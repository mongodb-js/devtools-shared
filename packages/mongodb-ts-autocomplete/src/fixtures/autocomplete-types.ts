const files = {
  '/bson.ts':
    "/**\n * A class representation of the BSON Binary type.\n * @public\n * @category BSONType\n */\nexport declare class Binary extends BSONValue {\n    get _bsontype(): 'Binary';\n    /* Excluded from this release type: BSON_BINARY_SUBTYPE_DEFAULT */\n    /** Initial buffer default size */\n    static readonly BUFFER_SIZE = 256;\n    /** Default BSON type */\n    static readonly SUBTYPE_DEFAULT = 0;\n    /** Function BSON type */\n    static readonly SUBTYPE_FUNCTION = 1;\n    /** Byte Array BSON type */\n    static readonly SUBTYPE_BYTE_ARRAY = 2;\n    /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */\n    static readonly SUBTYPE_UUID_OLD = 3;\n    /** UUID BSON type */\n    static readonly SUBTYPE_UUID = 4;\n    /** MD5 BSON type */\n    static readonly SUBTYPE_MD5 = 5;\n    /** Encrypted BSON type */\n    static readonly SUBTYPE_ENCRYPTED = 6;\n    /** Column BSON type */\n    static readonly SUBTYPE_COLUMN = 7;\n    /** Sensitive BSON type */\n    static readonly SUBTYPE_SENSITIVE = 8;\n    /** User BSON type */\n    static readonly SUBTYPE_USER_DEFINED = 128;\n    buffer: Uint8Array;\n    sub_type: number;\n    position: number;\n    /**\n     * Create a new Binary instance.\n     * @param buffer - a buffer object containing the binary data.\n     * @param subType - the option binary type.\n     */\n    constructor(buffer?: BinarySequence, subType?: number);\n    /**\n     * Updates this binary with byte_value.\n     *\n     * @param byteValue - a single byte we wish to write.\n     */\n    put(byteValue: string | number | Uint8Array | number[]): void;\n    /**\n     * Writes a buffer to the binary.\n     *\n     * @param sequence - a string or buffer to be written to the Binary BSON object.\n     * @param offset - specify the binary of where to write the content.\n     */\n    write(sequence: BinarySequence, offset: number): void;\n    /**\n     * Reads **length** bytes starting at **position**.\n     *\n     * @param position - read from the given position in the Binary.\n     * @param length - the number of bytes to read.\n     */\n    read(position: number, length: number): BinarySequence;\n    /** returns a view of the binary value as a Uint8Array */\n    value(): Uint8Array;\n    /** the length of the binary sequence */\n    length(): number;\n    toJSON(): string;\n    toString(encoding?: 'hex' | 'base64' | 'utf8' | 'utf-8'): string;\n    /* Excluded from this release type: toExtendedJSON */\n    toUUID(): UUID;\n    /** Creates an Binary instance from a hex digit string */\n    static createFromHexString(hex: string, subType?: number): Binary;\n    /** Creates an Binary instance from a base64 string */\n    static createFromBase64(base64: string, subType?: number): Binary;\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface BinaryExtended {\n    $binary: {\n        subType: string;\n        base64: string;\n    };\n}\n\n/** @public */\nexport declare interface BinaryExtendedLegacy {\n    $type: string;\n    $binary: string;\n}\n\n/** @public */\nexport declare type BinarySequence = Uint8Array | number[];\n\ndeclare namespace BSON {\n    export {\n        setInternalBufferSize,\n        serialize,\n        serializeWithBufferAndIndex,\n        deserialize,\n        calculateObjectSize,\n        deserializeStream,\n        UUIDExtended,\n        BinaryExtended,\n        BinaryExtendedLegacy,\n        BinarySequence,\n        CodeExtended,\n        DBRefLike,\n        Decimal128Extended,\n        DoubleExtended,\n        EJSONOptions,\n        Int32Extended,\n        LongExtended,\n        MaxKeyExtended,\n        MinKeyExtended,\n        ObjectIdExtended,\n        ObjectIdLike,\n        BSONRegExpExtended,\n        BSONRegExpExtendedLegacy,\n        BSONSymbolExtended,\n        LongWithoutOverrides,\n        TimestampExtended,\n        TimestampOverrides,\n        LongWithoutOverridesClass,\n        SerializeOptions,\n        DeserializeOptions,\n        Code,\n        BSONSymbol,\n        DBRef,\n        Binary,\n        ObjectId,\n        UUID,\n        Long,\n        Timestamp,\n        Double,\n        Int32,\n        MinKey,\n        MaxKey,\n        BSONRegExp,\n        Decimal128,\n        BSONValue,\n        BSONError,\n        BSONVersionError,\n        BSONRuntimeError,\n        BSONOffsetError,\n        BSONType,\n        EJSON,\n        onDemand,\n        OnDemand,\n        Document,\n        CalculateObjectSizeOptions\n    }\n}\nexport { BSON }\n\n/**\n * @public\n * @experimental\n */\ndeclare type BSONElement = [\ntype: number,\nnameOffset: number,\nnameLength: number,\noffset: number,\nlength: number\n];\n\n/**\n * @public\n * @category Error\n *\n * `BSONError` objects are thrown when BSON encounters an error.\n *\n * This is the parent class for all the other errors thrown by this library.\n */\nexport declare class BSONError extends Error {\n    /* Excluded from this release type: bsonError */\n    get name(): string;\n    constructor(message: string, options?: {\n        cause?: unknown;\n    });\n    /**\n     * @public\n     *\n     * All errors thrown from the BSON library inherit from `BSONError`.\n     * This method can assist with determining if an error originates from the BSON library\n     * even if it does not pass an `instanceof` check against this class' constructor.\n     *\n     * @param value - any javascript value that needs type checking\n     */\n    static isBSONError(value: unknown): value is BSONError;\n}\n\n/**\n * @public\n * @category Error\n *\n * @experimental\n *\n * An error generated when BSON bytes are invalid.\n * Reports the offset the parser was able to reach before encountering the error.\n */\nexport declare class BSONOffsetError extends BSONError {\n    get name(): 'BSONOffsetError';\n    offset: number;\n    constructor(message: string, offset: number, options?: {\n        cause?: unknown;\n    });\n}\n\n/**\n * A class representation of the BSON RegExp type.\n * @public\n * @category BSONType\n */\nexport declare class BSONRegExp extends BSONValue {\n    get _bsontype(): 'BSONRegExp';\n    pattern: string;\n    options: string;\n    /**\n     * @param pattern - The regular expression pattern to match\n     * @param options - The regular expression options\n     */\n    constructor(pattern: string, options?: string);\n    static parseOptions(options?: string): string;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface BSONRegExpExtended {\n    $regularExpression: {\n        pattern: string;\n        options: string;\n    };\n}\n\n/** @public */\nexport declare interface BSONRegExpExtendedLegacy {\n    $regex: string | BSONRegExp;\n    $options: string;\n}\n\n/**\n * @public\n * @category Error\n *\n * An error generated when BSON functions encounter an unexpected input\n * or reaches an unexpected/invalid internal state\n *\n */\nexport declare class BSONRuntimeError extends BSONError {\n    get name(): 'BSONRuntimeError';\n    constructor(message: string);\n}\n\n/**\n * A class representation of the BSON Symbol type.\n * @public\n * @category BSONType\n */\nexport declare class BSONSymbol extends BSONValue {\n    get _bsontype(): 'BSONSymbol';\n    value: string;\n    /**\n     * @param value - the string representing the symbol.\n     */\n    constructor(value: string);\n    /** Access the wrapped string value. */\n    valueOf(): string;\n    toString(): string;\n    toJSON(): string;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface BSONSymbolExtended {\n    $symbol: string;\n}\n\n/** @public */\nexport declare const BSONType: Readonly<{\n    readonly double: 1;\n    readonly string: 2;\n    readonly object: 3;\n    readonly array: 4;\n    readonly binData: 5;\n    readonly undefined: 6;\n    readonly objectId: 7;\n    readonly bool: 8;\n    readonly date: 9;\n    readonly null: 10;\n    readonly regex: 11;\n    readonly dbPointer: 12;\n    readonly javascript: 13;\n    readonly symbol: 14;\n    readonly javascriptWithScope: 15;\n    readonly int: 16;\n    readonly timestamp: 17;\n    readonly long: 18;\n    readonly decimal: 19;\n    readonly minKey: -1;\n    readonly maxKey: 127;\n}>;\n\n/** @public */\nexport declare type BSONType = (typeof BSONType)[keyof typeof BSONType];\n\n/** @public */\nexport declare abstract class BSONValue {\n    /** @public */\n    abstract get _bsontype(): string;\n    /**\n     * @public\n     * Prints a human-readable string of BSON value information\n     * If invoked manually without node.js.inspect function, this will default to a modified JSON.stringify\n     */\n    abstract inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n    /* Excluded from this release type: toExtendedJSON */\n}\n\n/**\n * @public\n * @category Error\n */\nexport declare class BSONVersionError extends BSONError {\n    get name(): 'BSONVersionError';\n    constructor();\n}\n\n/**\n * @public\n * @experimental\n *\n * A collection of functions that help work with data in a Uint8Array.\n * ByteUtils is configured at load time to use Node.js or Web based APIs for the internal implementations.\n */\ndeclare type ByteUtils = {\n    /** Transforms the input to an instance of Buffer if running on node, otherwise Uint8Array */\n    toLocalBufferType: (buffer: Uint8Array | ArrayBufferView | ArrayBuffer) => Uint8Array;\n    /** Create empty space of size */\n    allocate: (size: number) => Uint8Array;\n    /** Create empty space of size, use pooled memory when available */\n    allocateUnsafe: (size: number) => Uint8Array;\n    /** Check if two Uint8Arrays are deep equal */\n    equals: (a: Uint8Array, b: Uint8Array) => boolean;\n    /** Check if two Uint8Arrays are deep equal */\n    fromNumberArray: (array: number[]) => Uint8Array;\n    /** Create a Uint8Array from a base64 string */\n    fromBase64: (base64: string) => Uint8Array;\n    /** Create a base64 string from bytes */\n    toBase64: (buffer: Uint8Array) => string;\n    /** **Legacy** binary strings are an outdated method of data transfer. Do not add public API support for interpreting this format */\n    fromISO88591: (codePoints: string) => Uint8Array;\n    /** **Legacy** binary strings are an outdated method of data transfer. Do not add public API support for interpreting this format */\n    toISO88591: (buffer: Uint8Array) => string;\n    /** Create a Uint8Array from a hex string */\n    fromHex: (hex: string) => Uint8Array;\n    /** Create a lowercase hex string from bytes */\n    toHex: (buffer: Uint8Array) => string;\n    /** Create a string from utf8 code units, fatal=true will throw an error if UTF-8 bytes are invalid, fatal=false will insert replacement characters */\n    toUTF8: (buffer: Uint8Array, start: number, end: number, fatal: boolean) => string;\n    /** Get the utf8 code unit count from a string if it were to be transformed to utf8 */\n    utf8ByteLength: (input: string) => number;\n    /** Encode UTF8 bytes generated from `source` string into `destination` at byteOffset. Returns the number of bytes encoded. */\n    encodeUTF8Into: (destination: Uint8Array, source: string, byteOffset: number) => number;\n    /** Generate a Uint8Array filled with random bytes with byteLength */\n    randomBytes: (byteLength: number) => Uint8Array;\n};\n\n/* Excluded declaration from this release type: ByteUtils */\n\n/**\n * Calculate the bson size for a passed in Javascript object.\n *\n * @param object - the Javascript object to calculate the BSON byte size for\n * @returns size of BSON object in bytes\n * @public\n */\nexport declare function calculateObjectSize(object: Document, options?: CalculateObjectSizeOptions): number;\n\n/** @public */\nexport declare type CalculateObjectSizeOptions = Pick<SerializeOptions, 'serializeFunctions' | 'ignoreUndefined'>;\n\n/**\n * A class representation of the BSON Code type.\n * @public\n * @category BSONType\n */\nexport declare class Code extends BSONValue {\n    get _bsontype(): 'Code';\n    code: string;\n    scope: Document | null;\n    /**\n     * @param code - a string or function.\n     * @param scope - an optional scope for the function.\n     */\n    constructor(code: string | Function, scope?: Document | null);\n    toJSON(): {\n        code: string;\n        scope?: Document;\n    };\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface CodeExtended {\n    $code: string;\n    $scope?: Document;\n}\n\n/**\n * A class representation of the BSON DBRef type.\n * @public\n * @category BSONType\n */\nexport declare class DBRef extends BSONValue {\n    get _bsontype(): 'DBRef';\n    collection: string;\n    oid: ObjectId;\n    db?: string;\n    fields: Document;\n    /**\n     * @param collection - the collection name.\n     * @param oid - the reference ObjectId.\n     * @param db - optional db name, if omitted the reference is local to the current db.\n     */\n    constructor(collection: string, oid: ObjectId, db?: string, fields?: Document);\n    /* Excluded from this release type: namespace */\n    /* Excluded from this release type: namespace */\n    toJSON(): DBRefLike & Document;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface DBRefLike {\n    $ref: string;\n    $id: ObjectId;\n    $db?: string;\n}\n\n/**\n * A class representation of the BSON Decimal128 type.\n * @public\n * @category BSONType\n */\nexport declare class Decimal128 extends BSONValue {\n    get _bsontype(): 'Decimal128';\n    readonly bytes: Uint8Array;\n    /**\n     * @param bytes - a buffer containing the raw Decimal128 bytes in little endian order,\n     *                or a string representation as returned by .toString()\n     */\n    constructor(bytes: Uint8Array | string);\n    /**\n     * Create a Decimal128 instance from a string representation\n     *\n     * @param representation - a numeric string representation.\n     */\n    static fromString(representation: string): Decimal128;\n    /**\n     * Create a Decimal128 instance from a string representation, allowing for rounding to 34\n     * significant digits\n     *\n     * @example Example of a number that will be rounded\n     * ```ts\n     * > let d = Decimal128.fromString('37.499999999999999196428571428571375')\n     * Uncaught:\n     * BSONError: \"37.499999999999999196428571428571375\" is not a valid Decimal128 string - inexact rounding\n     * at invalidErr (/home/wajames/js-bson/lib/bson.cjs:1402:11)\n     * at Decimal128.fromStringInternal (/home/wajames/js-bson/lib/bson.cjs:1633:25)\n     * at Decimal128.fromString (/home/wajames/js-bson/lib/bson.cjs:1424:27)\n     *\n     * > d = Decimal128.fromStringWithRounding('37.499999999999999196428571428571375')\n     * new Decimal128(\"37.49999999999999919642857142857138\")\n     * ```\n     * @param representation - a numeric string representation.\n     */\n    static fromStringWithRounding(representation: string): Decimal128;\n    private static _fromString;\n    /** Create a string representation of the raw Decimal128 value */\n    toString(): string;\n    toJSON(): Decimal128Extended;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface Decimal128Extended {\n    $numberDecimal: string;\n}\n\n/**\n * Deserialize data as BSON.\n *\n * @param buffer - the buffer containing the serialized set of BSON documents.\n * @returns returns the deserialized Javascript Object.\n * @public\n */\nexport declare function deserialize(buffer: Uint8Array, options?: DeserializeOptions): Document;\n\n/** @public */\nexport declare interface DeserializeOptions {\n    /**\n     * when deserializing a Long return as a BigInt.\n     * @defaultValue `false`\n     */\n    useBigInt64?: boolean;\n    /**\n     * when deserializing a Long will fit it into a Number if it's smaller than 53 bits.\n     * @defaultValue `true`\n     */\n    promoteLongs?: boolean;\n    /**\n     * when deserializing a Binary will return it as a node.js Buffer instance.\n     * @defaultValue `false`\n     */\n    promoteBuffers?: boolean;\n    /**\n     * when deserializing will promote BSON values to their Node.js closest equivalent types.\n     * @defaultValue `true`\n     */\n    promoteValues?: boolean;\n    /**\n     * allow to specify if there what fields we wish to return as unserialized raw buffer.\n     * @defaultValue `null`\n     */\n    fieldsAsRaw?: Document;\n    /**\n     * return BSON regular expressions as BSONRegExp instances.\n     * @defaultValue `false`\n     */\n    bsonRegExp?: boolean;\n    /**\n     * allows the buffer to be larger than the parsed BSON object.\n     * @defaultValue `false`\n     */\n    allowObjectSmallerThanBufferSize?: boolean;\n    /**\n     * Offset into buffer to begin reading document from\n     * @defaultValue `0`\n     */\n    index?: number;\n    raw?: boolean;\n    /** Allows for opt-out utf-8 validation for all keys or\n     * specified keys. Must be all true or all false.\n     *\n     * @example\n     * ```js\n     * // disables validation on all keys\n     *  validation: { utf8: false }\n     *\n     * // enables validation only on specified keys a, b, and c\n     *  validation: { utf8: { a: true, b: true, c: true } }\n     *\n     *  // disables validation only on specified keys a, b\n     *  validation: { utf8: { a: false, b: false } }\n     * ```\n     */\n    validation?: {\n        utf8: boolean | Record<string, true> | Record<string, false>;\n    };\n}\n\n/**\n * Deserialize stream data as BSON documents.\n *\n * @param data - the buffer containing the serialized set of BSON documents.\n * @param startIndex - the start index in the data Buffer where the deserialization is to start.\n * @param numberOfDocuments - number of documents to deserialize.\n * @param documents - an array where to store the deserialized documents.\n * @param docStartIndex - the index in the documents array from where to start inserting documents.\n * @param options - additional options used for the deserialization.\n * @returns next index in the buffer after deserialization **x** numbers of documents.\n * @public\n */\nexport declare function deserializeStream(data: Uint8Array | ArrayBuffer, startIndex: number, numberOfDocuments: number, documents: Document[], docStartIndex: number, options: DeserializeOptions): number;\n\n/** @public */\nexport declare interface Document {\n    [key: string]: any;\n}\n\n/**\n * A class representation of the BSON Double type.\n * @public\n * @category BSONType\n */\nexport declare class Double extends BSONValue {\n    get _bsontype(): 'Double';\n    value: number;\n    /**\n     * Create a Double type\n     *\n     * @param value - the number we want to represent as a double.\n     */\n    constructor(value: number);\n    /**\n     * Attempt to create an double type from string.\n     *\n     * This method will throw a BSONError on any string input that is not representable as a IEEE-754 64-bit double.\n     * Notably, this method will also throw on the following string formats:\n     * - Strings in non-decimal and non-exponential formats (binary, hex, or octal digits)\n     * - Strings with characters other than numeric, floating point, or leading sign characters (Note: 'Infinity', '-Infinity', and 'NaN' input strings are still allowed)\n     * - Strings with leading and/or trailing whitespace\n     *\n     * Strings with leading zeros, however, are also allowed\n     *\n     * @param value - the string we want to represent as a double.\n     */\n    static fromString(value: string): Double;\n    /**\n     * Access the number value.\n     *\n     * @returns returns the wrapped double number.\n     */\n    valueOf(): number;\n    toJSON(): number;\n    toString(radix?: number): string;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface DoubleExtended {\n    $numberDouble: string;\n}\n\n/** @public */\nexport declare const EJSON: {\n    parse: typeof parse;\n    stringify: typeof stringify;\n    serialize: typeof EJSONserialize;\n    deserialize: typeof EJSONdeserialize;\n};\n\n/**\n * Deserializes an Extended JSON object into a plain JavaScript object with native/BSON types\n *\n * @param ejson - The Extended JSON object to deserialize\n * @param options - Optional settings passed to the parse method\n */\ndeclare function EJSONdeserialize(ejson: Document, options?: EJSONOptions): any;\n\n/** @public */\nexport declare type EJSONOptions = {\n    /**\n     * Output using the Extended JSON v1 spec\n     * @defaultValue `false`\n     */\n    legacy?: boolean;\n    /**\n     * Enable Extended JSON's `relaxed` mode, which attempts to return native JS types where possible, rather than BSON types\n     * @defaultValue `false` */\n    relaxed?: boolean;\n    /**\n     * Enable native bigint support\n     * @defaultValue `false`\n     */\n    useBigInt64?: boolean;\n};\n\n/**\n * Serializes an object to an Extended JSON string, and reparse it as a JavaScript object.\n *\n * @param value - The object to serialize\n * @param options - Optional settings passed to the `stringify` function\n */\ndeclare function EJSONserialize(value: any, options?: EJSONOptions): Document;\n\ndeclare type InspectFn = (x: unknown, options?: unknown) => string;\n\n/**\n * A class representation of a BSON Int32 type.\n * @public\n * @category BSONType\n */\nexport declare class Int32 extends BSONValue {\n    get _bsontype(): 'Int32';\n    value: number;\n    /**\n     * Create an Int32 type\n     *\n     * @param value - the number we want to represent as an int32.\n     */\n    constructor(value: number | string);\n    /**\n     * Attempt to create an Int32 type from string.\n     *\n     * This method will throw a BSONError on any string input that is not representable as an Int32.\n     * Notably, this method will also throw on the following string formats:\n     * - Strings in non-decimal formats (exponent notation, binary, hex, or octal digits)\n     * - Strings non-numeric and non-leading sign characters (ex: '2.0', '24,000')\n     * - Strings with leading and/or trailing whitespace\n     *\n     * Strings with leading zeros, however, are allowed.\n     *\n     * @param value - the string we want to represent as an int32.\n     */\n    static fromString(value: string): Int32;\n    /**\n     * Access the number value.\n     *\n     * @returns returns the wrapped int32 number.\n     */\n    valueOf(): number;\n    toString(radix?: number): string;\n    toJSON(): number;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface Int32Extended {\n    $numberInt: string;\n}\n\n/**\n * A class representing a 64-bit integer\n * @public\n * @category BSONType\n * @remarks\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16 bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n * Common constant values ZERO, ONE, NEG_ONE, etc. are found as static properties on this class.\n */\nexport declare class Long extends BSONValue {\n    get _bsontype(): 'Long';\n    /** An indicator used to reliably determine if an object is a Long or not. */\n    get __isLong__(): boolean;\n    /**\n     * The high 32 bits as a signed value.\n     */\n    high: number;\n    /**\n     * The low 32 bits as a signed value.\n     */\n    low: number;\n    /**\n     * Whether unsigned or not.\n     */\n    unsigned: boolean;\n    /**\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n     *\n     * @param low - The low (signed) 32 bits of the long\n     * @param high - The high (signed) 32 bits of the long\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     */\n    constructor(low: number, high?: number, unsigned?: boolean);\n    /**\n     * Constructs a 64 bit two's-complement integer, given a bigint representation.\n     *\n     * @param value - BigInt representation of the long value\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     */\n    constructor(value: bigint, unsigned?: boolean);\n    /**\n     * Constructs a 64 bit two's-complement integer, given a string representation.\n     *\n     * @param value - String representation of the long value\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     */\n    constructor(value: string, unsigned?: boolean);\n    static TWO_PWR_24: Long;\n    /** Maximum unsigned value. */\n    static MAX_UNSIGNED_VALUE: Long;\n    /** Signed zero */\n    static ZERO: Long;\n    /** Unsigned zero. */\n    static UZERO: Long;\n    /** Signed one. */\n    static ONE: Long;\n    /** Unsigned one. */\n    static UONE: Long;\n    /** Signed negative one. */\n    static NEG_ONE: Long;\n    /** Maximum signed value. */\n    static MAX_VALUE: Long;\n    /** Minimum signed value. */\n    static MIN_VALUE: Long;\n    /**\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits.\n     * Each is assumed to use 32 bits.\n     * @param lowBits - The low 32 bits\n     * @param highBits - The high 32 bits\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long;\n    /**\n     * Returns a Long representing the given 32 bit integer value.\n     * @param value - The 32 bit integer in question\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromInt(value: number, unsigned?: boolean): Long;\n    /**\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n     * @param value - The number in question\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromNumber(value: number, unsigned?: boolean): Long;\n    /**\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n     * @param value - The number in question\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromBigInt(value: bigint, unsigned?: boolean): Long;\n    /* Excluded from this release type: _fromString */\n    /**\n     * Returns a signed Long representation of the given string, written using radix 10.\n     * Will throw an error if the given text is not exactly representable as a Long.\n     * Throws an error if any of the following conditions are true:\n     * - the string contains invalid characters for the radix 10\n     * - the string contains whitespace\n     * - the value the string represents is too large or too small to be a Long\n     * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n     * @param str - The textual representation of the Long\n     * @returns The corresponding Long value\n     */\n    static fromStringStrict(str: string): Long;\n    /**\n     * Returns a Long representation of the given string, written using the radix 10.\n     * Will throw an error if the given parameters are not exactly representable as a Long.\n     * Throws an error if any of the following conditions are true:\n     * - the string contains invalid characters for the given radix\n     * - the string contains whitespace\n     * - the value the string represents is too large or too small to be a Long\n     * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n     * @param str - The textual representation of the Long\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromStringStrict(str: string, unsigned?: boolean): Long;\n    /**\n     * Returns a signed Long representation of the given string, written using the specified radix.\n     * Will throw an error if the given parameters are not exactly representable as a Long.\n     * Throws an error if any of the following conditions are true:\n     * - the string contains invalid characters for the given radix\n     * - the string contains whitespace\n     * - the value the string represents is too large or too small to be a Long\n     * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n     * @param str - The textual representation of the Long\n     * @param radix - The radix in which the text is written (2-36), defaults to 10\n     * @returns The corresponding Long value\n     */\n    static fromStringStrict(str: string, radix?: boolean): Long;\n    /**\n     * Returns a Long representation of the given string, written using the specified radix.\n     * Will throw an error if the given parameters are not exactly representable as a Long.\n     * Throws an error if any of the following conditions are true:\n     * - the string contains invalid characters for the given radix\n     * - the string contains whitespace\n     * - the value the string represents is too large or too small to be a Long\n     * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n     * @param str - The textual representation of the Long\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @param radix - The radix in which the text is written (2-36), defaults to 10\n     * @returns The corresponding Long value\n     */\n    static fromStringStrict(str: string, unsigned?: boolean, radix?: number): Long;\n    /**\n     * Returns a signed Long representation of the given string, written using radix 10.\n     *\n     * If the input string is empty, this function will throw a BSONError.\n     *\n     * If input string does not have valid signed 64-bit Long representation, this method will return a coerced value:\n     * - inputs that overflow 64-bit signed long will be coerced to Long.MAX_VALUE and Long.MIN_VALUE respectively\n     * - 'NaN' or '+/-Infinity' are coerced to Long.ZERO\n     * - other invalid characters sequences have variable behavior\n     *\n     * @param str - The textual representation of the Long\n     * @returns The corresponding Long value\n     */\n    static fromString(str: string): Long;\n    /**\n     * Returns a signed Long representation of the given string, written using the provided radix.\n     *\n     * If the input string is empty or a provided radix is not within (2-36), this function will throw a BSONError.\n     *\n     * If input parameters do not have valid signed 64-bit Long representation, this method will return a coerced value:\n     * - inputs that overflow 64-bit signed long will be coerced to Long.MAX_VALUE and Long.MIN_VALUE respectively\n     * - if the radix is less than 24, 'NaN' is coerced to Long.ZERO\n     * - if the radix is less than 35, '+/-Infinity' inputs are coerced to Long.ZERO\n     * - other invalid characters sequences have variable behavior\n     * @param str - The textual representation of the Long\n     * @param radix - The radix in which the text is written (2-36), defaults to 10\n     * @returns The corresponding Long value\n     */\n    static fromString(str: string, radix?: number): Long;\n    /**\n     * Returns a Long representation of the given string, written using radix 10.\n     *\n     * If the input string is empty, this function will throw a BSONError.\n     *\n     * If input parameters do not have a valid 64-bit Long representation, this method will return a coerced value:\n     * - inputs that overflow 64-bit long will be coerced to max or min (if signed) values\n     * - if the radix is less than 24, 'NaN' is coerced to Long.ZERO\n     * - if the radix is less than 35, '+/-Infinity' inputs are coerced to Long.ZERO\n     * - other invalid characters sequences have variable behavior\n     * @param str - The textual representation of the Long\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromString(str: string, unsigned?: boolean): Long;\n    /**\n     * Returns a Long representation of the given string, written using the specified radix.\n     *\n     * If the input string is empty or a provided radix is not within (2-36), this function will throw a BSONError.\n     *\n     * If input parameters do not have a valid 64-bit Long representation, this method will return a coerced value:\n     * - inputs that overflow 64-bit long will be coerced to max or min (if signed) values\n     * - if the radix is less than 24, 'NaN' is coerced to Long.ZERO\n     * - if the radix is less than 35, '+/-Infinity' inputs are coerced to Long.ZERO\n     * - other invalid characters sequences have variable behavior\n     * @param str - The textual representation of the Long\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @param radix - The radix in which the text is written (2-36), defaults to 10\n     * @returns The corresponding Long value\n     */\n    static fromString(str: string, unsigned?: boolean, radix?: number): Long;\n    /**\n     * Creates a Long from its byte representation.\n     * @param bytes - Byte representation\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @param le - Whether little or big endian, defaults to big endian\n     * @returns The corresponding Long value\n     */\n    static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long;\n    /**\n     * Creates a Long from its little endian byte representation.\n     * @param bytes - Little endian byte representation\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromBytesLE(bytes: number[], unsigned?: boolean): Long;\n    /**\n     * Creates a Long from its big endian byte representation.\n     * @param bytes - Big endian byte representation\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     * @returns The corresponding Long value\n     */\n    static fromBytesBE(bytes: number[], unsigned?: boolean): Long;\n    /**\n     * Tests if the specified object is a Long.\n     */\n    static isLong(value: unknown): value is Long;\n    /**\n     * Converts the specified value to a Long.\n     * @param unsigned - Whether unsigned or not, defaults to signed\n     */\n    static fromValue(val: number | string | {\n        low: number;\n        high: number;\n        unsigned?: boolean;\n    }, unsigned?: boolean): Long;\n    /** Returns the sum of this and the specified Long. */\n    add(addend: string | number | Long | Timestamp): Long;\n    /**\n     * Returns the sum of this and the specified Long.\n     * @returns Sum\n     */\n    and(other: string | number | Long | Timestamp): Long;\n    /**\n     * Compares this Long's value with the specified's.\n     * @returns 0 if they are the same, 1 if the this is greater and -1 if the given one is greater\n     */\n    compare(other: string | number | Long | Timestamp): 0 | 1 | -1;\n    /** This is an alias of {@link Long.compare} */\n    comp(other: string | number | Long | Timestamp): 0 | 1 | -1;\n    /**\n     * Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.\n     * @returns Quotient\n     */\n    divide(divisor: string | number | Long | Timestamp): Long;\n    /**This is an alias of {@link Long.divide} */\n    div(divisor: string | number | Long | Timestamp): Long;\n    /**\n     * Tests if this Long's value equals the specified's.\n     * @param other - Other value\n     */\n    equals(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.equals} */\n    eq(other: string | number | Long | Timestamp): boolean;\n    /** Gets the high 32 bits as a signed integer. */\n    getHighBits(): number;\n    /** Gets the high 32 bits as an unsigned integer. */\n    getHighBitsUnsigned(): number;\n    /** Gets the low 32 bits as a signed integer. */\n    getLowBits(): number;\n    /** Gets the low 32 bits as an unsigned integer. */\n    getLowBitsUnsigned(): number;\n    /** Gets the number of bits needed to represent the absolute value of this Long. */\n    getNumBitsAbs(): number;\n    /** Tests if this Long's value is greater than the specified's. */\n    greaterThan(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.greaterThan} */\n    gt(other: string | number | Long | Timestamp): boolean;\n    /** Tests if this Long's value is greater than or equal the specified's. */\n    greaterThanOrEqual(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.greaterThanOrEqual} */\n    gte(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.greaterThanOrEqual} */\n    ge(other: string | number | Long | Timestamp): boolean;\n    /** Tests if this Long's value is even. */\n    isEven(): boolean;\n    /** Tests if this Long's value is negative. */\n    isNegative(): boolean;\n    /** Tests if this Long's value is odd. */\n    isOdd(): boolean;\n    /** Tests if this Long's value is positive. */\n    isPositive(): boolean;\n    /** Tests if this Long's value equals zero. */\n    isZero(): boolean;\n    /** Tests if this Long's value is less than the specified's. */\n    lessThan(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long#lessThan}. */\n    lt(other: string | number | Long | Timestamp): boolean;\n    /** Tests if this Long's value is less than or equal the specified's. */\n    lessThanOrEqual(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.lessThanOrEqual} */\n    lte(other: string | number | Long | Timestamp): boolean;\n    /** Returns this Long modulo the specified. */\n    modulo(divisor: string | number | Long | Timestamp): Long;\n    /** This is an alias of {@link Long.modulo} */\n    mod(divisor: string | number | Long | Timestamp): Long;\n    /** This is an alias of {@link Long.modulo} */\n    rem(divisor: string | number | Long | Timestamp): Long;\n    /**\n     * Returns the product of this and the specified Long.\n     * @param multiplier - Multiplier\n     * @returns Product\n     */\n    multiply(multiplier: string | number | Long | Timestamp): Long;\n    /** This is an alias of {@link Long.multiply} */\n    mul(multiplier: string | number | Long | Timestamp): Long;\n    /** Returns the Negation of this Long's value. */\n    negate(): Long;\n    /** This is an alias of {@link Long.negate} */\n    neg(): Long;\n    /** Returns the bitwise NOT of this Long. */\n    not(): Long;\n    /** Tests if this Long's value differs from the specified's. */\n    notEquals(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.notEquals} */\n    neq(other: string | number | Long | Timestamp): boolean;\n    /** This is an alias of {@link Long.notEquals} */\n    ne(other: string | number | Long | Timestamp): boolean;\n    /**\n     * Returns the bitwise OR of this Long and the specified.\n     */\n    or(other: number | string | Long): Long;\n    /**\n     * Returns this Long with bits shifted to the left by the given amount.\n     * @param numBits - Number of bits\n     * @returns Shifted Long\n     */\n    shiftLeft(numBits: number | Long): Long;\n    /** This is an alias of {@link Long.shiftLeft} */\n    shl(numBits: number | Long): Long;\n    /**\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\n     * @param numBits - Number of bits\n     * @returns Shifted Long\n     */\n    shiftRight(numBits: number | Long): Long;\n    /** This is an alias of {@link Long.shiftRight} */\n    shr(numBits: number | Long): Long;\n    /**\n     * Returns this Long with bits logically shifted to the right by the given amount.\n     * @param numBits - Number of bits\n     * @returns Shifted Long\n     */\n    shiftRightUnsigned(numBits: Long | number): Long;\n    /** This is an alias of {@link Long.shiftRightUnsigned} */\n    shr_u(numBits: number | Long): Long;\n    /** This is an alias of {@link Long.shiftRightUnsigned} */\n    shru(numBits: number | Long): Long;\n    /**\n     * Returns the difference of this and the specified Long.\n     * @param subtrahend - Subtrahend\n     * @returns Difference\n     */\n    subtract(subtrahend: string | number | Long | Timestamp): Long;\n    /** This is an alias of {@link Long.subtract} */\n    sub(subtrahend: string | number | Long | Timestamp): Long;\n    /** Converts the Long to a 32 bit integer, assuming it is a 32 bit integer. */\n    toInt(): number;\n    /** Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa). */\n    toNumber(): number;\n    /** Converts the Long to a BigInt (arbitrary precision). */\n    toBigInt(): bigint;\n    /**\n     * Converts this Long to its byte representation.\n     * @param le - Whether little or big endian, defaults to big endian\n     * @returns Byte representation\n     */\n    toBytes(le?: boolean): number[];\n    /**\n     * Converts this Long to its little endian byte representation.\n     * @returns Little endian byte representation\n     */\n    toBytesLE(): number[];\n    /**\n     * Converts this Long to its big endian byte representation.\n     * @returns Big endian byte representation\n     */\n    toBytesBE(): number[];\n    /**\n     * Converts this Long to signed.\n     */\n    toSigned(): Long;\n    /**\n     * Converts the Long to a string written in the specified radix.\n     * @param radix - Radix (2-36), defaults to 10\n     * @throws RangeError If `radix` is out of range\n     */\n    toString(radix?: number): string;\n    /** Converts this Long to unsigned. */\n    toUnsigned(): Long;\n    /** Returns the bitwise XOR of this Long and the given one. */\n    xor(other: Long | number | string): Long;\n    /** This is an alias of {@link Long.isZero} */\n    eqz(): boolean;\n    /** This is an alias of {@link Long.lessThanOrEqual} */\n    le(other: string | number | Long | Timestamp): boolean;\n    toExtendedJSON(options?: EJSONOptions): number | LongExtended;\n    static fromExtendedJSON(doc: {\n        $numberLong: string;\n    }, options?: EJSONOptions): number | Long | bigint;\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface LongExtended {\n    $numberLong: string;\n}\n\n/** @public */\nexport declare type LongWithoutOverrides = new (low: unknown, high?: number | boolean, unsigned?: boolean) => {\n    [P in Exclude<keyof Long, TimestampOverrides>]: Long[P];\n};\n\n/** @public */\nexport declare const LongWithoutOverridesClass: LongWithoutOverrides;\n\n/**\n * A class representation of the BSON MaxKey type.\n * @public\n * @category BSONType\n */\nexport declare class MaxKey extends BSONValue {\n    get _bsontype(): 'MaxKey';\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(): string;\n}\n\n/** @public */\nexport declare interface MaxKeyExtended {\n    $maxKey: 1;\n}\n\n/**\n * A class representation of the BSON MinKey type.\n * @public\n * @category BSONType\n */\nexport declare class MinKey extends BSONValue {\n    get _bsontype(): 'MinKey';\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(): string;\n}\n\n/** @public */\nexport declare interface MinKeyExtended {\n    $minKey: 1;\n}\n\n/**\n * @experimental\n * @public\n *\n * A collection of functions that get or set various numeric types and bit widths from a Uint8Array.\n */\ndeclare type NumberUtils = {\n    /**\n     * Parses a signed int32 at offset. Throws a `RangeError` if value is negative.\n     */\n    getNonnegativeInt32LE: (source: Uint8Array, offset: number) => number;\n    getInt32LE: (source: Uint8Array, offset: number) => number;\n    getUint32LE: (source: Uint8Array, offset: number) => number;\n    getUint32BE: (source: Uint8Array, offset: number) => number;\n    getBigInt64LE: (source: Uint8Array, offset: number) => bigint;\n    getFloat64LE: (source: Uint8Array, offset: number) => number;\n    setInt32BE: (destination: Uint8Array, offset: number, value: number) => 4;\n    setInt32LE: (destination: Uint8Array, offset: number, value: number) => 4;\n    setBigInt64LE: (destination: Uint8Array, offset: number, value: bigint) => 8;\n    setFloat64LE: (destination: Uint8Array, offset: number, value: number) => 8;\n};\n\n/**\n * Number parsing and serializing utilities.\n *\n * @experimental\n * @public\n */\ndeclare const NumberUtils: NumberUtils;\n\n/**\n * A class representation of the BSON ObjectId type.\n * @public\n * @category BSONType\n */\nexport declare class ObjectId extends BSONValue {\n    get _bsontype(): 'ObjectId';\n    /* Excluded from this release type: index */\n    static cacheHexString: boolean;\n    /* Excluded from this release type: buffer */\n    /* Excluded from this release type: __id */\n    /**\n     * Create ObjectId from a number.\n     *\n     * @param inputId - A number.\n     * @deprecated Instead, use `static createFromTime()` to set a numeric value for the new ObjectId.\n     */\n    constructor(inputId: number);\n    /**\n     * Create ObjectId from a 24 character hex string.\n     *\n     * @param inputId - A 24 character hex string.\n     */\n    constructor(inputId: string);\n    /**\n     * Create ObjectId from the BSON ObjectId type.\n     *\n     * @param inputId - The BSON ObjectId type.\n     */\n    constructor(inputId: ObjectId);\n    /**\n     * Create ObjectId from the object type that has the toHexString method.\n     *\n     * @param inputId - The ObjectIdLike type.\n     */\n    constructor(inputId: ObjectIdLike);\n    /**\n     * Create ObjectId from a 12 byte binary Buffer.\n     *\n     * @param inputId - A 12 byte binary Buffer.\n     */\n    constructor(inputId: Uint8Array);\n    /** To generate a new ObjectId, use ObjectId() with no argument. */\n    constructor();\n    /**\n     * Implementation overload.\n     *\n     * @param inputId - All input types that are used in the constructor implementation.\n     */\n    constructor(inputId?: string | number | ObjectId | ObjectIdLike | Uint8Array);\n    /**\n     * The ObjectId bytes\n     * @readonly\n     */\n    get id(): Uint8Array;\n    set id(value: Uint8Array);\n    /** Returns the ObjectId id as a 24 lowercase character hex string representation */\n    toHexString(): string;\n    /* Excluded from this release type: getInc */\n    /**\n     * Generate a 12 byte id buffer used in ObjectId's\n     *\n     * @param time - pass in a second based timestamp.\n     */\n    static generate(time?: number): Uint8Array;\n    /**\n     * Converts the id into a 24 character hex string for printing, unless encoding is provided.\n     * @param encoding - hex or base64\n     */\n    toString(encoding?: 'hex' | 'base64'): string;\n    /** Converts to its JSON the 24 character hex string representation. */\n    toJSON(): string;\n    /* Excluded from this release type: is */\n    /**\n     * Compares the equality of this ObjectId with `otherID`.\n     *\n     * @param otherId - ObjectId instance to compare against.\n     */\n    equals(otherId: string | ObjectId | ObjectIdLike | undefined | null): boolean;\n    /** Returns the generation date (accurate up to the second) that this ID was generated. */\n    getTimestamp(): Date;\n    /* Excluded from this release type: createPk */\n    /* Excluded from this release type: serializeInto */\n    /**\n     * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\n     *\n     * @param time - an integer number representing a number of seconds.\n     */\n    static createFromTime(time: number): ObjectId;\n    /**\n     * Creates an ObjectId from a hex string representation of an ObjectId.\n     *\n     * @param hexString - create a ObjectId from a passed in 24 character hexstring.\n     */\n    static createFromHexString(hexString: string): ObjectId;\n    /** Creates an ObjectId instance from a base64 string */\n    static createFromBase64(base64: string): ObjectId;\n    /**\n     * Checks if a value can be used to create a valid bson ObjectId\n     * @param id - any JS value\n     */\n    static isValid(id: string | number | ObjectId | ObjectIdLike | Uint8Array): boolean;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    /**\n     * Converts to a string representation of this Id.\n     *\n     * @returns return the 24 character hex string representation.\n     */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface ObjectIdExtended {\n    $oid: string;\n}\n\n/** @public */\nexport declare interface ObjectIdLike {\n    id: string | Uint8Array;\n    __id?: string;\n    toHexString(): string;\n}\n\n/**\n * @experimental\n * @public\n *\n * A new set of BSON APIs that are currently experimental and not intended for production use.\n */\nexport declare type OnDemand = {\n    parseToElements: (this: void, bytes: Uint8Array, startOffset?: number) => Iterable<BSONElement>;\n    BSONElement: BSONElement;\n    ByteUtils: ByteUtils;\n    NumberUtils: NumberUtils;\n};\n\n/**\n * @experimental\n * @public\n */\nexport declare const onDemand: OnDemand;\n\n/**\n * Parse an Extended JSON string, constructing the JavaScript value or object described by that\n * string.\n *\n * @example\n * ```js\n * const { EJSON } = require('bson');\n * const text = '{ \"int32\": { \"$numberInt\": \"10\" } }';\n *\n * // prints { int32: { [String: '10'] _bsontype: 'Int32', value: '10' } }\n * console.log(EJSON.parse(text, { relaxed: false }));\n *\n * // prints { int32: 10 }\n * console.log(EJSON.parse(text));\n * ```\n */\ndeclare function parse(text: string, options?: EJSONOptions): any;\n\n/**\n * Serialize a Javascript object.\n *\n * @param object - the Javascript object to serialize.\n * @returns Buffer object containing the serialized object.\n * @public\n */\nexport declare function serialize(object: Document, options?: SerializeOptions): Uint8Array;\n\n/** @public */\nexport declare interface SerializeOptions {\n    /**\n     * the serializer will check if keys are valid.\n     * @defaultValue `false`\n     */\n    checkKeys?: boolean;\n    /**\n     * serialize the javascript functions\n     * @defaultValue `false`\n     */\n    serializeFunctions?: boolean;\n    /**\n     * serialize will not emit undefined fields\n     * note that the driver sets this to `false`\n     * @defaultValue `true`\n     */\n    ignoreUndefined?: boolean;\n    /* Excluded from this release type: minInternalBufferSize */\n    /**\n     * the index in the buffer where we wish to start serializing into\n     * @defaultValue `0`\n     */\n    index?: number;\n}\n\n/**\n * Serialize a Javascript object using a predefined Buffer and index into the buffer,\n * useful when pre-allocating the space for serialization.\n *\n * @param object - the Javascript object to serialize.\n * @param finalBuffer - the Buffer you pre-allocated to store the serialized BSON object.\n * @returns the index pointing to the last written byte in the buffer.\n * @public\n */\nexport declare function serializeWithBufferAndIndex(object: Document, finalBuffer: Uint8Array, options?: SerializeOptions): number;\n\n/**\n * Sets the size of the internal serialization buffer.\n *\n * @param size - The desired size for the internal serialization buffer in bytes\n * @public\n */\nexport declare function setInternalBufferSize(size: number): void;\n\n/**\n * Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer\n * function is specified or optionally including only the specified properties if a replacer array\n * is specified.\n *\n * @param value - The value to convert to extended JSON\n * @param replacer - A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string\n * @param space - A String or Number object that's used to insert white space into the output JSON string for readability purposes.\n * @param options - Optional settings\n *\n * @example\n * ```js\n * const { EJSON } = require('bson');\n * const Int32 = require('mongodb').Int32;\n * const doc = { int32: new Int32(10) };\n *\n * // prints '{\"int32\":{\"$numberInt\":\"10\"}}'\n * console.log(EJSON.stringify(doc, { relaxed: false }));\n *\n * // prints '{\"int32\":10}'\n * console.log(EJSON.stringify(doc));\n * ```\n */\ndeclare function stringify(value: any, replacer?: (number | string)[] | ((this: any, key: string, value: any) => any) | EJSONOptions, space?: string | number, options?: EJSONOptions): string;\n\n/**\n * @public\n * @category BSONType\n */\nexport declare class Timestamp extends LongWithoutOverridesClass {\n    get _bsontype(): 'Timestamp';\n    static readonly MAX_VALUE: Long;\n    /**\n     * @param int - A 64-bit bigint representing the Timestamp.\n     */\n    constructor(int: bigint);\n    /**\n     * @param long - A 64-bit Long representing the Timestamp.\n     */\n    constructor(long: Long);\n    /**\n     * @param value - A pair of two values indicating timestamp and increment.\n     */\n    constructor(value: {\n        t: number;\n        i: number;\n    });\n    toJSON(): {\n        $timestamp: string;\n    };\n    /** Returns a Timestamp represented by the given (32-bit) integer value. */\n    static fromInt(value: number): Timestamp;\n    /** Returns a Timestamp representing the given number value, provided that it is a finite number. Otherwise, zero is returned. */\n    static fromNumber(value: number): Timestamp;\n    /**\n     * Returns a Timestamp for the given high and low bits. Each is assumed to use 32 bits.\n     *\n     * @param lowBits - the low 32-bits.\n     * @param highBits - the high 32-bits.\n     */\n    static fromBits(lowBits: number, highBits: number): Timestamp;\n    /**\n     * Returns a Timestamp from the given string, optionally using the given radix.\n     *\n     * @param str - the textual representation of the Timestamp.\n     * @param optRadix - the radix in which the text is written.\n     */\n    static fromString(str: string, optRadix: number): Timestamp;\n    /* Excluded from this release type: toExtendedJSON */\n    /* Excluded from this release type: fromExtendedJSON */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare interface TimestampExtended {\n    $timestamp: {\n        t: number;\n        i: number;\n    };\n}\n\n/** @public */\nexport declare type TimestampOverrides = '_bsontype' | 'toExtendedJSON' | 'fromExtendedJSON' | 'inspect';\n\n/**\n * A class representation of the BSON UUID type.\n * @public\n */\nexport declare class UUID extends Binary {\n    /**\n     * Create a UUID type\n     *\n     * When the argument to the constructor is omitted a random v4 UUID will be generated.\n     *\n     * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.\n     */\n    constructor(input?: string | Uint8Array | UUID);\n    /**\n     * The UUID bytes\n     * @readonly\n     */\n    get id(): Uint8Array;\n    set id(value: Uint8Array);\n    /**\n     * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)\n     * @param includeDashes - should the string exclude dash-separators.\n     */\n    toHexString(includeDashes?: boolean): string;\n    /**\n     * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.\n     */\n    toString(encoding?: 'hex' | 'base64'): string;\n    /**\n     * Converts the id into its JSON string representation.\n     * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n     */\n    toJSON(): string;\n    /**\n     * Compares the equality of this UUID with `otherID`.\n     *\n     * @param otherId - UUID instance to compare against.\n     */\n    equals(otherId: string | Uint8Array | UUID): boolean;\n    /**\n     * Creates a Binary instance from the current UUID.\n     */\n    toBinary(): Binary;\n    /**\n     * Generates a populated buffer containing a v4 uuid\n     */\n    static generate(): Uint8Array;\n    /**\n     * Checks if a value is a valid bson UUID\n     * @param input - UUID, string or Buffer to validate.\n     */\n    static isValid(input: string | Uint8Array | UUID | Binary): boolean;\n    /**\n     * Creates an UUID from a hex string representation of an UUID.\n     * @param hexString - 32 or 36 character hex string (dashes excluded/included).\n     */\n    static createFromHexString(hexString: string): UUID;\n    /** Creates an UUID from a base64 string representation of an UUID. */\n    static createFromBase64(base64: string): UUID;\n    /* Excluded from this release type: bytesFromString */\n    /* Excluded from this release type: isValidUUIDString */\n    /**\n     * Converts to a string representation of this Id.\n     *\n     * @returns return the 36 character hex string representation.\n     *\n     */\n    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\nexport declare type UUIDExtended = {\n    $uuid: string;\n};\n\nexport { }\n",
  '/mql.ts':
    '// TODO: everything in here is just a very minimal stub until we can generate\n// this file from the work in MONGOSH-2030\n\nexport interface Document {\n  [key: string]: any;\n}\n\nexport interface Array<T> {\n  [n: number]: T;\n}\n\nexport interface Cursor<T> {\n  toArray(): Array<T>;\n  first: T;\n}\n\nexport type Filter<T> = T;\nexport type Project<T> = {\n  $project: {\n    [t in keyof T]: 1 | 0;\n  };\n};\n\nexport type Lookup<T, R> = {\n  $lookup: {\n    from: string;\n    localField: keyof T;\n    foreignField: keyof R;\n    as: string;\n  };\n};\n\nexport type Match<T> = {\n  $match: Filter<T>;\n};\n\nexport type Pipeline<T> = Array<Match<T> | Project<T> | Lookup<T, any>>;\n',
  '/shell-api.ts':
    "/// <reference types=\"node\" />\n\nimport type { Agent } from 'https';\nimport type { ClientRequest } from 'http';\nimport type { ConnectionOptions } from 'tls';\nimport type { Duplex } from 'stream';\nimport { EventEmitter } from 'events';\nimport type { IncomingMessage } from 'http';\nimport { Readable } from 'stream';\nimport type { RequestOptions } from 'https';\nimport type { ServerResponse } from 'http';\nimport type { SrvRecord } from 'dns';\nimport type { TcpNetConnectOpts } from 'net';\nimport type { TLSSocketOptions } from 'tls';\n\n/** @public */\ndeclare type Abortable = {\n  /**\n   * @experimental\n   * When provided, the corresponding `AbortController` can be used to abort an asynchronous action.\n   *\n   * The `signal.reason` value is used as the error thrown.\n   *\n   * @remarks\n   * **NOTE:** If an abort signal aborts an operation while the driver is writing to the underlying\n   * socket or reading the response from the server, the socket will be closed.\n   * If signals are aborted at a high rate during socket read/writes this can lead to a high rate of connection reestablishment.\n   *\n   * We plan to mitigate this in a future release, please follow NODE-6062 (`timeoutMS` expiration suffers the same limitation).\n   *\n   * AbortSignals are likely a best fit for human interactive interruption (ex. ctrl-C) where the frequency\n   * of cancellation is reasonably low. If a signal is programmatically aborted for 100s of operations you can empty\n   * the driver's connection pool.\n   *\n   * @example\n   * ```js\n   * const controller = new AbortController();\n   * const { signal } = controller;\n   * process.on('SIGINT', () => controller.abort(new Error('^C pressed')));\n   *\n   * try {\n   *   const res = await fetch('...', { signal });\n   *   await collection.findOne(await res.json(), { signal });\n   * catch (error) {\n   *   if (error === signal.reason) {\n   *     // signal abort error handling\n   *   }\n   * }\n   * ```\n   */\n  signal?: AbortSignal | undefined;\n};\n\n/** @public */\ndeclare abstract class AbstractCursor<TSchema = any, CursorEvents extends AbstractCursorEvents = AbstractCursorEvents> extends TypedEventEmitter<CursorEvents> implements AsyncDisposable_2 {\n  /* Excluded from this release type: cursorId */\n  /* Excluded from this release type: cursorSession */\n  /* Excluded from this release type: selectedServer */\n  /* Excluded from this release type: cursorNamespace */\n  /* Excluded from this release type: documents */\n  /* Excluded from this release type: cursorClient */\n  /* Excluded from this release type: transform */\n  /* Excluded from this release type: initialized */\n  /* Excluded from this release type: isClosed */\n  /* Excluded from this release type: isKilled */\n  /* Excluded from this release type: cursorOptions */\n  /* Excluded from this release type: timeoutContext */\n  /** @event */\n  static readonly CLOSE: \"close\";\n  /* Excluded from this release type: deserializationOptions */\n  protected signal: AbortSignal | undefined;\n  private abortListener;\n  /* Excluded from this release type: __constructor */\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id(): Long | undefined;\n  /* Excluded from this release type: isDead */\n  /* Excluded from this release type: client */\n  /* Excluded from this release type: server */\n  get namespace(): MongoDBNamespace;\n  get readPreference(): ReadPreference;\n  get readConcern(): ReadConcern | undefined;\n  /* Excluded from this release type: session */\n  /* Excluded from this release type: session */\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed(): boolean;\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed(): boolean;\n  get loadBalanced(): boolean;\n  /* Excluded from this release type: [Symbol.asyncDispose] */\n  /* Excluded from this release type: asyncDispose */\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  private trackCursor;\n  /** Returns current buffered documents length */\n  bufferedCount(): number;\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): NonNullable<TSchema>[];\n  [Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void>;\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema>;\n  hasNext(): Promise<boolean>;\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  next(): Promise<TSchema | null>;\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  tryNext(): Promise<TSchema | null>;\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  forEach(iterator: (doc: TSchema) => boolean | void): Promise<void>;\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  close(options?: {\n    timeoutMS?: number;\n  }): Promise<void>;\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  toArray(): Promise<TSchema[]>;\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this;\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T>;\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this;\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this;\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this;\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this;\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void;\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n  /* Excluded from this release type: _initialize */\n  /* Excluded from this release type: getMore */\n  /* Excluded from this release type: cursorInit */\n  /* Excluded from this release type: fetchBatch */\n  /* Excluded from this release type: cleanup */\n  /* Excluded from this release type: hasEmittedClose */\n  /* Excluded from this release type: emitClose */\n  /* Excluded from this release type: transformDocument */\n  /* Excluded from this release type: throwIfInitialized */\n}\ndeclare abstract class AbstractCursor_2<CursorType extends ServiceProviderAggregationCursor | ServiceProviderFindCursor | ServiceProviderRunCommandCursor> extends ShellApiWithMongoClass {\n  _mongo: Mongo;\n  _cursor: CursorType;\n  _transform: ((doc: any) => any) | null;\n  _currentIterationResult: CursorIterationResult | null;\n  constructor(mongo: Mongo, cursor: CursorType);\n  [asPrintable](): Promise<CursorIterationResult>;\n  _it(): Promise<CursorIterationResult>;\n  batchSize(size: number): this;\n  close(): Promise<void>;\n  forEach(f: (doc: Document_2) => void | boolean | Promise<void> | Promise<boolean>): Promise<void>;\n  hasNext(): Promise<boolean>;\n  tryNext(): Promise<Document_2 | null>;\n  _tryNext(): Promise<Document_2 | null>;\n  _canDelegateIterationToUnderlyingCursor(): boolean;\n  [Symbol.asyncIterator](): AsyncGenerator<Document_2, void, void>;\n  isClosed(): boolean;\n  isExhausted(): boolean;\n  itcount(): Promise<number>;\n  toArray(): Promise<Document_2[]>;\n  pretty(): this;\n  map(f: (doc: Document_2) => Document_2): this;\n  maxTimeMS(value: number): this;\n  next(): Promise<Document_2 | null>;\n  objsLeftInBatch(): number;\n}\n\n/** @public */\ndeclare type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\ndeclare interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** Specifies the time an operation will run until it throws a timeout error. See {@link AbstractCursorOptions.timeoutMode} for more details on how this option applies to cursors. */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n  /* Excluded from this release type: timeoutContext */\n}\n\n/** @public */\ndeclare type AcceptedFields<TSchema, FieldType, AssignableType> = { readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType };\n\n/** @public */\ndeclare type AddToSetOperators<Type> = {\n  $each?: Array<Flatten<Type>>;\n};\n\n/**\n * The **Admin** class is an internal class that allows convenient access to\n * the admin functionality and commands for MongoDB.\n *\n * **ADMIN Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const admin = client.db().admin();\n * const dbInfo = await admin.listDatabases();\n * for (const db of dbInfo.databases) {\n *   console.log(db.name);\n * }\n * ```\n */\ndeclare class Admin {\n  /* Excluded from this release type: s */\n  /* Excluded from this release type: __constructor */\n  /**\n   * Execute a command\n   *\n   * The driver will ensure the following fields are attached to the command sent to the server:\n   * - `lsid` - sourced from an implicit session or options.session\n   * - `$readPreference` - defaults to primary or can be configured by options.readPreference\n   * - `$db` - sourced from the name of this database\n   *\n   * If the client has a serverApi setting:\n   * - `apiVersion`\n   * - `apiStrict`\n   * - `apiDeprecationErrors`\n   *\n   * When in a transaction:\n   * - `readConcern` - sourced from readConcern set on the TransactionOptions\n   * - `writeConcern` - sourced from writeConcern set on the TransactionOptions\n   *\n   * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.\n   *\n   * @param command - The command to execute\n   * @param options - Optional settings for the command\n   */\n  command(command: Document_2, options?: RunCommandOptions): Promise<Document_2>;\n  /**\n   * Retrieve the server build information\n   *\n   * @param options - Optional settings for the command\n   */\n  buildInfo(options?: CommandOperationOptions): Promise<Document_2>;\n  /**\n   * Retrieve the server build information\n   *\n   * @param options - Optional settings for the command\n   */\n  serverInfo(options?: CommandOperationOptions): Promise<Document_2>;\n  /**\n   * Retrieve this db's server status.\n   *\n   * @param options - Optional settings for the command\n   */\n  serverStatus(options?: CommandOperationOptions): Promise<Document_2>;\n  /**\n   * Ping the MongoDB server and retrieve results\n   *\n   * @param options - Optional settings for the command\n   */\n  ping(options?: CommandOperationOptions): Promise<Document_2>;\n  /**\n   * Remove a user from a database\n   *\n   * @param username - The username to remove\n   * @param options - Optional settings for the command\n   */\n  removeUser(username: string, options?: RemoveUserOptions): Promise<boolean>;\n  /**\n   * Validate an existing collection\n   *\n   * @param collectionName - The name of the collection to validate.\n   * @param options - Optional settings for the command\n   */\n  validateCollection(collectionName: string, options?: ValidateCollectionOptions): Promise<Document_2>;\n  /**\n   * List the available databases\n   *\n   * @param options - Optional settings for the command\n   */\n  listDatabases(options?: ListDatabasesOptions): Promise<ListDatabasesResult>;\n  /**\n   * Get ReplicaSet status\n   *\n   * @param options - Optional settings for the command\n   */\n  replSetGetStatus(options?: CommandOperationOptions): Promise<Document_2>;\n}\ndeclare interface Admin_2 {\n  platform: ReplPlatform;\n  initialDb: string;\n  bsonLibrary: typeof bson;\n  listDatabases(database: string, options?: ListDatabasesOptions): Promise<Document_2>;\n  getNewConnection(uri: string, options: MongoClientOptions): Promise<any>;\n  getURI(): string | undefined;\n  getConnectionInfo(): Promise<ConnectionInfo_2>;\n  authenticate(authDoc: ShellAuthOptions): Promise<{\n    ok: number;\n  }>;\n  createCollection(dbName: string, collName: string, options: CreateCollectionOptions, dbOptions?: DbOptions): Promise<{\n    ok: number;\n  }>;\n  getReadPreference(): ReadPreference;\n  getReadConcern(): ReadConcern | undefined;\n  getWriteConcern(): WriteConcern | undefined;\n  resetConnectionOptions(options: MongoClientOptions): Promise<void>;\n  startSession(options: ClientSessionOptions): ClientSession;\n  getRawClient(): any;\n  createClientEncryption?(options: ClientEncryptionOptions): ClientEncryption;\n  getFleOptions?: () => AutoEncryptionOptions | undefined;\n  createEncryptedCollection?(dbName: string, collName: string, options: CreateEncryptedCollectionOptions, libmongocrypt: ClientEncryption): Promise<{\n    collection: Collection_2;\n    encryptedFields: Document_2;\n  }>;\n}\ndeclare type AgentWithInitialize = Agent & {\n  initialize?(): Promise<void>;\n  logger?: ProxyLogEmitter;\n  readonly proxyOptions?: Readonly<DevtoolsProxyOptions>;\n  createSocket(req: ClientRequest, options: TcpNetConnectOpts | ConnectionOptions, cb: (err: Error | null, s?: Duplex) => void): void;\n} & Partial<EventEmitter>;\n\n/** @public */\ndeclare interface AggregateOptions extends Omit<CommandOperationOptions, 'explain'> {\n  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>). */\n  allowDiskUse?: boolean;\n  /** The number of documents to return per batch. See [aggregation documentation](https://www.mongodb.com/docs/manual/reference/command/aggregate). */\n  batchSize?: number;\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */\n  cursor?: Document_2;\n  /**\n   * Specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n   */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */\n  maxAwaitTimeMS?: number;\n  /** Specify collation. */\n  collation?: CollationOptions;\n  /** Add an index selection hint to an aggregation command */\n  hint?: Hint;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  out?: string;\n  /**\n   * Specifies the verbosity mode for the explain output.\n   * @deprecated This API is deprecated in favor of `collection.aggregate().explain()`\n   * or `db.aggregate().explain()`.\n   */\n  explain?: ExplainOptions['explain'];\n  /* Excluded from this release type: timeoutMode */\n}\ndeclare abstract class AggregateOrFindCursor<CursorType extends ServiceProviderAggregationCursor | ServiceProviderFindCursor> extends AbstractCursor_2<CursorType> {\n  projection(spec: Document_2): this;\n  skip(value: number): this;\n  sort(spec: Document_2): this;\n  explain(verbosity?: ExplainVerbosityLike): Promise<any>;\n}\nexport declare class AggregationCursor extends AggregateOrFindCursor<ServiceProviderAggregationCursor> {\n  constructor(mongo: Mongo, cursor: ServiceProviderAggregationCursor);\n}\n\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\ndeclare class AggregationCursor_2<TSchema = any> extends ExplainableCursor_2<TSchema> {\n  readonly pipeline: Document_2[];\n  /* Excluded from this release type: aggregateOptions */\n  /* Excluded from this release type: __constructor */\n  clone(): AggregationCursor_2<TSchema>;\n  map<T>(transform: (doc: TSchema) => T): AggregationCursor_2<T>;\n  /* Excluded from this release type: _initialize */\n  /** Execute the explain for the cursor */\n  explain(): Promise<Document_2>;\n  explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document_2>;\n  explain(options: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions, options: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  /** Add a stage to the aggregation pipeline\n   * @example\n   * ```\n   * const documents = await users.aggregate().addStage({ $match: { name: /Mike/ } }).toArray();\n   * ```\n   * @example\n   * ```\n   * const documents = await users.aggregate()\n   *   .addStage<{ name: string }>({ $project: { name: true } })\n   *   .toArray(); // type of documents is { name: string }[]\n   * ```\n   */\n  addStage(stage: Document_2): this;\n  addStage<T = Document_2>(stage: Document_2): AggregationCursor_2<T>;\n  /** Add a group stage to the aggregation pipeline */\n  group<T = TSchema>($group: Document_2): AggregationCursor_2<T>;\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit: number): this;\n  /** Add a match stage to the aggregation pipeline */\n  match($match: Document_2): this;\n  /** Add an out stage to the aggregation pipeline */\n  out($out: {\n    db: string;\n    coll: string;\n  } | string): this;\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n  project<T extends Document_2 = Document_2>($project: Document_2): AggregationCursor_2<T>;\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup: Document_2): this;\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact: Document_2): this;\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip: number): this;\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort: Sort): this;\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind: Document_2 | string): this;\n  /** Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear: Document_2): this;\n}\n\n/**\n * It is possible to search using alternative types in mongodb e.g.\n * string types can be searched using a regex in mongo\n * array types can be searched using their element type\n * @public\n */\ndeclare type AlternativeType<T> = T extends ReadonlyArray<infer U> ? T | RegExpOrString<U> : RegExpOrString<T>;\ndeclare type AltNames = string[];\n\n/** @public */\ndeclare type AnyBulkWriteOperation<TSchema extends Document_2 = Document_2> = {\n  insertOne: InsertOneModel<TSchema>;\n} | {\n  replaceOne: ReplaceOneModel<TSchema>;\n} | {\n  updateOne: UpdateOneModel<TSchema>;\n} | {\n  updateMany: UpdateManyModel<TSchema>;\n} | {\n  deleteOne: DeleteOneModel<TSchema>;\n} | {\n  deleteMany: DeleteManyModel<TSchema>;\n};\n\n/**\n * Used to represent any of the client bulk write models that can be passed as an array\n * to MongoClient#bulkWrite.\n * @public\n */\ndeclare type AnyClientBulkWriteModel<TSchema extends Document_2> = ClientInsertOneModel<TSchema> | ClientReplaceOneModel<TSchema> | ClientUpdateOneModel<TSchema> | ClientUpdateManyModel<TSchema> | ClientDeleteOneModel<TSchema> | ClientDeleteManyModel<TSchema>;\ndeclare interface ApiEvent {\n  method: string;\n  class: string;\n  deprecated: boolean;\n  isAsync: boolean;\n  callDepth: number;\n}\ndeclare interface ApiEventArguments {\n  pipeline?: any[];\n  query?: object;\n  options?: object;\n  filter?: object;\n}\ndeclare interface ApiEventWithArguments {\n  method: string;\n  class?: string;\n  db?: string;\n  coll?: string;\n  uri?: string;\n  arguments?: ApiEventArguments;\n}\ndeclare interface ApiWarning {\n  method: string;\n  class: string;\n  message: string;\n}\n\n/** @public */\ndeclare type ArrayOperator<Type> = {\n  $each?: Array<Flatten<Type>>;\n  $slice?: number;\n  $position?: number;\n  $sort?: Sort;\n};\ndeclare const asPrintable: unique symbol;\n\n/**\n * @public\n */\ndeclare interface AsyncDisposable_2 {\n  /* Excluded from this release type: [Symbol.asyncDispose] */\n  /* Excluded from this release type: asyncDispose */\n}\n\n/** @public */\ndeclare interface Auth {\n  /** The username for auth */\n  username?: string;\n  /** The password for auth */\n  password?: string;\n}\ndeclare type AuthDoc = {\n  user: string;\n  pwd: string;\n  authDb?: string;\n  mechanism?: string;\n};\n\n/** @public */\ndeclare type AuthFlowType = 'auth-code' | 'device-auth';\n\n/** @public */\ndeclare const AuthMechanism: Readonly<{\n  readonly MONGODB_AWS: \"MONGODB-AWS\";\n  readonly MONGODB_CR: \"MONGODB-CR\";\n  readonly MONGODB_DEFAULT: \"DEFAULT\";\n  readonly MONGODB_GSSAPI: \"GSSAPI\";\n  readonly MONGODB_PLAIN: \"PLAIN\";\n  readonly MONGODB_SCRAM_SHA1: \"SCRAM-SHA-1\";\n  readonly MONGODB_SCRAM_SHA256: \"SCRAM-SHA-256\";\n  readonly MONGODB_X509: \"MONGODB-X509\";\n  readonly MONGODB_OIDC: \"MONGODB-OIDC\";\n}>;\n\n/** @public */\ndeclare type AuthMechanism = (typeof AuthMechanism)[keyof typeof AuthMechanism];\n\n/** @public */\ndeclare interface AuthMechanismProperties extends Document_2 {\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  AWS_SESSION_TOKEN?: string;\n  /** A user provided OIDC machine callback function. */\n  OIDC_CALLBACK?: OIDCCallbackFunction;\n  /** A user provided OIDC human interacted callback function. */\n  OIDC_HUMAN_CALLBACK?: OIDCCallbackFunction;\n  /** The OIDC environment. Note that 'test' is for internal use only. */\n  ENVIRONMENT?: 'test' | 'azure' | 'gcp' | 'k8s';\n  /** Allowed hosts that OIDC auth can connect to. */\n  ALLOWED_HOSTS?: string[];\n  /** The resource token for OIDC auth in Azure and GCP. */\n  TOKEN_RESOURCE?: string;\n}\nexport declare interface AutocompleteParameters {\n  topology: () => Topologies | undefined;\n  apiVersionInfo: () => Required<ServerApi> | undefined;\n  connectionInfo: () => ConnectionExtraInfo | undefined;\n  getCollectionCompletionsForCurrentDb: (collName: string) => Promise<string[]>;\n  getDatabaseCompletions: (dbName: string) => Promise<string[]>;\n}\n\n/** @public */\ndeclare const AutoEncryptionLoggerLevel: Readonly<{\n  readonly FatalError: 0;\n  readonly Error: 1;\n  readonly Warning: 2;\n  readonly Info: 3;\n  readonly Trace: 4;\n}>;\n\n/**\n * @public\n * The level of severity of the log message\n *\n * | Value | Level |\n * |-------|-------|\n * | 0 | Fatal Error |\n * | 1 | Error |\n * | 2 | Warning |\n * | 3 | Info |\n * | 4 | Trace |\n */\ndeclare type AutoEncryptionLoggerLevel = (typeof AutoEncryptionLoggerLevel)[keyof typeof AutoEncryptionLoggerLevel];\n\n/** @public */\ndeclare interface AutoEncryptionOptions {\n  /* Excluded from this release type: metadataClient */\n  /** A `MongoClient` used to fetch keys from a key vault */\n  keyVaultClient?: MongoClient;\n  /** The namespace where keys are stored in the key vault */\n  keyVaultNamespace?: string;\n  /** Configuration options that are used by specific KMS providers during key generation, encryption, and decryption. */\n  kmsProviders?: KMSProviders;\n  /**\n   * A map of namespaces to a local JSON schema for encryption\n   *\n   * **NOTE**: Supplying options.schemaMap provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending decrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   */\n  schemaMap?: Document_2;\n  /** Supply a schema for the encrypted fields in the document  */\n  encryptedFieldsMap?: Document_2;\n  /** Allows the user to bypass auto encryption, maintaining implicit decryption */\n  bypassAutoEncryption?: boolean;\n  /** Allows users to bypass query analysis */\n  bypassQueryAnalysis?: boolean;\n  options?: {\n    /** An optional hook to catch logging messages from the underlying encryption engine */\n    logger?: (level: AutoEncryptionLoggerLevel, message: string) => void;\n  };\n  extraOptions?: {\n    /**\n     * A local process the driver communicates with to determine how to encrypt values in a command.\n     * Defaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise\n     */\n    mongocryptdURI?: string;\n    /** If true, autoEncryption will not attempt to spawn a mongocryptd before connecting  */\n    mongocryptdBypassSpawn?: boolean;\n    /** The path to the mongocryptd executable on the system */\n    mongocryptdSpawnPath?: string;\n    /** Command line arguments to use when auto-spawning a mongocryptd */\n    mongocryptdSpawnArgs?: string[];\n    /**\n     * Full path to a MongoDB Crypt shared library to be used (instead of mongocryptd).\n     *\n     * This needs to be the path to the file itself, not a directory.\n     * It can be an absolute or relative path. If the path is relative and\n     * its first component is `$ORIGIN`, it will be replaced by the directory\n     * containing the mongodb-client-encryption native addon file. Otherwise,\n     * the path will be interpreted relative to the current working directory.\n     *\n     * Currently, loading different MongoDB Crypt shared library files from different\n     * MongoClients in the same process is not supported.\n     *\n     * If this option is provided and no MongoDB Crypt shared library could be loaded\n     * from the specified location, creating the MongoClient will fail.\n     *\n     * If this option is not provided and `cryptSharedLibRequired` is not specified,\n     * the AutoEncrypter will attempt to spawn and/or use mongocryptd according\n     * to the mongocryptd-specific `extraOptions` options.\n     *\n     * Specifying a path prevents mongocryptd from being used as a fallback.\n     *\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\n     */\n    cryptSharedLibPath?: string;\n    /**\n     * If specified, never use mongocryptd and instead fail when the MongoDB Crypt\n     * shared library could not be loaded.\n     *\n     * This is always true when `cryptSharedLibPath` is specified.\n     *\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\n     */\n    cryptSharedLibRequired?: boolean;\n    /* Excluded from this release type: cryptSharedLibSearchPaths */\n  };\n  proxyOptions?: ProxyOptions;\n  /** The TLS options to use connecting to the KMS provider */\n  tlsOptions?: CSFLEKMSTlsOptions;\n}\n\n/**\n * @public\n * Configuration options for making an AWS encryption key\n */\ndeclare interface AWSEncryptionKeyOptions {\n  /**\n   * The AWS region of the KMS\n   */\n  region: string;\n  /**\n   * The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n   */\n  key: string;\n  /**\n   * An alternate host to send KMS requests to. May include port number.\n   */\n  endpoint?: string | undefined;\n}\n\n/** @public */\ndeclare interface AWSKMSProviderConfiguration {\n  /**\n   * The access key used for the AWS KMS provider\n   */\n  accessKeyId: string;\n  /**\n   * The secret access key used for the AWS KMS provider\n   */\n  secretAccessKey: string;\n  /**\n   * An optional AWS session token that will be used as the\n   * X-Amz-Security-Token header for AWS requests.\n   */\n  sessionToken?: string;\n}\n\n/**\n * @public\n * Configuration options for making an Azure encryption key\n */\ndeclare interface AzureEncryptionKeyOptions {\n  /**\n   * Key name\n   */\n  keyName: string;\n  /**\n   * Key vault URL, typically `<name>.vault.azure.net`\n   */\n  keyVaultEndpoint: string;\n  /**\n   * Key version\n   */\n  keyVersion?: string | undefined;\n}\n\n/** @public */\ndeclare type AzureKMSProviderConfiguration = {\n  /**\n   * The tenant ID identifies the organization for the account\n   */\n  tenantId: string;\n  /**\n   * The client ID to authenticate a registered application\n   */\n  clientId: string;\n  /**\n   * The client secret to authenticate a registered application\n   */\n  clientSecret: string;\n  /**\n   * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\n   * This is optional, and only needed if customer is using a non-commercial Azure instance\n   * (e.g. a government or China account, which use different URLs).\n   * Defaults to \"login.microsoftonline.com\"\n   */\n  identityPlatformEndpoint?: string | undefined;\n} | {\n  /**\n   * If present, an access token to authenticate with Azure.\n   */\n  accessToken: string;\n};\ndeclare interface BaseSocks5RequestMetadata {\n  srcAddr: string;\n  srcPort: number;\n  dstAddr: string;\n  dstPort: number;\n}\n\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n *\n * @public\n */\ndeclare class Batch<T = Document_2> {\n  originalZeroIndex: number;\n  currentIndex: number;\n  originalIndexes: number[];\n  batchType: BatchType;\n  operations: T[];\n  size: number;\n  sizeBytes: number;\n  constructor(batchType: BatchType, originalZeroIndex: number);\n}\n\n/** @public */\ndeclare const BatchType: Readonly<{\n  readonly INSERT: 1;\n  readonly UPDATE: 2;\n  readonly DELETE: 3;\n}>;\n\n/** @public */\ndeclare type BatchType = (typeof BatchType)[keyof typeof BatchType];\n\n/**\n * A class representation of the BSON Binary type.\n * @public\n * @category BSONType\n */\ndeclare class Binary extends BSONValue {\n  get _bsontype(): 'Binary';\n  /* Excluded from this release type: BSON_BINARY_SUBTYPE_DEFAULT */\n  /** Initial buffer default size */\n  static readonly BUFFER_SIZE = 256;\n  /** Default BSON type */\n  static readonly SUBTYPE_DEFAULT = 0;\n  /** Function BSON type */\n  static readonly SUBTYPE_FUNCTION = 1;\n  /** Byte Array BSON type */\n  static readonly SUBTYPE_BYTE_ARRAY = 2;\n  /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */\n  static readonly SUBTYPE_UUID_OLD = 3;\n  /** UUID BSON type */\n  static readonly SUBTYPE_UUID = 4;\n  /** MD5 BSON type */\n  static readonly SUBTYPE_MD5 = 5;\n  /** Encrypted BSON type */\n  static readonly SUBTYPE_ENCRYPTED = 6;\n  /** Column BSON type */\n  static readonly SUBTYPE_COLUMN = 7;\n  /** Sensitive BSON type */\n  static readonly SUBTYPE_SENSITIVE = 8;\n  /** Vector BSON type */\n  static readonly SUBTYPE_VECTOR = 9;\n  /** User BSON type */\n  static readonly SUBTYPE_USER_DEFINED = 128;\n  /** datatype of a Binary Vector (subtype: 9) */\n  static readonly VECTOR_TYPE: Readonly<{\n    readonly Int8: 3;\n    readonly Float32: 39;\n    readonly PackedBit: 16;\n  }>;\n  /**\n   * The bytes of the Binary value.\n   *\n   * The format of a Binary value in BSON is defined as:\n   * ```txt\n   * binary\t::= int32 subtype (byte*)\n   * ```\n   *\n   * This `buffer` is the \"(byte*)\" segment.\n   *\n   * Unless the value is subtype 2, then deserialize will read the first 4 bytes as an int32 and set this to the remaining bytes.\n   *\n   * ```txt\n   * binary\t::= int32 unsigned_byte(2) int32 (byte*)\n   * ```\n   *\n   * @see https://bsonspec.org/spec.html\n   */\n  buffer: Uint8Array;\n  /**\n   * The binary subtype.\n   *\n   * Current defined values are:\n   *\n   * - `unsigned_byte(0)` Generic binary subtype\n   * - `unsigned_byte(1)` Function\n   * - `unsigned_byte(2)` Binary (Deprecated)\n   * - `unsigned_byte(3)` UUID (Deprecated)\n   * - `unsigned_byte(4)` UUID\n   * - `unsigned_byte(5)` MD5\n   * - `unsigned_byte(6)` Encrypted BSON value\n   * - `unsigned_byte(7)` Compressed BSON column\n   * - `unsigned_byte(8)` Sensitive\n   * - `unsigned_byte(9)` Vector\n   * - `unsigned_byte(128)` - `unsigned_byte(255)` User defined\n   */\n  sub_type: number;\n  /**\n   * The Binary's `buffer` can be larger than the Binary's content.\n   * This property is used to determine where the content ends in the buffer.\n   */\n  position: number;\n  /**\n   * Create a new Binary instance.\n   * @param buffer - a buffer object containing the binary data.\n   * @param subType - the option binary type.\n   */\n  constructor(buffer?: BinarySequence, subType?: number);\n  /**\n   * Updates this binary with byte_value.\n   *\n   * @param byteValue - a single byte we wish to write.\n   */\n  put(byteValue: string | number | Uint8Array | number[]): void;\n  /**\n   * Writes a buffer to the binary.\n   *\n   * @param sequence - a string or buffer to be written to the Binary BSON object.\n   * @param offset - specify the binary of where to write the content.\n   */\n  write(sequence: BinarySequence, offset: number): void;\n  /**\n   * Returns a view of **length** bytes starting at **position**.\n   *\n   * @param position - read from the given position in the Binary.\n   * @param length - the number of bytes to read.\n   */\n  read(position: number, length: number): Uint8Array;\n  /** returns a view of the binary value as a Uint8Array */\n  value(): Uint8Array;\n  /** the length of the binary sequence */\n  length(): number;\n  toJSON(): string;\n  toString(encoding?: 'hex' | 'base64' | 'utf8' | 'utf-8'): string;\n  /* Excluded from this release type: toExtendedJSON */\n  toUUID(): UUID;\n  /** Creates an Binary instance from a hex digit string */\n  static createFromHexString(hex: string, subType?: number): Binary;\n  /** Creates an Binary instance from a base64 string */\n  static createFromBase64(base64: string, subType?: number): Binary;\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n  /**\n   * If this Binary represents a Int8 Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.Int8`),\n   * returns a copy of the bytes in a new Int8Array.\n   *\n   * If the Binary is not a Vector, or the datatype is not Int8, an error is thrown.\n   */\n  toInt8Array(): Int8Array;\n  /**\n   * If this Binary represents a Float32 Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.Float32`),\n   * returns a copy of the bytes in a new Float32Array.\n   *\n   * If the Binary is not a Vector, or the datatype is not Float32, an error is thrown.\n   */\n  toFloat32Array(): Float32Array;\n  /**\n   * If this Binary represents packed bit Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.PackedBit`),\n   * returns a copy of the bytes that are packed bits.\n   *\n   * Use `toBits` to get the unpacked bits.\n   *\n   * If the Binary is not a Vector, or the datatype is not PackedBit, an error is thrown.\n   */\n  toPackedBits(): Uint8Array;\n  /**\n   * If this Binary represents a Packed bit Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.PackedBit`),\n   * returns a copy of the bit unpacked into a new Int8Array.\n   *\n   * Use `toPackedBits` to get the bits still in packed form.\n   *\n   * If the Binary is not a Vector, or the datatype is not PackedBit, an error is thrown.\n   */\n  toBits(): Int8Array;\n  /**\n   * Constructs a Binary representing an Int8 Vector.\n   * @param array - The array to store as a view on the Binary class\n   */\n  static fromInt8Array(array: Int8Array): Binary;\n  /** Constructs a Binary representing an Float32 Vector. */\n  static fromFloat32Array(array: Float32Array): Binary;\n  /**\n   * Constructs a Binary representing a packed bit Vector.\n   *\n   * Use `fromBits` to pack an array of 1s and 0s.\n   */\n  static fromPackedBits(array: Uint8Array, padding?: number): Binary;\n  /**\n   * Constructs a Binary representing an Packed Bit Vector.\n   * @param array - The array of 1s and 0s to pack into the Binary instance\n   */\n  static fromBits(bits: ArrayLike<number>): Binary;\n}\n\n/** @public */\ndeclare type BinarySequence = Uint8Array | number[];\n\n/** @public */\ndeclare type BitwiseFilter = number /** numeric bit mask */ | Binary /** BinData bit mask */ | ReadonlyArray<number>;\ndeclare const bson: {\n  ObjectId: typeof ObjectId;\n  DBRef: typeof DBRef;\n  MaxKey: typeof MaxKey;\n  MinKey: typeof MinKey;\n  Timestamp: typeof Timestamp;\n  BSONSymbol: typeof BSONSymbol;\n  Code: typeof Code;\n  Decimal128: typeof Decimal128;\n  Int32: typeof Int32;\n  Long: typeof Long;\n  Binary: typeof Binary;\n  calculateObjectSize: typeof calculateObjectSize;\n  Double: typeof Double;\n  EJSON: {\n    parse: (text: string, options?: EJSONOptions) => any;\n    stringify: (value: any, replacer?: (number | string)[] | ((this: any, key: string, value: any) => any) | EJSONOptions, space?: string | number, options?: EJSONOptions) => string;\n    serialize: (value: any, options?: EJSONOptions) => Document_2;\n    deserialize: (ejson: Document_2, options?: EJSONOptions) => any;\n  };\n  BSONRegExp: typeof BSONRegExp;\n};\n\n/**\n * A class representation of the BSON RegExp type.\n * @public\n * @category BSONType\n */\ndeclare class BSONRegExp extends BSONValue {\n  get _bsontype(): 'BSONRegExp';\n  pattern: string;\n  options: string;\n  /**\n   * @param pattern - The regular expression pattern to match\n   * @param options - The regular expression options\n   */\n  constructor(pattern: string, options?: string);\n  static parseOptions(options?: string): string;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/**\n * BSON Serialization options.\n * @public\n */\ndeclare interface BSONSerializeOptions extends Omit<SerializeOptions, 'index'>, Omit<DeserializeOptions, 'evalFunctions' | 'cacheFunctions' | 'cacheFunctionsCrc32' | 'allowObjectSmallerThanBufferSize' | 'index' | 'validation'> {\n  /**\n   * Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\n   * which is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\n   * See this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\n   * for more detail about what \"unsafe\" refers to in this context.\n   * If you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\n   * your own buffer and clone the contents:\n   *\n   * @example\n   * ```ts\n   * const raw = await collection.findOne({}, { raw: true });\n   * const myBuffer = Buffer.alloc(raw.byteLength);\n   * myBuffer.set(raw, 0);\n   * // Only save and use `myBuffer` beyond this point\n   * ```\n   *\n   * @remarks\n   * Please note there is a known limitation where this option cannot be used at the MongoClient level (see [NODE-3946](https://jira.mongodb.org/browse/NODE-3946)).\n   * It does correctly work at `Db`, `Collection`, and per operation the same as other BSON options work.\n   */\n  raw?: boolean;\n  /** Enable utf8 validation when deserializing BSON documents.  Defaults to true. */\n  enableUtf8Validation?: boolean;\n}\n\n/**\n * A class representation of the BSON Symbol type.\n * @public\n * @category BSONType\n */\ndeclare class BSONSymbol extends BSONValue {\n  get _bsontype(): 'BSONSymbol';\n  value: string;\n  /**\n   * @param value - the string representing the symbol.\n   */\n  constructor(value: string);\n  /** Access the wrapped string value. */\n  valueOf(): string;\n  toString(): string;\n  toJSON(): string;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare const BSONType: Readonly<{\n  readonly double: 1;\n  readonly string: 2;\n  readonly object: 3;\n  readonly array: 4;\n  readonly binData: 5;\n  readonly undefined: 6;\n  readonly objectId: 7;\n  readonly bool: 8;\n  readonly date: 9;\n  readonly null: 10;\n  readonly regex: 11;\n  readonly dbPointer: 12;\n  readonly javascript: 13;\n  readonly symbol: 14;\n  readonly javascriptWithScope: 15;\n  readonly int: 16;\n  readonly timestamp: 17;\n  readonly long: 18;\n  readonly decimal: 19;\n  readonly minKey: -1;\n  readonly maxKey: 127;\n}>;\n\n/** @public */\ndeclare type BSONType = (typeof BSONType)[keyof typeof BSONType];\n\n/** @public */\ndeclare type BSONTypeAlias = keyof typeof BSONType;\n\n/** @public */\ndeclare abstract class BSONValue {\n  /** @public */\n  abstract get _bsontype(): string;\n  /* Excluded from this release type: [BSON_VERSION_SYMBOL] */\n  /**\n   * @public\n   * Prints a human-readable string of BSON value information\n   * If invoked manually without node.js.inspect function, this will default to a modified JSON.stringify\n   */\n  abstract inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n  /* Excluded from this release type: toExtendedJSON */\n}\ndeclare class Bulk extends ShellApiWithMongoClass {\n  _mongo: Mongo;\n  _collection: Collection;\n  _batchCounts: any;\n  _executed: boolean;\n  _serviceProviderBulkOp: OrderedBulkOperation | UnorderedBulkOperation;\n  _ordered: boolean;\n  constructor(collection: Collection, innerBulk: OrderedBulkOperation | UnorderedBulkOperation, ordered?: boolean);\n  [asPrintable](): any;\n  private _emitBulkApiCall;\n  execute(writeConcern?: WriteConcern): BulkWriteResult;\n  find(query: Document_2): BulkFindOp;\n  insert(document: Document_2): Bulk;\n  toJSON(): Record<'nInsertOps' | 'nUpdateOps' | 'nRemoveOps' | 'nBatches', number>;\n  toString(): string;\n  getOperations(): Pick<Batch, 'originalZeroIndex' | 'batchType' | 'operations'>[];\n}\ndeclare class BulkFindOp extends ShellApiWithMongoClass {\n  _serviceProviderBulkFindOp: FindOperators;\n  _parentBulk: Bulk;\n  constructor(innerFind: FindOperators, parentBulk: Bulk);\n  get _mongo(): Mongo;\n  [asPrintable](): string;\n  collation(spec: CollationOptions): BulkFindOp;\n  arrayFilters(filters: Document_2[]): BulkFindOp;\n  hint(hintDoc: Document_2): BulkFindOp;\n  delete(): Bulk;\n  deleteOne(): Bulk;\n  remove(): Bulk;\n  removeOne(): Bulk;\n  replaceOne(replacement: Document_2): Bulk;\n  updateOne(update: Document_2 | Document_2[]): Bulk;\n  update(update: Document_2 | Document_2[]): Bulk;\n  upsert(): BulkFindOp;\n}\n\n/** @public */\ndeclare abstract class BulkOperationBase {\n  private collection;\n  isOrdered: boolean;\n  /* Excluded from this release type: s */\n  operationId?: number;\n  /* Excluded from this release type: __constructor */\n  /**\n   * Add a single insert document to the bulk operation\n   *\n   * @example\n   * ```ts\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   *\n   * // Adds three inserts to the bulkOp.\n   * bulkOp\n   *   .insert({ a: 1 })\n   *   .insert({ b: 2 })\n   *   .insert({ c: 3 });\n   * await bulkOp.execute();\n   * ```\n   */\n  insert(document: Document_2): BulkOperationBase;\n  /**\n   * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\n   * Returns a builder object used to complete the definition of the operation.\n   *\n   * @example\n   * ```ts\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   *\n   * // Add an updateOne to the bulkOp\n   * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\n   *\n   * // Add an updateMany to the bulkOp\n   * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\n   *\n   * // Add an upsert\n   * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\n   *\n   * // Add a deletion\n   * bulkOp.find({ g: 7 }).deleteOne();\n   *\n   * // Add a multi deletion\n   * bulkOp.find({ h: 8 }).delete();\n   *\n   * // Add a replaceOne\n   * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});\n   *\n   * // Update using a pipeline (requires Mongodb 4.2 or higher)\n   * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\n   *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\n   * ]);\n   *\n   * // All of the ops will now be executed\n   * await bulkOp.execute();\n   * ```\n   */\n  find(selector: Document_2): FindOperators;\n  /** Specifies a raw operation to perform in the bulk write. */\n  raw(op: AnyBulkWriteOperation): this;\n  get length(): number;\n  get bsonOptions(): BSONSerializeOptions;\n  get writeConcern(): WriteConcern | undefined;\n  get batches(): Batch[];\n  execute(options?: BulkWriteOptions): Promise<BulkWriteResult_2>;\n  /* Excluded from this release type: handleWriteError */\n  abstract addToOperationsList(batchType: BatchType, document: Document_2 | UpdateStatement | DeleteStatement): this;\n  private shouldForceServerObjectId;\n}\n\n/** @public */\ndeclare interface BulkWriteOperationError {\n  index: number;\n  code: number;\n  errmsg: string;\n  errInfo: Document_2;\n  op: Document_2 | UpdateStatement | DeleteStatement;\n}\n\n/** @public */\ndeclare interface BulkWriteOptions extends CommandOperationOptions {\n  /**\n   * Allow driver to bypass schema validation.\n   * @defaultValue `false` - documents will be validated by default\n   **/\n  bypassDocumentValidation?: boolean;\n  /**\n   * If true, when an insert fails, don't execute the remaining writes.\n   * If false, continue with remaining inserts when one fails.\n   * @defaultValue `true` - inserts are ordered by default\n   */\n  ordered?: boolean;\n  /**\n   * Force server to assign _id values instead of driver.\n   * @defaultValue `false` - the driver generates `_id` fields by default\n   **/\n  forceServerObjectId?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  /* Excluded from this release type: timeoutContext */\n}\nexport declare class BulkWriteResult extends ShellApiValueClass {\n  acknowledged: boolean;\n  insertedCount: number;\n  insertedIds: {\n    [index: number]: ObjectId;\n  };\n  matchedCount: number;\n  modifiedCount: number;\n  deletedCount: number;\n  upsertedCount: number;\n  upsertedIds: {\n    [index: number]: ObjectId;\n  };\n  constructor(acknowledged: boolean, insertedCount: number, insertedIds: {\n    [index: number]: ObjectId;\n  }, matchedCount: number, modifiedCount: number, deletedCount: number, upsertedCount: number, upsertedIds: {\n    [index: number]: ObjectId;\n  });\n}\n\n/**\n * @public\n * The result of a bulk write.\n */\ndeclare class BulkWriteResult_2 {\n  private readonly result;\n  /** Number of documents inserted. */\n  readonly insertedCount: number;\n  /** Number of documents matched for update. */\n  readonly matchedCount: number;\n  /** Number of documents modified. */\n  readonly modifiedCount: number;\n  /** Number of documents deleted. */\n  readonly deletedCount: number;\n  /** Number of documents upserted. */\n  readonly upsertedCount: number;\n  /** Upserted document generated Id's, hash key is the index of the originating operation */\n  readonly upsertedIds: {\n    [key: number]: any;\n  };\n  /** Inserted document generated Id's, hash key is the index of the originating operation */\n  readonly insertedIds: {\n    [key: number]: any;\n  };\n  private static generateIdMap;\n  /* Excluded from this release type: __constructor */\n  /** Evaluates to true if the bulk operation correctly executes */\n  get ok(): number;\n  /* Excluded from this release type: getSuccessfullyInsertedIds */\n  /** Returns the upserted id at the given index */\n  getUpsertedIdAt(index: number): Document_2 | undefined;\n  /** Returns raw internal result */\n  getRawResponse(): Document_2;\n  /** Returns true if the bulk operation contains a write error */\n  hasWriteErrors(): boolean;\n  /** Returns the number of write errors off the bulk operation */\n  getWriteErrorCount(): number;\n  /** Returns a specific write error object */\n  getWriteErrorAt(index: number): WriteError | undefined;\n  /** Retrieve all write errors */\n  getWriteErrors(): WriteError[];\n  /** Retrieve the write concern error if one exists */\n  getWriteConcernError(): WriteConcernError | undefined;\n  toString(): string;\n  isOk(): boolean;\n}\n\n/**\n * Calculate the bson size for a passed in Javascript object.\n *\n * @param object - the Javascript object to calculate the BSON byte size for\n * @returns size of BSON object in bytes\n * @public\n */\ndeclare function calculateObjectSize(object: Document_2, options?: CalculateObjectSizeOptions): number;\n\n/** @public */\ndeclare type CalculateObjectSizeOptions = Pick<SerializeOptions, 'serializeFunctions' | 'ignoreUndefined'>;\n\n/** @public */\ndeclare class CancellationToken extends TypedEventEmitter<{\n  cancel(): void;\n}> {\n  constructor(...args: any[]);\n}\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @public\n */\ndeclare class ChangeStream<TSchema extends Document_2 = Document_2, TChange extends Document_2 = ChangeStreamDocument<TSchema>> extends TypedEventEmitter<ChangeStreamEvents<TSchema, TChange>> implements AsyncDisposable_2 {\n  /* Excluded from this release type: [Symbol.asyncDispose] */\n  /* Excluded from this release type: asyncDispose */\n  pipeline: Document_2[];\n  /**\n   * @remarks WriteConcern can still be present on the options because\n   * we inherit options from the client/db/collection.  The\n   * key must be present on the options in order to delete it.\n   * This allows typescript to delete the key but will\n   * not allow a writeConcern to be assigned as a property on options.\n   */\n  options: ChangeStreamOptions & {\n    writeConcern?: never;\n  };\n  parent: MongoClient | Db | Collection_2;\n  namespace: MongoDBNamespace;\n  type: symbol;\n  /* Excluded from this release type: cursor */\n  streamOptions?: CursorStreamOptions;\n  /* Excluded from this release type: cursorStream */\n  /* Excluded from this release type: isClosed */\n  /* Excluded from this release type: mode */\n  /** @event */\n  static readonly RESPONSE: \"response\";\n  /** @event */\n  static readonly MORE: \"more\";\n  /** @event */\n  static readonly INIT: \"init\";\n  /** @event */\n  static readonly CLOSE: \"close\";\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   * @event\n   */\n  static readonly CHANGE: \"change\";\n  /** @event */\n  static readonly END: \"end\";\n  /** @event */\n  static readonly ERROR: \"error\";\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   * @event\n   */\n  static readonly RESUME_TOKEN_CHANGED: \"resumeTokenChanged\";\n  private timeoutContext?;\n  /**\n   * Note that this property is here to uniquely identify a ChangeStream instance as the owner of\n   * the {@link CursorTimeoutContext} instance (see {@link ChangeStream._createChangeStreamCursor}) to ensure\n   * that {@link AbstractCursor.close} does not mutate the timeoutContext.\n   */\n  private contextOwner;\n  /* Excluded from this release type: __constructor */\n  /** The cached resume token that is used to resume after the most recently returned change. */\n  get resumeToken(): ResumeToken;\n  /** Check if there is any document still available in the Change Stream */\n  hasNext(): Promise<boolean>;\n  /** Get the next available document from the Change Stream. */\n  next(): Promise<TChange>;\n  /**\n   * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned\n   */\n  tryNext(): Promise<TChange | null>;\n  [Symbol.asyncIterator](): AsyncGenerator<TChange, void, void>;\n  /** Is the cursor closed */\n  get closed(): boolean;\n  /**\n   * Frees the internal resources used by the change stream.\n   */\n  close(): Promise<void>;\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   *\n   * NOTE: When using a Stream to process change stream events, the stream will\n   * NOT automatically resume in the case a resumable error is encountered.\n   *\n   * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed\n   */\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TChange>;\n  /* Excluded from this release type: _setIsEmitter */\n  /* Excluded from this release type: _setIsIterator */\n  /* Excluded from this release type: _createChangeStreamCursor */\n  /* Excluded from this release type: _closeEmitterModeWithError */\n  /* Excluded from this release type: _streamEvents */\n  /* Excluded from this release type: _endStream */\n  /* Excluded from this release type: _processChange */\n  /* Excluded from this release type: _processErrorStreamMode */\n  /* Excluded from this release type: _processErrorIteratorMode */\n  private _resume;\n}\n\n/**\n * Only present when the `showExpandedEvents` flag is enabled.\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/modify/#mongodb-data-modify\n */\ndeclare interface ChangeStreamCollModDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'modify';\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/create/#mongodb-data-create\n */\ndeclare interface ChangeStreamCreateDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'create';\n  /**\n   * The type of the newly created object.\n   *\n   * @sinceServerVersion 8.1.0\n   */\n  nsType?: 'collection' | 'timeseries' | 'view';\n}\n\n/**\n * Only present when the `showExpandedEvents` flag is enabled.\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/createIndexes/#mongodb-data-createIndexes\n */\ndeclare interface ChangeStreamCreateIndexDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'createIndexes';\n}\ndeclare class ChangeStreamCursor extends ShellApiWithMongoClass {\n  _mongo: Mongo;\n  _cursor: ServiceProviderChangeStream<Document_2>;\n  _currentIterationResult: CursorIterationResult | null;\n  _on: string;\n  constructor(cursor: ServiceProviderChangeStream<Document_2>, on: string, mongo: Mongo);\n  _it(): Promise<CursorIterationResult>;\n  [asPrintable](): string;\n  close(): void;\n  hasNext(): boolean;\n  tryNext(): Document_2 | null;\n  [Symbol.asyncIterator](): AsyncGenerator<Document_2, void, unknown>;\n  isClosed(): boolean;\n  isExhausted(): never;\n  itcount(): number;\n  next(): Document_2;\n  getResumeToken(): ResumeToken;\n  map(): ChangeStreamCursor;\n  forEach(): Promise<void>;\n  toArray(): Promise<Document_2[]>;\n  objsLeftInBatch(): void;\n  pretty(): ChangeStreamCursor;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#delete-event\n */\ndeclare interface ChangeStreamDeleteDocument<TSchema extends Document_2 = Document_2> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'delete';\n  /** Namespace the delete event occurred on */\n  ns: ChangeStreamNameSpace;\n  /**\n   * Contains the pre-image of the modified or deleted document if the\n   * pre-image is available for the change event and either 'required' or\n   * 'whenAvailable' was specified for the 'fullDocumentBeforeChange' option\n   * when creating the change stream. If 'whenAvailable' was specified but the\n   * pre-image is unavailable, this will be explicitly set to null.\n   */\n  fullDocumentBeforeChange?: TSchema;\n}\n\n/** @public */\ndeclare type ChangeStreamDocument<TSchema extends Document_2 = Document_2> = ChangeStreamInsertDocument<TSchema> | ChangeStreamUpdateDocument<TSchema> | ChangeStreamReplaceDocument<TSchema> | ChangeStreamDeleteDocument<TSchema> | ChangeStreamDropDocument | ChangeStreamRenameDocument | ChangeStreamDropDatabaseDocument | ChangeStreamInvalidateDocument | ChangeStreamCreateIndexDocument | ChangeStreamCreateDocument | ChangeStreamCollModDocument | ChangeStreamDropIndexDocument | ChangeStreamShardCollectionDocument | ChangeStreamReshardCollectionDocument | ChangeStreamRefineCollectionShardKeyDocument;\n\n/** @public */\ndeclare interface ChangeStreamDocumentCollectionUUID {\n  /**\n   * The UUID (Binary subtype 4) of the collection that the operation was performed on.\n   *\n   * Only present when the `showExpandedEvents` flag is enabled.\n   *\n   * **NOTE:** collectionUUID will be converted to a NodeJS Buffer if the promoteBuffers\n   *    flag is enabled.\n   *\n   * @sinceServerVersion 6.1.0\n   */\n  collectionUUID: Binary;\n}\n\n/** @public */\ndeclare interface ChangeStreamDocumentCommon {\n  /**\n   * The id functions as an opaque token for use when resuming an interrupted\n   * change stream.\n   */\n  _id: ResumeToken;\n  /**\n   * The timestamp from the oplog entry associated with the event.\n   * For events that happened as part of a multi-document transaction, the associated change stream\n   * notifications will have the same clusterTime value, namely the time when the transaction was committed.\n   * On a sharded cluster, events that occur on different shards can have the same clusterTime but be\n   * associated with different transactions or even not be associated with any transaction.\n   * To identify events for a single transaction, you can use the combination of lsid and txnNumber in the change stream event document.\n   */\n  clusterTime?: Timestamp;\n  /**\n   * The transaction number.\n   * Only present if the operation is part of a multi-document transaction.\n   *\n   * **NOTE:** txnNumber can be a Long if promoteLongs is set to false\n   */\n  txnNumber?: number;\n  /**\n   * The identifier for the session associated with the transaction.\n   * Only present if the operation is part of a multi-document transaction.\n   */\n  lsid?: ServerSessionId;\n  /**\n   * When the change stream's backing aggregation pipeline contains the $changeStreamSplitLargeEvent\n   * stage, events larger than 16MB will be split into multiple events and contain the\n   * following information about which fragment the current event is.\n   */\n  splitEvent?: ChangeStreamSplitEvent;\n}\n\n/** @public */\ndeclare interface ChangeStreamDocumentKey<TSchema extends Document_2 = Document_2> {\n  /**\n   * For unsharded collections this contains a single field `_id`.\n   * For sharded collections, this will contain all the components of the shard key\n   */\n  documentKey: {\n    _id: InferIdType<TSchema>;\n    [shardKey: string]: any;\n  };\n}\n\n/** @public */\ndeclare interface ChangeStreamDocumentOperationDescription {\n  /**\n   * An description of the operation.\n   *\n   * Only present when the `showExpandedEvents` flag is enabled.\n   *\n   * @sinceServerVersion 6.1.0\n   */\n  operationDescription?: Document_2;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#dropdatabase-event\n */\ndeclare interface ChangeStreamDropDatabaseDocument extends ChangeStreamDocumentCommon {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'dropDatabase';\n  /** The database dropped */\n  ns: {\n    db: string;\n  };\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#drop-event\n */\ndeclare interface ChangeStreamDropDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'drop';\n  /** Namespace the drop event occurred on */\n  ns: ChangeStreamNameSpace;\n}\n\n/**\n * Only present when the `showExpandedEvents` flag is enabled.\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/dropIndexes/#mongodb-data-dropIndexes\n */\ndeclare interface ChangeStreamDropIndexDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'dropIndexes';\n}\n\n/** @public */\ndeclare type ChangeStreamEvents<TSchema extends Document_2 = Document_2, TChange extends Document_2 = ChangeStreamDocument<TSchema>> = {\n  resumeTokenChanged(token: ResumeToken): void;\n  init(response: any): void;\n  more(response?: any): void;\n  response(): void;\n  end(): void;\n  error(error: Error): void;\n  change(change: TChange): void;\n  /**\n   * @remarks Note that the `close` event is currently emitted whenever the internal `ChangeStreamCursor`\n   * instance is closed, which can occur multiple times for a given `ChangeStream` instance.\n   *\n   * TODO(NODE-6434): address this issue in NODE-6434\n   */\n  close(): void;\n};\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#insert-event\n */\ndeclare interface ChangeStreamInsertDocument<TSchema extends Document_2 = Document_2> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'insert';\n  /** This key will contain the document being inserted */\n  fullDocument: TSchema;\n  /** Namespace the insert event occurred on */\n  ns: ChangeStreamNameSpace;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#invalidate-event\n */\ndeclare interface ChangeStreamInvalidateDocument extends ChangeStreamDocumentCommon {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'invalidate';\n}\n\n/** @public */\ndeclare interface ChangeStreamNameSpace {\n  db: string;\n  coll: string;\n}\n\n/**\n * Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @public\n */\ndeclare interface ChangeStreamOptions extends Omit<AggregateOptions, 'writeConcern'> {\n  /**\n   * Allowed values: 'updateLookup', 'whenAvailable', 'required'.\n   *\n   * When set to 'updateLookup', the change notification for partial updates\n   * will include both a delta describing the changes to the document as well\n   * as a copy of the entire document that was changed from some time after\n   * the change occurred.\n   *\n   * When set to 'whenAvailable', configures the change stream to return the\n   * post-image of the modified document for replace and update change events\n   * if the post-image for this event is available.\n   *\n   * When set to 'required', the same behavior as 'whenAvailable' except that\n   * an error is raised if the post-image is not available.\n   */\n  fullDocument?: string;\n  /**\n   * Allowed values: 'whenAvailable', 'required', 'off'.\n   *\n   * The default is to not send a value, which is equivalent to 'off'.\n   *\n   * When set to 'whenAvailable', configures the change stream to return the\n   * pre-image of the modified document for replace, update, and delete change\n   * events if it is available.\n   *\n   * When set to 'required', the same behavior as 'whenAvailable' except that\n   * an error is raised if the pre-image is not available.\n   */\n  fullDocumentBeforeChange?: string;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a change stream query. */\n  maxAwaitTimeMS?: number;\n  /**\n   * Allows you to start a changeStream after a specified event.\n   * @see https://www.mongodb.com/docs/manual/changeStreams/#resumeafter-for-change-streams\n   */\n  resumeAfter?: ResumeToken;\n  /**\n   * Similar to resumeAfter, but will allow you to start after an invalidated event.\n   * @see https://www.mongodb.com/docs/manual/changeStreams/#startafter-for-change-streams\n   */\n  startAfter?: ResumeToken;\n  /** Will start the changeStream after the specified operationTime. */\n  startAtOperationTime?: OperationTime;\n  /**\n   * The number of documents to return per batch.\n   * @see https://www.mongodb.com/docs/manual/reference/command/aggregate\n   */\n  batchSize?: number;\n  /**\n   * When enabled, configures the change stream to include extra change events.\n   *\n   * - createIndexes\n   * - dropIndexes\n   * - modify\n   * - create\n   * - shardCollection\n   * - reshardCollection\n   * - refineCollectionShardKey\n   */\n  showExpandedEvents?: boolean;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/refineCollectionShardKey/#mongodb-data-refineCollectionShardKey\n */\ndeclare interface ChangeStreamRefineCollectionShardKeyDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'refineCollectionShardKey';\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#rename-event\n */\ndeclare interface ChangeStreamRenameDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'rename';\n  /** The new name for the `ns.coll` collection */\n  to: {\n    db: string;\n    coll: string;\n  };\n  /** The \"from\" namespace that the rename occurred on */\n  ns: ChangeStreamNameSpace;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#replace-event\n */\ndeclare interface ChangeStreamReplaceDocument<TSchema extends Document_2 = Document_2> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema> {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'replace';\n  /** The fullDocument of a replace event represents the document after the insert of the replacement document */\n  fullDocument: TSchema;\n  /** Namespace the replace event occurred on */\n  ns: ChangeStreamNameSpace;\n  /**\n   * Contains the pre-image of the modified or deleted document if the\n   * pre-image is available for the change event and either 'required' or\n   * 'whenAvailable' was specified for the 'fullDocumentBeforeChange' option\n   * when creating the change stream. If 'whenAvailable' was specified but the\n   * pre-image is unavailable, this will be explicitly set to null.\n   */\n  fullDocumentBeforeChange?: TSchema;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/reshardCollection/#mongodb-data-reshardCollection\n */\ndeclare interface ChangeStreamReshardCollectionDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'reshardCollection';\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/shardCollection/#mongodb-data-shardCollection\n */\ndeclare interface ChangeStreamShardCollectionDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'shardCollection';\n}\n\n/** @public */\ndeclare interface ChangeStreamSplitEvent {\n  /** Which fragment of the change this is. */\n  fragment: number;\n  /** The total number of fragments. */\n  of: number;\n}\n\n/**\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/change-events/#update-event\n */\ndeclare interface ChangeStreamUpdateDocument<TSchema extends Document_2 = Document_2> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentCollectionUUID {\n  /** Describes the type of operation represented in this change notification */\n  operationType: 'update';\n  /**\n   * This is only set if `fullDocument` is set to `'updateLookup'`\n   * Contains the point-in-time post-image of the modified document if the\n   * post-image is available and either 'required' or 'whenAvailable' was\n   * specified for the 'fullDocument' option when creating the change stream.\n   */\n  fullDocument?: TSchema;\n  /** Contains a description of updated and removed fields in this operation */\n  updateDescription: UpdateDescription<TSchema>;\n  /** Namespace the update event occurred on */\n  ns: ChangeStreamNameSpace;\n  /**\n   * Contains the pre-image of the modified or deleted document if the\n   * pre-image is available for the change event and either 'required' or\n   * 'whenAvailable' was specified for the 'fullDocumentBeforeChange' option\n   * when creating the change stream. If 'whenAvailable' was specified but the\n   * pre-image is unavailable, this will be explicitly set to null.\n   */\n  fullDocumentBeforeChange?: TSchema;\n}\ndeclare interface CheckMetadataConsistencyOptions {\n  cursor?: {\n    batchSize: number;\n  };\n  checkIndexes?: 1;\n}\n\n/**\n * A mapping of namespace strings to collections schemas.\n * @public\n *\n * @example\n * ```ts\n * type MongoDBSchemas = {\n *   'db.books': Book;\n *   'db.authors': Author;\n * }\n *\n * const model: ClientBulkWriteModel<MongoDBSchemas> = {\n *   namespace: 'db.books'\n *   name: 'insertOne',\n *   document: { title: 'Practical MongoDB Aggregations', authorName: 3 } // error `authorName` cannot be number\n * };\n * ```\n *\n * The type of the `namespace` field narrows other parts of the BulkWriteModel to use the correct schema for type assertions.\n *\n */\ndeclare type ClientBulkWriteModel<SchemaMap extends Record<string, Document_2> = Record<string, Document_2>> = { [Namespace in keyof SchemaMap]: AnyClientBulkWriteModel<SchemaMap[Namespace]> & {\n  namespace: Namespace;\n} }[keyof SchemaMap];\n\n/** @public */\ndeclare interface ClientBulkWriteOptions extends CommandOperationOptions {\n  /**\n   * If true, when an insert fails, don't execute the remaining writes.\n   * If false, continue with remaining inserts when one fails.\n   * @defaultValue `true` - inserts are ordered by default\n   */\n  ordered?: boolean;\n  /**\n   * Allow driver to bypass schema validation.\n   * @defaultValue `false` - documents will be validated by default\n   **/\n  bypassDocumentValidation?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  /**\n   * Whether detailed results for each successful operation should be included in the returned\n   * BulkWriteResult.\n   */\n  verboseResults?: boolean;\n}\n\n/** @public */\ndeclare interface ClientBulkWriteResult {\n  /**\n   * Whether the bulk write was acknowledged.\n   */\n  readonly acknowledged: boolean;\n  /**\n   * The total number of documents inserted across all insert operations.\n   */\n  readonly insertedCount: number;\n  /**\n   * The total number of documents upserted across all update operations.\n   */\n  readonly upsertedCount: number;\n  /**\n   * The total number of documents matched across all update operations.\n   */\n  readonly matchedCount: number;\n  /**\n   * The total number of documents modified across all update operations.\n   */\n  readonly modifiedCount: number;\n  /**\n   * The total number of documents deleted across all delete operations.\n   */\n  readonly deletedCount: number;\n  /**\n   * The results of each individual insert operation that was successfully performed.\n   */\n  readonly insertResults?: ReadonlyMap<number, ClientInsertOneResult>;\n  /**\n   * The results of each individual update operation that was successfully performed.\n   */\n  readonly updateResults?: ReadonlyMap<number, ClientUpdateResult>;\n  /**\n   * The results of each individual delete operation that was successfully performed.\n   */\n  readonly deleteResults?: ReadonlyMap<number, ClientDeleteResult>;\n}\ndeclare class ClientBulkWriteResult_2 extends ShellApiValueClass {\n  acknowledged: boolean;\n  insertedCount: number;\n  matchedCount: number;\n  modifiedCount: number;\n  deletedCount: number;\n  upsertedCount: number;\n  insertResults?: ReadonlyMap<number, ClientInsertResult>;\n  updateResults?: ReadonlyMap<number, ClientUpdateResult_2>;\n  deleteResults?: ReadonlyMap<number, ClientDeleteResult_2>;\n  constructor({\n    acknowledged,\n    insertedCount,\n    matchedCount,\n    modifiedCount,\n    deletedCount,\n    upsertedCount,\n    insertResults,\n    updateResults,\n    deleteResults\n  }: {\n    acknowledged: boolean;\n    insertedCount: number;\n    matchedCount: number;\n    modifiedCount: number;\n    deletedCount: number;\n    upsertedCount: number;\n    insertResults?: ReadonlyMap<number, ClientInsertResult>;\n    updateResults?: ReadonlyMap<number, ClientUpdateResult_2>;\n    deleteResults?: ReadonlyMap<number, ClientDeleteResult_2>;\n  });\n}\n\n/** @public */\ndeclare interface ClientDeleteManyModel<TSchema> extends ClientWriteModel {\n  name: 'deleteMany';\n  /**\n   * The filter used to determine if a document should be deleted.\n   * For a deleteMany operation, all matches are removed.\n   */\n  filter: Filter<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n}\n\n/** @public */\ndeclare interface ClientDeleteOneModel<TSchema> extends ClientWriteModel {\n  name: 'deleteOne';\n  /**\n   * The filter used to determine if a document should be deleted.\n   * For a deleteOne operation, the first match is removed.\n   */\n  filter: Filter<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n}\n\n/** @public */\ndeclare interface ClientDeleteResult {\n  /**\n   * The number of documents that were deleted.\n   */\n  deletedCount: number;\n}\ndeclare type ClientDeleteResult_2 = {\n  deletedCount: number;\n};\n\n/**\n * @public\n * The public interface for explicit in-use encryption\n */\ndeclare class ClientEncryption {\n  /* Excluded from this release type: _client */\n  /* Excluded from this release type: _keyVaultNamespace */\n  /* Excluded from this release type: _keyVaultClient */\n  /* Excluded from this release type: _proxyOptions */\n  /* Excluded from this release type: _tlsOptions */\n  /* Excluded from this release type: _kmsProviders */\n  /* Excluded from this release type: _timeoutMS */\n  /* Excluded from this release type: _mongoCrypt */\n  /* Excluded from this release type: getMongoCrypt */\n  /**\n   * Create a new encryption instance\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     local: {\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     aws: {\n   *       accessKeyId: AWS_ACCESS_KEY,\n   *       secretAccessKey: AWS_SECRET_KEY\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  constructor(client: MongoClient, options: ClientEncryptionOptions);\n  /**\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create a local key\n   * const dataKeyId = await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key with a keyAltName\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   },\n   *   keyAltNames: [ 'mySpecialKey' ]\n   * });\n   * ```\n   */\n  createDataKey(provider: ClientEncryptionDataKeyProvider, options?: ClientEncryptionCreateDataKeyProviderOptions): Promise<UUID>;\n  /**\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\n   *\n   * If no matches are found, then no bulk write is performed.\n   *\n   * @example\n   * ```ts\n   * // rewrapping all data data keys (using a filter that matches all documents)\n   * const filter = {};\n   *\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   * if (result.bulkWriteResult != null) {\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // attempting to rewrap all data keys with no matches\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   *\n   * if (result.bulkWriteResult == null) {\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\n   * }\n   * ```\n   */\n  rewrapManyDataKey(filter: Filter<DataKey>, options: ClientEncryptionRewrapManyDataKeyProviderOptions): Promise<{\n    bulkWriteResult?: BulkWriteResult_2;\n  }>;\n  /**\n   * Deletes the key with the provided id from the keyvault, if it exists.\n   *\n   * @example\n   * ```ts\n   * // delete a key by _id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\n   *\n   * if (deletedCount != null && deletedCount > 0) {\n   *   // successful deletion\n   * }\n   * ```\n   *\n   */\n  deleteKey(_id: Binary): Promise<DeleteResult_2>;\n  /**\n   * Finds all the keys currently stored in the keyvault.\n   *\n   * This method will not throw.\n   *\n   * @returns a FindCursor over all keys in the keyvault.\n   * @example\n   * ```ts\n   * // fetching all keys\n   * const keys = await clientEncryption.getKeys().toArray();\n   * ```\n   */\n  getKeys(): FindCursor<DataKey>;\n  /**\n   * Finds a key in the keyvault with the specified _id.\n   *\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // getting a key by id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const key = await clientEncryption.getKey(id);\n   * if (!key) {\n   *  // key is null if there was no matching key\n   * }\n   * ```\n   */\n  getKey(_id: Binary): Promise<DataKey | null>;\n  /**\n   * Finds a key in the keyvault which has the specified keyAltName.\n   *\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // get a key by alt name\n   * const keyAltName = 'keyAltName';\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\n   * if (!key) {\n   *  // key is null if there is no matching key\n   * }\n   * ```\n   */\n  getKeyByAltName(keyAltName: string): Promise<WithId<DataKey> | null>;\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // adding an keyAltName to a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  addKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null>;\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\n   *\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // removing a key alt name from a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\n   *\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  removeKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null>;\n  /**\n   * A convenience method for creating an encrypted collection.\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\n   * and then create a new collection with the full set of encryptedFields.\n   *\n   * @param db - A Node.js driver Db object with which to create the collection\n   * @param name - The name of the collection to be created\n   * @param options - Options for createDataKey and for createCollection\n   * @returns created collection and generated encryptedFields\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\n   */\n  createEncryptedCollection<TSchema extends Document_2 = Document_2>(db: Db, name: string, options: {\n    provider: ClientEncryptionDataKeyProvider;\n    createCollectionOptions: Omit<CreateCollectionOptions, 'encryptedFields'> & {\n      encryptedFields: Document_2;\n    };\n    masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;\n  }): {\n    collection: Collection_2<TSchema>;\n    encryptedFields: Document_2;\n  };\n  /**\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\n   * @param options -\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\n   *\n   * @example\n   * ```ts\n   * // Encryption with async/await api\n   * async function encryptMyData(value) {\n   *   const keyId = await clientEncryption.createDataKey('local');\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Encryption using a keyAltName\n   * async function encryptMyData(value) {\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   */\n  encrypt(value: unknown, options: ClientEncryptionEncryptOptions): Binary;\n  /**\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\n   *\n   * Only supported when queryType is \"range\" and algorithm is \"Range\".\n   *\n   * @param expression - a BSON document of one of the following forms:\n   *  1. A Match Expression of this form:\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\n   *  2. An Aggregate Expression of this form:\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\n   *\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\n   *\n   * @param options -\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\n   */\n  encryptExpression(expression: Document_2, options: ClientEncryptionEncryptOptions): Binary;\n  /**\n   * Explicitly decrypt a provided encrypted value\n   *\n   * @param value - An encrypted value\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\n   *\n   * @example\n   * ```ts\n   * // Decrypting value with async/await API\n   * async function decryptMyValue(value) {\n   *   return clientEncryption.decrypt(value);\n   * }\n   * ```\n   */\n  decrypt<T = any>(value: Binary): T;\n  /* Excluded from this release type: askForKMSCredentials */\n  static get libmongocryptVersion(): string;\n  /* Excluded from this release type: _encrypt */\n}\ndeclare class ClientEncryption_2 extends ShellApiWithMongoClass {\n  _mongo: Mongo;\n  _libmongocrypt: ClientEncryption;\n  constructor(mongo: Mongo);\n  [asPrintable](): string;\n  encrypt(keyId: Binary, value: any, algorithmOrEncryptionOptions: ClientEncryptionEncryptOptions['algorithm'] | ClientEncryptionEncryptOptions): Promise<Binary>;\n  decrypt(encryptedValue: Binary): Promise<any>;\n  encryptExpression(keyId: Binary, value: Document_2, options: ClientEncryptionEncryptOptions): Promise<Binary>;\n  createEncryptedCollection(dbName: string, collName: string, options: CreateEncryptedCollectionOptions): Promise<{\n    collection: Collection;\n    encryptedFields: Document_2;\n  }>;\n}\n\n/**\n * @public\n * Options to provide when creating a new data key.\n */\ndeclare interface ClientEncryptionCreateDataKeyProviderOptions {\n  /**\n   * Identifies a new KMS-specific key used to encrypt the new data key\n   */\n  masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions | KMIPEncryptionKeyOptions | undefined;\n  /**\n   * An optional list of string alternate names used to reference a key.\n   * If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n   */\n  keyAltNames?: string[] | undefined;\n  /** @experimental */\n  keyMaterial?: Buffer | Binary;\n  /* Excluded from this release type: timeoutContext */\n}\n\n/**\n * @public\n *\n * A data key provider.  Allowed values:\n *\n * - aws, gcp, local, kmip or azure\n * - (`mongodb-client-encryption>=6.0.1` only) a named key, in the form of:\n *    `aws:<name>`, `gcp:<name>`, `local:<name>`, `kmip:<name>`, `azure:<name>`\n *  where `name` is an alphanumeric string, underscores allowed.\n */\ndeclare type ClientEncryptionDataKeyProvider = keyof KMSProviders;\n\n/**\n * @public\n * Options to provide when encrypting data.\n */\ndeclare interface ClientEncryptionEncryptOptions {\n  /**\n   * The algorithm to use for encryption.\n   */\n  algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random' | 'Indexed' | 'Unindexed' | 'Range';\n  /**\n   * The id of the Binary dataKey to use for encryption\n   */\n  keyId?: Binary;\n  /**\n   * A unique string name corresponding to an already existing dataKey.\n   */\n  keyAltName?: string;\n  /** The contention factor. */\n  contentionFactor?: bigint | number;\n  /**\n   * The query type.\n   */\n  queryType?: 'equality' | 'range';\n  /** The index options for a Queryable Encryption field supporting \"range\" queries.*/\n  rangeOptions?: RangeOptions;\n}\n\n/**\n * @public\n * Additional settings to provide when creating a new `ClientEncryption` instance.\n */\ndeclare interface ClientEncryptionOptions {\n  /**\n   * The namespace of the key vault, used to store encryption keys\n   */\n  keyVaultNamespace: string;\n  /**\n   * A MongoClient used to fetch keys from a key vault. Defaults to client.\n   */\n  keyVaultClient?: MongoClient | undefined;\n  /**\n   * Options for specific KMS providers to use\n   */\n  kmsProviders?: KMSProviders;\n  /**\n   * Options for specifying a Socks5 proxy to use for connecting to the KMS.\n   */\n  proxyOptions?: ProxyOptions;\n  /**\n   * TLS options for kms providers to use.\n   */\n  tlsOptions?: CSFLEKMSTlsOptions;\n  /**\n   * @experimental\n   *\n   * The timeout setting to be used for all the operations on ClientEncryption.\n   *\n   * When provided, `timeoutMS` is used as the timeout for each operation executed on\n   * the ClientEncryption object.  For example:\n   *\n   * ```typescript\n   * const clientEncryption = new ClientEncryption(client, {\n   *  timeoutMS: 1_000\n   *  kmsProviders: { local: { key: '<KEY>' } }\n   * });\n   *\n   * // `1_000` is used as the timeout for createDataKey call\n   * await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * If `timeoutMS` is configured on the provided client, the client's `timeoutMS` value\n   * will be used unless `timeoutMS` is also provided as a client encryption option.\n   *\n   * ```typescript\n   * const client = new MongoClient('<uri>', { timeoutMS: 2_000 });\n   *\n   * // timeoutMS is set to 1_000 on clientEncryption\n   * const clientEncryption = new ClientEncryption(client, {\n   *  timeoutMS: 1_000\n   *  kmsProviders: { local: { key: '<KEY>' } }\n   * });\n   * ```\n   */\n  timeoutMS?: number;\n}\n\n/**\n * @public\n * @experimental\n */\ndeclare interface ClientEncryptionRewrapManyDataKeyProviderOptions {\n  provider: ClientEncryptionDataKeyProvider;\n  masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions | KMIPEncryptionKeyOptions | undefined;\n}\n\n/**\n * @public\n *\n * TLS options to use when connecting. The spec specifically calls out which insecure\n * tls options are not allowed:\n *\n *  - tlsAllowInvalidCertificates\n *  - tlsAllowInvalidHostnames\n *  - tlsInsecure\n *\n * These options are not included in the type, and are ignored if provided.\n */\ndeclare type ClientEncryptionTlsOptions = Pick<MongoClientOptions, 'tlsCAFile' | 'tlsCertificateKeyFile' | 'tlsCertificateKeyFilePassword'>;\n\n/** @public */\ndeclare interface ClientInsertOneModel<TSchema> extends ClientWriteModel {\n  name: 'insertOne';\n  /** The document to insert. */\n  document: OptionalId<TSchema>;\n}\n\n/** @public */\ndeclare interface ClientInsertOneResult {\n  /**\n   * The _id of the inserted document.\n   */\n  insertedId: any;\n}\ndeclare type ClientInsertResult = {\n  insertedId: any;\n};\n\n/**\n * @public\n * @see https://github.com/mongodb/specifications/blob/master/source/mongodb-handshake/handshake.md#hello-command\n */\ndeclare interface ClientMetadata {\n  driver: {\n    name: string;\n    version: string;\n  };\n  os: {\n    type: string;\n    name?: NodeJS.Platform;\n    architecture?: string;\n    version?: string;\n  };\n  platform: string;\n  application?: {\n    name: string;\n  };\n  /** FaaS environment information */\n  env?: {\n    name: 'aws.lambda' | 'gcp.func' | 'azure.func' | 'vercel';\n    timeout_sec?: Int32;\n    memory_mb?: Int32;\n    region?: string;\n    url?: string;\n  };\n}\n\n/** @public */\ndeclare interface ClientReplaceOneModel<TSchema> extends ClientWriteModel {\n  name: 'replaceOne';\n  /**\n   * The filter used to determine if a document should be replaced.\n   * For a replaceOne operation, the first match is replaced.\n   */\n  filter: Filter<TSchema>;\n  /** The document with which to replace the matched document. */\n  replacement: WithoutId<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\ndeclare class ClientSession extends TypedEventEmitter<ClientSessionEvents> implements AsyncDisposable_2 {\n  /* Excluded from this release type: client */\n  /* Excluded from this release type: sessionPool */\n  hasEnded: boolean;\n  clientOptions: MongoOptions;\n  supports: {\n    causalConsistency: boolean;\n  };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /* Excluded from this release type: owner */\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /* Excluded from this release type: commitAttempted */\n  readonly snapshotEnabled: boolean;\n  /* Excluded from this release type: _serverSession */\n  /* Excluded from this release type: snapshotTime */\n  /* Excluded from this release type: pinnedConnection */\n  /* Excluded from this release type: txnNumberIncrement */\n  /**\n   * @experimental\n   * Specifies the time an operation in a given `ClientSession` will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n  /* Excluded from this release type: timeoutContext */\n  /* Excluded from this release type: __constructor */\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined;\n  get serverSession(): ServerSession;\n  get loadBalanced(): boolean;\n  /* Excluded from this release type: pin */\n  /* Excluded from this release type: unpin */\n  get isPinned(): boolean;\n  /**\n   * Frees any client-side resources held by the current session.  If a session is in a transaction,\n   * the transaction is aborted.\n   *\n   * Does not end the session on the server.\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  endSession(options?: EndSessionOptions): Promise<void>;\n  /* Excluded from this release type: [Symbol.asyncDispose] */\n  /* Excluded from this release type: asyncDispose */\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void;\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime: ClusterTime): void;\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean;\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber(): void;\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean;\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @remarks\n   * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void;\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param options - Optional options, can be used to override `defaultTimeoutMS`.\n   */\n  commitTransaction(options?: {\n    timeoutMS?: number;\n  }): Promise<void>;\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param options - Optional options, can be used to override `defaultTimeoutMS`.\n   */\n  abortTransaction(options?: {\n    timeoutMS?: number;\n  }): Promise<void>;\n  /* Excluded from this release type: abortTransaction */\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never;\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.\n   *\n   * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   * **IMPORTANT:** When running an operation inside a `withTransaction` callback, if it is not\n   * provided the explicit session in its options, it will not be part of the transaction and it will not respect timeoutMS.\n   *\n   *\n   * @remarks\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * If a command inside withTransaction fails:\n   * - It may cause the transaction on the server to be aborted.\n   * - This situation is normally handled transparently by the driver.\n   * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.\n   * - The driver will then retry the transaction indefinitely.\n   *\n   * To avoid this situation, the application must not silently handle errors within the provided function.\n   * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  withTransaction<T = any>(fn: WithTransactionCallback<T>, options?: TransactionOptions & {\n    /**\n     * Configures a timeoutMS expiry for the entire withTransactionCallback.\n     *\n     * @remarks\n     * - The remaining timeout will not be applied to callback operations that do not use the ClientSession.\n     * - Overriding timeoutMS for operations executed using the explicit session inside the provided callback will result in a client-side error.\n     */\n    timeoutMS?: number;\n  }): Promise<T>;\n}\n\n/** @public */\ndeclare type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @public */\ndeclare interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n  /**\n   * @public\n   * @experimental\n   * An overriding timeoutMS value to use for a client-side timeout.\n   * If not provided the session uses the timeoutMS specified on the MongoClient.\n   */\n  defaultTimeoutMS?: number;\n  /* Excluded from this release type: owner */\n  /* Excluded from this release type: explicit */\n  /* Excluded from this release type: initialClusterTime */\n}\ndeclare interface ClientSideFieldLevelEncryptionOptions {\n  keyVaultClient?: Mongo;\n  keyVaultNamespace: string;\n  kmsProviders: KMSProviders;\n  schemaMap?: Document_2;\n  bypassAutoEncryption?: boolean;\n  explicitEncryptionOnly?: boolean;\n  tlsOptions?: { [k in keyof KMSProviders]?: ClientEncryptionTlsOptions };\n  encryptedFieldsMap?: Document_2;\n  bypassQueryAnalysis?: boolean;\n}\n\n/** @public */\ndeclare interface ClientUpdateManyModel<TSchema> extends ClientWriteModel {\n  name: 'updateMany';\n  /**\n   * The filter used to determine if a document should be updated.\n   * For an updateMany operation, all matches are updated.\n   */\n  filter: Filter<TSchema>;\n  /**\n   * The modifications to apply. The value can be either:\n   * UpdateFilter<Document> - A document that contains update operator expressions,\n   * Document[] - an aggregation pipeline.\n   */\n  update: UpdateFilter<TSchema> | Document_2[];\n  /** A set of filters specifying to which array elements an update should apply. */\n  arrayFilters?: Document_2[];\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\ndeclare interface ClientUpdateOneModel<TSchema> extends ClientWriteModel {\n  name: 'updateOne';\n  /**\n   * The filter used to determine if a document should be updated.\n   * For an updateOne operation, the first match is updated.\n   */\n  filter: Filter<TSchema>;\n  /**\n   * The modifications to apply. The value can be either:\n   * UpdateFilter<Document> - A document that contains update operator expressions,\n   * Document[] - an aggregation pipeline.\n   */\n  update: UpdateFilter<TSchema> | Document_2[];\n  /** A set of filters specifying to which array elements an update should apply. */\n  arrayFilters?: Document_2[];\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\ndeclare interface ClientUpdateResult {\n  /**\n   * The number of documents that matched the filter.\n   */\n  matchedCount: number;\n  /**\n   * The number of documents that were modified.\n   */\n  modifiedCount: number;\n  /**\n   * The _id field of the upserted document if an upsert occurred.\n   *\n   * It MUST be possible to discern between a BSON Null upserted ID value and this field being\n   * unset. If necessary, drivers MAY add a didUpsert boolean field to differentiate between\n   * these two cases.\n   */\n  upsertedId?: any;\n  /**\n   * Determines if the upsert did include an _id, which includes the case of the _id being null.\n   */\n  didUpsert: boolean;\n}\ndeclare type ClientUpdateResult_2 = {\n  matchedCount: number;\n  modifiedCount: number;\n  upsertedId?: any;\n  didUpsert: boolean;\n};\n\n/** @public */\ndeclare interface ClientWriteModel {\n  /**\n   * The namespace for the write.\n   *\n   * A namespace is a combination of the database name and the name of the collection: `<database-name>.<collection>`.\n   * All documents belong to a namespace.\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/limits/#std-label-faq-dev-namespace\n   */\n  namespace: string;\n}\ndeclare interface Closable {\n  close(force: boolean): Promise<void>;\n  suspend(): Promise<() => Promise<void>>;\n}\n\n/** @public\n * Configuration options for clustered collections\n * @see https://www.mongodb.com/docs/manual/core/clustered-collections/\n */\ndeclare interface ClusteredCollectionOptions extends Document_2 {\n  name?: string;\n  key: Document_2;\n  unique: boolean;\n}\n\n/**\n * @public\n * Gossiped in component for the cluster time tracking the state of user databases\n * across the cluster. It may optionally include a signature identifying the process that\n * generated such a value.\n */\ndeclare interface ClusterTime {\n  clusterTime: Timestamp;\n  /** Used to validate the identity of a request or response's ClusterTime. */\n  signature?: {\n    hash: Binary;\n    keyId: Long;\n  };\n}\n\n/**\n * A class representation of the BSON Code type.\n * @public\n * @category BSONType\n */\ndeclare class Code extends BSONValue {\n  get _bsontype(): 'Code';\n  code: string;\n  scope: Document_2 | null;\n  /**\n   * @param code - a string or function.\n   * @param scope - an optional scope for the function.\n   */\n  constructor(code: string | Function, scope?: Document_2 | null);\n  toJSON(): {\n    code: string;\n    scope?: Document_2;\n  };\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface CollationOptions {\n  locale: string;\n  caseLevel?: boolean;\n  caseFirst?: string;\n  strength?: number;\n  numericOrdering?: boolean;\n  alternate?: string;\n  maxVariable?: string;\n  backwards?: boolean;\n  normalization?: boolean;\n}\nexport declare type Collection<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = M[keyof M], C extends GenericCollectionSchema = D[keyof D], N extends StringKey<D> = StringKey<D>> = CollectionImpl<M, D, C, N> & { [k in StringKey<D> as k extends `${N}.${infer S}` ? S : never]: Collection<M, D, D[k], k> };\n\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const pets = client.db().collection<Pet>('pets');\n *\n * const petCursor = pets.find();\n *\n * for await (const pet of petCursor) {\n *   console.log(`${pet.name} is a ${pet.kind}!`);\n * }\n * ```\n */\ndeclare class Collection_2<TSchema extends Document_2 = Document_2> {\n  /* Excluded from this release type: s */\n  /* Excluded from this release type: client */\n  /* Excluded from this release type: __constructor */\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName(): string;\n  /**\n   * The name of this collection\n   */\n  get collectionName(): string;\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace(): string;\n  /* Excluded from this release type: fullNamespace */\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern(): ReadConcern | undefined;\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference(): ReadPreference | undefined;\n  get bsonOptions(): BSONSerializeOptions;\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern(): WriteConcern | undefined;\n  /** The current index hint for the collection */\n  get hint(): Hint | undefined;\n  set hint(v: Hint | undefined);\n  get timeoutMS(): number | undefined;\n  /**\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param doc - The document to insert\n   * @param options - Optional settings for the command\n   */\n  insertOne(doc: OptionalUnlessRequiredId<TSchema>, options?: InsertOneOptions): Promise<InsertOneResult_2<TSchema>>;\n  /**\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   */\n  insertMany(docs: ReadonlyArray<OptionalUnlessRequiredId<TSchema>>, options?: BulkWriteOptions): Promise<InsertManyResult_2<TSchema>>;\n  /**\n   * Perform a bulkWrite operation without a fluent API\n   *\n   * Legal operation types are\n   * - `insertOne`\n   * - `replaceOne`\n   * - `updateOne`\n   * - `updateMany`\n   * - `deleteOne`\n   * - `deleteMany`\n   *\n   * If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param operations - Bulk operations to perform\n   * @param options - Optional settings for the command\n   * @throws MongoDriverError if operations is not an array\n   */\n  bulkWrite(operations: ReadonlyArray<AnyBulkWriteOperation<TSchema>>, options?: BulkWriteOptions): Promise<BulkWriteResult_2>;\n  /**\n   * Update a single document in a collection\n   *\n   * The value of `update` can be either:\n   * - UpdateFilter<TSchema> - A document that contains update operator expressions,\n   * - Document[] - an aggregation pipeline.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The modifications to apply\n   * @param options - Optional settings for the command\n   */\n  updateOne(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document_2[], options?: UpdateOptions): Promise<UpdateResult_2<TSchema>>;\n  /**\n   * Replace a document in a collection with another document\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  replaceOne(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options?: ReplaceOptions): Promise<UpdateResult_2<TSchema>>;\n  /**\n   * Update multiple documents in a collection\n   *\n   * The value of `update` can be either:\n   * - UpdateFilter<TSchema> - A document that contains update operator expressions,\n   * - Document[] - an aggregation pipeline.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The modifications to apply\n   * @param options - Optional settings for the command\n   */\n  updateMany(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document_2[], options?: UpdateOptions): Promise<UpdateResult_2<TSchema>>;\n  /**\n   * Delete a document from a collection\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  deleteOne(filter?: Filter<TSchema>, options?: DeleteOptions): Promise<DeleteResult_2>;\n  /**\n   * Delete multiple documents from a collection\n   *\n   * @param filter - The filter used to select the documents to remove\n   * @param options - Optional settings for the command\n   */\n  deleteMany(filter?: Filter<TSchema>, options?: DeleteOptions): Promise<DeleteResult_2>;\n  /**\n   * Rename the collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the Db or MongoClient.\n   *\n   * @param newName - New name of of the collection.\n   * @param options - Optional settings for the command\n   */\n  rename(newName: string, options?: RenameOptions): Promise<Collection_2>;\n  /**\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  drop(options?: DropCollectionOptions): Promise<boolean>;\n  /**\n   * Fetches the first document that matches the filter\n   *\n   * @param filter - Query for find Operation\n   * @param options - Optional settings for the command\n   */\n  findOne(): Promise<WithId<TSchema> | null>;\n  findOne(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\n  findOne(filter: Filter<TSchema>, options: Omit<FindOptions, 'timeoutMode'> & Abortable): Promise<WithId<TSchema> | null>;\n  findOne<T = TSchema>(): Promise<T | null>;\n  findOne<T = TSchema>(filter: Filter<TSchema>): Promise<T | null>;\n  findOne<T = TSchema>(filter: Filter<TSchema>, options?: Omit<FindOptions, 'timeoutMode'> & Abortable): Promise<T | null>;\n  /**\n   * Creates a cursor for a filter that can be used to iterate over results from MongoDB\n   *\n   * @param filter - The filter predicate. If unspecified, then all documents in the collection will match the predicate\n   */\n  find(): FindCursor<WithId<TSchema>>;\n  find(filter: Filter<TSchema>, options?: FindOptions & Abortable): FindCursor<WithId<TSchema>>;\n  find<T extends Document_2>(filter: Filter<TSchema>, options?: FindOptions & Abortable): FindCursor<T>;\n  /**\n   * Returns the options of the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  options(options?: OperationOptions): Promise<Document_2>;\n  /**\n   * Returns if the collection is a capped collection\n   *\n   * @param options - Optional settings for the command\n   */\n  isCapped(options?: OperationOptions): Promise<boolean>;\n  /**\n   * Creates an index on the db and collection collection.\n   *\n   * @param indexSpec - The field name or index specification to create an index for\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   *\n   * await collection.createIndex({ a: 1, b: -1 });\n   *\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\n   *\n   * // Equivalent to { e: 1 }\n   * await collection.createIndex('e');\n   *\n   * // Equivalent to { f: 1, g: 1 }\n   * await collection.createIndex(['f', 'g'])\n   *\n   * // Equivalent to { h: 1, i: -1 }\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n   *\n   * // Equivalent to { j: 1, k: -1, l: 2d }\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n   * ```\n   */\n  createIndex(indexSpec: IndexSpecification, options?: CreateIndexesOptions): Promise<string>;\n  /**\n   * Creates multiple indexes in the collection, this method is only supported for\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n   * error.\n   *\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n   * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.\n   *\n   * @param indexSpecs - An array of index specifications to be created\n   * @param options - Optional settings for the command\n   *\n   * @example\n   * ```ts\n   * const collection = client.db('foo').collection('bar');\n   * await collection.createIndexes([\n   *   // Simple index on field fizz\n   *   {\n   *     key: { fizz: 1 },\n   *   }\n   *   // wildcard index\n   *   {\n   *     key: { '$**': 1 }\n   *   },\n   *   // named index on darmok and jalad\n   *   {\n   *     key: { darmok: 1, jalad: -1 }\n   *     name: 'tanagra'\n   *   }\n   * ]);\n   * ```\n   */\n  createIndexes(indexSpecs: IndexDescription[], options?: CreateIndexesOptions): Promise<string[]>;\n  /**\n   * Drops an index from this collection.\n   *\n   * @param indexName - Name of the index to drop.\n   * @param options - Optional settings for the command\n   */\n  dropIndex(indexName: string, options?: DropIndexesOptions): Promise<Document_2>;\n  /**\n   * Drops all indexes from this collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  dropIndexes(options?: DropIndexesOptions): Promise<boolean>;\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options?: ListIndexesOptions): ListIndexesCursor;\n  /**\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\n   *\n   * @param indexes - One or more index names to check.\n   * @param options - Optional settings for the command\n   */\n  indexExists(indexes: string | string[], options?: ListIndexesOptions): Promise<boolean>;\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param options - Optional settings for the command\n   */\n  indexInformation(options: IndexInformationOptions & {\n    full: true;\n  }): Promise<IndexDescriptionInfo[]>;\n  indexInformation(options: IndexInformationOptions & {\n    full?: false;\n  }): Promise<IndexDescriptionCompact>;\n  indexInformation(options: IndexInformationOptions): Promise<IndexDescriptionCompact | IndexDescriptionInfo[]>;\n  indexInformation(): Promise<IndexDescriptionCompact>;\n  /**\n   * Gets an estimate of the count of documents in a collection using collection metadata.\n   * This will always run a count command on all server versions.\n   *\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\n   * encountering errors.\n   *\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\n   * @param options - Optional settings for the command\n   */\n  estimatedDocumentCount(options?: EstimatedDocumentCountOptions): Promise<number>;\n  /**\n   * Gets the number of documents matching the filter.\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * Due to countDocuments using the $match aggregation pipeline stage, certain query operators cannot be used in countDocuments. This includes the $where and $near query operators, among others. Details can be found in the documentation for the $match aggregation pipeline stage.\n   *\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n   * the following query operators must be replaced:\n   *\n   * | Operator | Replacement |\n   * | -------- | ----------- |\n   * | `$where`   | [`$expr`][1] |\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n   *\n   * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n   * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n   * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n   * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   *\n   * @param filter - The filter for the count\n   * @param options - Optional settings for the command\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   */\n  countDocuments(filter?: Filter<TSchema>, options?: CountDocumentsOptions & Abortable): Promise<number>;\n  /**\n   * The distinct command returns a list of distinct values for the given key across a collection.\n   *\n   * @param key - Field of the document to find distinct values for\n   * @param filter - The filter for filtering the set of documents to which we apply the distinct filter.\n   * @param options - Optional settings for the command\n   */\n  distinct<Key extends keyof WithId<TSchema>>(key: Key): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(key: Key, filter: Filter<TSchema>): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(key: Key, filter: Filter<TSchema>, options: DistinctOptions): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct(key: string): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;\n  /**\n   * Retrieve all the indexes on the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  indexes(options: IndexInformationOptions & {\n    full?: true;\n  }): Promise<IndexDescriptionInfo[]>;\n  indexes(options: IndexInformationOptions & {\n    full: false;\n  }): Promise<IndexDescriptionCompact>;\n  indexes(options: IndexInformationOptions): Promise<IndexDescriptionCompact | IndexDescriptionInfo[]>;\n  indexes(options?: ListIndexesOptions): Promise<IndexDescriptionInfo[]>;\n  /**\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   */\n  findOneAndDelete(filter: Filter<TSchema>, options: FindOneAndDeleteOptions & {\n    includeResultMetadata: true;\n  }): Promise<ModifyResult<TSchema>>;\n  findOneAndDelete(filter: Filter<TSchema>, options: FindOneAndDeleteOptions & {\n    includeResultMetadata: false;\n  }): Promise<WithId<TSchema> | null>;\n  findOneAndDelete(filter: Filter<TSchema>, options: FindOneAndDeleteOptions): Promise<WithId<TSchema> | null>;\n  findOneAndDelete(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\n  /**\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   */\n  findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options: FindOneAndReplaceOptions & {\n    includeResultMetadata: true;\n  }): Promise<ModifyResult<TSchema>>;\n  findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options: FindOneAndReplaceOptions & {\n    includeResultMetadata: false;\n  }): Promise<WithId<TSchema> | null>;\n  findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options: FindOneAndReplaceOptions): Promise<WithId<TSchema> | null>;\n  findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>): Promise<WithId<TSchema> | null>;\n  /**\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * The value of `update` can be either:\n   * - UpdateFilter<TSchema> - A document that contains update operator expressions,\n   * - Document[] - an aggregation pipeline consisting of the following stages:\n   *   - $addFields and its alias $set\n   *   - $project and its alias $unset\n   *   - $replaceRoot and its alias $replaceWith.\n   * See the [findAndModify command documentation](https://www.mongodb.com/docs/manual/reference/command/findAndModify) for details.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The modifications to apply\n   * @param options - Optional settings for the command\n   */\n  findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document_2[], options: FindOneAndUpdateOptions & {\n    includeResultMetadata: true;\n  }): Promise<ModifyResult<TSchema>>;\n  findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document_2[], options: FindOneAndUpdateOptions & {\n    includeResultMetadata: false;\n  }): Promise<WithId<TSchema> | null>;\n  findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document_2[], options: FindOneAndUpdateOptions): Promise<WithId<TSchema> | null>;\n  findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document_2[]): Promise<WithId<TSchema> | null>;\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate<T extends Document_2 = Document_2>(pipeline?: Document_2[], options?: AggregateOptions & Abortable): AggregationCursor_2<T>;\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @remarks\n   * When `timeoutMS` is configured for a change stream, it will have different behaviour depending\n   * on whether the change stream is in iterator mode or emitter mode. In both cases, a change\n   * stream will time out if it does not receive a change event within `timeoutMS` of the last change\n   * event.\n   *\n   * Note that if a change stream is consistently timing out when watching a collection, database or\n   * client that is being changed, then this may be due to the server timing out before it can finish\n   * processing the existing oplog. To address this, restart the change stream with a higher\n   * `timeoutMS`.\n   *\n   * If the change stream times out the initial aggregate operation to establish the change stream on\n   * the server, then the client will close the change stream. If the getMore calls to the server\n   * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError\n   * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in\n   * emitter mode.\n   *\n   * To determine whether or not the change stream is still open following a timeout, check the\n   * {@link ChangeStream.closed} getter.\n   *\n   * @example\n   * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.\n   * The next call can just be retried after this succeeds.\n   * ```ts\n   * const changeStream = collection.watch([], { timeoutMS: 100 });\n   * try {\n   *     await changeStream.next();\n   * } catch (e) {\n   *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {\n   *       await changeStream.next();\n   *     }\n   *     throw e;\n   * }\n   * ```\n   *\n   * @example\n   * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will\n   * emit an error event that returns a MongoOperationTimeoutError, but will not close the change\n   * stream unless the resume attempt fails. There is no need to re-establish change listeners as\n   * this will automatically continue emitting change events once the resume attempt completes.\n   *\n   * ```ts\n   * const changeStream = collection.watch([], { timeoutMS: 100 });\n   * changeStream.on('change', console.log);\n   * changeStream.on('error', e => {\n   *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {\n   *         // do nothing\n   *     } else {\n   *         changeStream.close();\n   *     }\n   * });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch<TLocal extends Document_2 = TSchema, TChange extends Document_2 = ChangeStreamDocument<TLocal>>(pipeline?: Document_2[], options?: ChangeStreamOptions): ChangeStream<TLocal, TChange>;\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation;\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n  initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation;\n  /**\n   * An estimated count of matching documents in the db to a filter.\n   *\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n   *\n   * @param filter - The filter for the count.\n   * @param options - Optional settings for the command\n   */\n  count(filter?: Filter<TSchema>, options?: CountOptions): Promise<number>;\n  /**\n   * Returns all search indexes for the current collection.\n   *\n   * @param options - The options for the list indexes operation.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  listSearchIndexes(options?: ListSearchIndexesOptions): ListSearchIndexesCursor;\n  /**\n   * Returns all search indexes for the current collection.\n   *\n   * @param name - The name of the index to search for.  Only indexes with matching index names will be returned.\n   * @param options - The options for the list indexes operation.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  listSearchIndexes(name: string, options?: ListSearchIndexesOptions): ListSearchIndexesCursor;\n  /**\n   * Creates a single search index for the collection.\n   *\n   * @param description - The index description for the new search index.\n   * @returns A promise that resolves to the name of the new search index.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  createSearchIndex(description: SearchIndexDescription): Promise<string>;\n  /**\n   * Creates multiple search indexes for the current collection.\n   *\n   * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.\n   * @returns A promise that resolves to an array of the newly created search index names.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   * @returns\n   */\n  createSearchIndexes(descriptions: SearchIndexDescription[]): Promise<string[]>;\n  /**\n   * Deletes a search index by index name.\n   *\n   * @param name - The name of the search index to be deleted.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  dropSearchIndex(name: string): Promise<void>;\n  /**\n   * Updates a search index by replacing the existing index definition with the provided definition.\n   *\n   * @param name - The name of the search index to update.\n   * @param definition - The new search index definition.\n   *\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\n   */\n  updateSearchIndex(name: string, definition: Document_2): Promise<void>;\n}\ndeclare class CollectionImpl<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = M[keyof M], C extends GenericCollectionSchema = D[keyof D], N extends StringKey<D> = StringKey<D>> extends ShellApiWithMongoClass {\n  _mongo: Mongo<M>;\n  _database: Database<M, D>;\n  _name: N;\n  _typeLaunder(): Collection<M, D>;\n  constructor(mongo: Mongo<M>, database: Database<M, D>, name: N);\n  [namespaceInfo](): Namespace;\n  [asPrintable](): string;\n  private _emitCollectionApiCall;\n  aggregate(pipeline: Document_2[], options: AggregateOptions & {\n    explain: ExplainVerbosityLike;\n  }): Document_2;\n  aggregate(pipeline: Document_2[], options?: AggregateOptions): AggregationCursor;\n  aggregate(...stages: Document_2[]): AggregationCursor;\n  bulkWrite(operations: AnyBulkWriteOperation[], options?: BulkWriteOptions): BulkWriteResult;\n  count(query?: {}, options?: CountOptions): number;\n  countDocuments(query?: Document_2, options?: CountDocumentsOptions): number;\n  deleteMany(filter: Document_2, options?: DeleteOptions): DeleteResult | Document_2;\n  deleteOne(filter: Document_2, options?: DeleteOptions): DeleteResult | Document_2;\n  distinct(field: string): Document_2;\n  distinct(field: string, query: Document_2): Document_2;\n  distinct(field: string, query: Document_2, options: DistinctOptions): Document_2;\n  estimatedDocumentCount(options?: EstimatedDocumentCountOptions): number;\n  find(query?: Document_2, projection?: Document_2, options?: FindOptions): Cursor;\n  findAndModify(options: FindAndModifyMethodShellOptions): Document_2 | null;\n  findOne(query?: Document_2, projection?: Document_2, options?: FindOptions): C['schema'] | null;\n  renameCollection(newName: string, dropTarget?: boolean): Document_2;\n  findOneAndDelete(filter: Document_2, options?: FindOneAndDeleteOptions): Document_2 | null;\n  findOneAndReplace(filter: Document_2, replacement: Document_2, options?: FindAndModifyShellOptions<FindOneAndReplaceOptions>): Document_2;\n  findOneAndUpdate(filter: Document_2, update: Document_2 | Document_2[], options?: FindAndModifyShellOptions<FindOneAndUpdateOptions>): Document_2;\n  insert(docs: Document_2 | Document_2[], options?: BulkWriteOptions): InsertManyResult;\n  insertMany(docs: Document_2[], options?: BulkWriteOptions): InsertManyResult;\n  insertOne(doc: Document_2, options?: InsertOneOptions): InsertOneResult;\n  isCapped(): boolean;\n  remove(query: Document_2, options?: boolean | RemoveShellOptions): DeleteResult | Document_2;\n  replaceOne(filter: Document_2, replacement: Document_2, options?: ReplaceOptions): UpdateResult;\n  update(filter: Document_2, update: Document_2, options?: UpdateOptions & {\n    multi?: boolean;\n  }): UpdateResult | Document_2;\n  updateMany(filter: Document_2, update: Document_2, options?: UpdateOptions): UpdateResult | Document_2;\n  updateOne(filter: Document_2, update: Document_2, options?: UpdateOptions): UpdateResult | Document_2;\n  compactStructuredEncryptionData(): Document_2;\n  convertToCapped(size: number): Document_2;\n  _createIndexes(keyPatterns: Document_2[], options?: CreateIndexesOptions, commitQuorum?: number | string): Promise<string[]>;\n  createIndexes(keyPatterns: Document_2[], options?: CreateIndexesOptions, commitQuorum?: number | string): string[];\n  createIndex(keys: Document_2, options?: CreateIndexesOptions, commitQuorum?: number | string): string;\n  ensureIndex(keys: Document_2, options?: CreateIndexesOptions, commitQuorum?: number | string): Document_2;\n  getIndexes(): Document_2[];\n  getIndexSpecs(): Document_2[];\n  getIndices(): Document_2[];\n  getIndexKeys(): Document_2[];\n  dropIndexes(indexes?: string | string[] | Document_2 | Document_2[]): Document_2;\n  dropIndex(index: string | Document_2): Document_2;\n  _getSingleStorageStatValue(key: string): Promise<number>;\n  totalIndexSize(...args: any[]): number;\n  reIndex(): Document_2;\n  getDB(): Database<M, D>;\n  getMongo(): Mongo<M>;\n  dataSize(): number;\n  storageSize(): number;\n  totalSize(): number;\n  drop(options?: DropCollectionOptions): boolean;\n  exists(): Document_2;\n  getFullName(): string;\n  getName(): N;\n  runCommand(commandName: string | Document_2, options?: RunCommandOptions): Document_2;\n  explain(verbosity?: ExplainVerbosityLike): Explainable;\n  _getLegacyCollStats(scale: number): Promise<Document_2>;\n  _aggregateAndScaleCollStats(collStats: Document_2[], scale: number): Promise<Document_2>;\n  _getAggregatedCollStats(scale: number): Promise<Document_2>;\n  stats(originalOptions?: Document_2 | number): Document_2;\n  latencyStats(options?: Document_2): Document_2[];\n  initializeOrderedBulkOp(): Bulk;\n  initializeUnorderedBulkOp(): Bulk;\n  getPlanCache(): PlanCache;\n  mapReduce(map: Function | string, reduce: Function | string, optionsOrOutString: MapReduceShellOptions): Document_2;\n  validate(options?: boolean | Document_2): Document_2;\n  getShardVersion(): Document_2;\n  _getShardedCollectionInfo(config: Database, collStats: Document_2[]): Promise<Document_2>;\n  getShardDistribution(): CommandResult<GetShardDistributionResult>;\n  watch(pipeline?: Document_2[] | ChangeStreamOptions, options?: ChangeStreamOptions): ChangeStreamCursor;\n  hideIndex(index: string | Document_2): Document_2;\n  unhideIndex(index: string | Document_2): Document_2;\n  analyzeShardKey(key: Document_2, options?: Document_2): Document_2;\n  configureQueryAnalyzer(options: Document_2): Document_2;\n  checkMetadataConsistency(options?: CheckMetadataConsistencyOptions): RunCommandCursor;\n  getSearchIndexes(indexName?: string | Document_2, options?: Document_2): Document_2[];\n  createSearchIndex(name: string, definition: SearchIndexDefinition): string;\n  createSearchIndex(name: string, type: 'search' | 'vectorSearch', definition: SearchIndexDefinition): string;\n  createSearchIndex(definition: SearchIndexDefinition, type?: 'search' | 'vectorSearch'): string;\n  createSearchIndex(description: SearchIndexDescription): string;\n  createSearchIndexes(specs: SearchIndexDescription[]): string[];\n  dropSearchIndex(indexName: string): void;\n  updateSearchIndex(indexName: string, definition: Document_2): void;\n}\n\n/** @public */\ndeclare interface CollectionInfo extends Document_2 {\n  name: string;\n  type?: string;\n  options?: Document_2;\n  info?: {\n    readOnly?: false;\n    uuid?: Binary;\n  };\n  idIndex?: Document_2;\n}\nexport declare type CollectionNamesWithTypes = {\n  name: string;\n  badge: string;\n};\n\n/** @public */\ndeclare interface CollectionOptions extends BSONSerializeOptions, WriteConcernOptions {\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\n  readPreference?: ReadPreferenceLike;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n}\n\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\ndeclare class CommandFailedEvent {\n  address: string;\n  /** Driver generated connection id */\n  connectionId?: string | number;\n  /**\n   * Server generated connection id\n   * Distinct from the connection id and is returned by the hello or legacy hello response as \"connectionId\" from the server on 4.2+.\n   */\n  serverConnectionId: bigint | null;\n  requestId: number;\n  duration: number;\n  commandName: string;\n  failure: Error;\n  serviceId?: ObjectId;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n  get hasServiceId(): boolean;\n}\n\n/** @public */\ndeclare interface CommandOperationOptions extends OperationOptions, WriteConcernOptions, ExplainOptions {\n  /** Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** Collation */\n  collation?: CollationOptions;\n  /**\n   * maxTimeMS is a server-side time limit in milliseconds for processing an operation.\n   */\n  maxTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /** Should retry failed writes */\n  retryWrites?: boolean;\n  dbName?: string;\n  authdb?: string;\n  noResponse?: boolean;\n}\nexport declare class CommandResult<T = unknown> extends ShellApiValueClass {\n  value: T;\n  type: string;\n  constructor(type: string, value: T);\n  [asPrintable](): T;\n  toJSON(): T;\n}\n\n/**\n * An event indicating the start of a given command\n * @public\n * @category Event\n */\ndeclare class CommandStartedEvent {\n  commandObj?: Document_2;\n  requestId: number;\n  databaseName: string;\n  commandName: string;\n  command: Document_2;\n  address: string;\n  /** Driver generated connection id */\n  connectionId?: string | number;\n  /**\n   * Server generated connection id\n   * Distinct from the connection id and is returned by the hello or legacy hello response as \"connectionId\"\n   * from the server on 4.2+.\n   */\n  serverConnectionId: bigint | null;\n  serviceId?: ObjectId;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n  get hasServiceId(): boolean;\n}\n\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\ndeclare class CommandSucceededEvent {\n  address: string;\n  /** Driver generated connection id */\n  connectionId?: string | number;\n  /**\n   * Server generated connection id\n   * Distinct from the connection id and is returned by the hello or legacy hello response as \"connectionId\" from the server on 4.2+.\n   */\n  serverConnectionId: bigint | null;\n  requestId: number;\n  duration: number;\n  commandName: string;\n  reply: unknown;\n  serviceId?: ObjectId;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n  get hasServiceId(): boolean;\n}\n\n/** @public */\ndeclare type CommonEvents = 'newListener' | 'removeListener';\n\n/** @public */\ndeclare const Compressor: Readonly<{\n  readonly none: 0;\n  readonly snappy: 1;\n  readonly zlib: 2;\n  readonly zstd: 3;\n}>;\n\n/** @public */\ndeclare type Compressor = (typeof Compressor)[CompressorName];\n\n/** @public */\ndeclare type CompressorName = keyof typeof Compressor;\n\n/** @public */\ndeclare type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;\ndeclare interface ConfigProvider<T> {\n  getConfig<K extends keyof T>(key: K): Promise<T[K] | undefined> | T[K] | undefined;\n  setConfig<K extends keyof T>(key: K, value: T[K]): Promise<'success' | 'ignored'> | 'success' | 'ignored';\n  resetConfig<K extends keyof T>(key: K): Promise<'success' | 'ignored'> | 'success' | 'ignored';\n  validateConfig<K extends keyof T>(key: K, value: T[K]): Promise<string | null>;\n  listConfigOptions(): string[] | undefined | Promise<string[]>;\n}\ndeclare interface ConnectAttemptFinishedEvent {\n  cryptSharedLibVersionInfo?: {\n    version: bigint;\n    versionStr: string;\n  } | null;\n}\ndeclare interface ConnectAttemptInitializedEvent {\n  uri: string;\n  driver: {\n    name: string;\n    version: string;\n  };\n  devtoolsConnectVersion: string;\n  host: string;\n}\ndeclare interface ConnectDnsResolutionDetail {\n  query: 'TXT' | 'SRV';\n  hostname: string;\n  error?: string;\n  wasNativelyLookedUp?: boolean;\n  durationMs: number;\n}\ndeclare interface ConnectEvent {\n  is_atlas?: boolean;\n  resolved_hostname?: string;\n  is_localhost?: boolean;\n  is_do_url?: boolean;\n  server_version?: string;\n  server_os?: string;\n  server_arch?: string;\n  is_enterprise?: boolean;\n  auth_type?: string;\n  is_data_federation?: boolean;\n  is_stream?: boolean;\n  dl_version?: string;\n  atlas_version?: string;\n  is_genuine?: boolean;\n  non_genuine_server_name?: string;\n  api_version?: string;\n  api_strict?: boolean;\n  api_deprecation_errors?: boolean;\n  node_version?: string;\n  uri?: string;\n  is_local_atlas?: boolean;\n  is_atlas_url?: boolean;\n}\ndeclare type ConnectEventArgs<K extends keyof ConnectEventMap> = ConnectEventMap[K] extends ((...args: infer P) => any) ? P : never;\ndeclare interface ConnectEventMap extends MongoDBOIDCLogEventsMap, ProxyEventMap {\n  'devtools-connect:connect-attempt-initialized': (ev: ConnectAttemptInitializedEvent) => void;\n  'devtools-connect:connect-heartbeat-failure': (ev: ConnectHeartbeatFailureEvent) => void;\n  'devtools-connect:connect-heartbeat-succeeded': (ev: ConnectHeartbeatSucceededEvent) => void;\n  'devtools-connect:connect-fail-early': () => void;\n  'devtools-connect:connect-attempt-finished': (ev: ConnectAttemptFinishedEvent) => void;\n  'devtools-connect:resolve-srv-error': (ev: ConnectResolveSrvErrorEvent) => void;\n  'devtools-connect:resolve-srv-succeeded': (ev: ConnectResolveSrvSucceededEvent) => void;\n  'devtools-connect:missing-optional-dependency': (ev: ConnectMissingOptionalDependencyEvent) => void;\n  'devtools-connect:used-system-ca': (ev: ConnectUsedSystemCAEvent) => void;\n  'devtools-connect:retry-after-tls-error': (ev: ConnectRetryAfterTLSErrorEvent) => void;\n}\ndeclare interface ConnectHeartbeatFailureEvent {\n  connectionId: string;\n  failure: Error;\n  isFailFast: boolean;\n  isKnownServer: boolean;\n}\ndeclare interface ConnectHeartbeatSucceededEvent {\n  connectionId: string;\n}\n\n/**\n * An event published when a connection is checked into the connection pool\n * @public\n * @category Event\n */\ndeclare class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a connection is checked out of the connection pool\n * @public\n * @category Event\n */\ndeclare class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /* Excluded from this release type: name */\n  /**\n   * The time it took to check out the connection.\n   * More specifically, the time elapsed between\n   * emitting a `ConnectionCheckOutStartedEvent`\n   * and emitting this event as part of the same checking out.\n   *\n   */\n  durationMS: number;\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a request to check a connection out fails\n * @public\n * @category Event\n */\ndeclare class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {\n  /** The reason the attempt to check out failed */\n  reason: string;\n  /* Excluded from this release type: error */\n  /* Excluded from this release type: name */\n  /**\n   * The time it took to check out the connection.\n   * More specifically, the time elapsed between\n   * emitting a `ConnectionCheckOutStartedEvent`\n   * and emitting this event as part of the same check out.\n   */\n  durationMS: number;\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a request to check a connection out begins\n * @public\n * @category Event\n */\ndeclare class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a connection is closed\n * @public\n * @category Event\n */\ndeclare class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /** The reason the connection was closed */\n  reason: string;\n  serviceId?: ObjectId;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: error */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a connection pool creates a new connection\n * @public\n * @category Event\n */\ndeclare class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {\n  /** A monotonically increasing, per-pool id for the newly created connection */\n  connectionId: number | '<monitor>';\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document_2): void;\n  close(): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\ndeclare type ConnectionExtraInfo = {\n  is_atlas?: boolean;\n  server_version?: string;\n  server_os?: string;\n  server_arch?: string;\n  is_enterprise?: boolean;\n  auth_type?: string;\n  is_data_federation?: boolean;\n  is_stream?: boolean;\n  dl_version?: string;\n  atlas_version?: string;\n  is_genuine?: boolean;\n  non_genuine_server_name?: string;\n  node_version?: string;\n  uri: string;\n  is_local_atlas?: boolean;\n} & HostInformation;\ndeclare interface ConnectionInfo {\n  connectionString: string;\n  driverOptions: Omit<DevtoolsConnectOptions, 'productName' | 'productDocsLink'>;\n}\ndeclare interface ConnectionInfo_2 {\n  buildInfo: Document_2 | null;\n  resolvedHostname?: string;\n  extraInfo: (ConnectionExtraInfo & {\n    fcv?: string;\n  }) | null;\n}\n\n/** @public */\ndeclare interface ConnectionOptions_2 extends SupportedNodeConnectionOptions, StreamDescriptionOptions, ProxyOptions {\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  /* Excluded from this release type: autoEncrypter */\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /* Excluded from this release type: connectionType */\n  credentials?: MongoCredentials;\n  /* Excluded from this release type: authProviders */\n  connectTimeoutMS?: number;\n  tls: boolean;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n  metadata: ClientMetadata;\n  /* Excluded from this release type: extendedMetadata */\n  /* Excluded from this release type: mongoLogger */\n}\n\n/**\n * An event published when a connection pool is cleared\n * @public\n * @category Event\n */\ndeclare class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {\n  /* Excluded from this release type: serviceId */\n  interruptInUseConnections?: boolean;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a connection pool is closed\n * @public\n * @category Event\n */\ndeclare class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a connection pool is created\n * @public\n * @category Event\n */\ndeclare class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {\n  /** The options used to create this connection pool */\n  options: Pick<ConnectionPoolOptions, 'maxPoolSize' | 'minPoolSize' | 'maxConnecting' | 'maxIdleTimeMS' | 'waitQueueTimeoutMS'>;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare type ConnectionPoolEvents = {\n  connectionPoolCreated(event: ConnectionPoolCreatedEvent): void;\n  connectionPoolReady(event: ConnectionPoolReadyEvent): void;\n  connectionPoolClosed(event: ConnectionPoolClosedEvent): void;\n  connectionPoolCleared(event: ConnectionPoolClearedEvent): void;\n  connectionCreated(event: ConnectionCreatedEvent): void;\n  connectionReady(event: ConnectionReadyEvent): void;\n  connectionClosed(event: ConnectionClosedEvent): void;\n  connectionCheckOutStarted(event: ConnectionCheckOutStartedEvent): void;\n  connectionCheckOutFailed(event: ConnectionCheckOutFailedEvent): void;\n  connectionCheckedOut(event: ConnectionCheckedOutEvent): void;\n  connectionCheckedIn(event: ConnectionCheckedInEvent): void;\n} & Omit<ConnectionEvents, 'close' | 'message'>;\n\n/**\n * The base export class for all monitoring events published from the connection pool\n * @public\n * @category Event\n */\ndeclare abstract class ConnectionPoolMonitoringEvent {\n  /** A timestamp when the event was created  */\n  time: Date;\n  /** The address (host/port pair) of the pool */\n  address: string;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare interface ConnectionPoolOptions extends Omit<ConnectionOptions_2, 'id' | 'generation'> {\n  /** The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections. */\n  maxPoolSize: number;\n  /** The minimum number of connections that MUST exist at any moment in a single connection pool. */\n  minPoolSize: number;\n  /** The maximum number of connections that may be in the process of being established concurrently by the connection pool. */\n  maxConnecting: number;\n  /** The maximum amount of time a connection should remain idle in the connection pool before being marked idle. */\n  maxIdleTimeMS: number;\n  /** The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit. */\n  waitQueueTimeoutMS: number;\n  /** If we are in load balancer mode. */\n  loadBalanced: boolean;\n  /* Excluded from this release type: minPoolSizeCheckFrequencyMS */\n}\n\n/**\n * An event published when a connection pool is ready\n * @public\n * @category Event\n */\ndeclare class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An event published when a connection is ready for use\n * @public\n * @category Event\n */\ndeclare class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {\n  /** The id of the connection */\n  connectionId: number | '<monitor>';\n  /**\n   * The time it took to establish the connection.\n   * In accordance with the definition of establishment of a connection\n   * specified by `ConnectionPoolOptions.maxConnecting`,\n   * it is the time elapsed between emitting a `ConnectionCreatedEvent`\n   * and emitting this event as part of the same checking out.\n   *\n   * Naturally, when establishing a connection is part of checking out,\n   * this duration is not greater than\n   * `ConnectionCheckedOutEvent.duration`.\n   */\n  durationMS: number;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\ndeclare interface ConnectLogEmitter {\n  on<K extends keyof ConnectEventMap>(event: K, listener: ConnectEventMap[K]): this;\n  off?<K extends keyof ConnectEventMap>(event: K, listener: ConnectEventMap[K]): this;\n  once<K extends keyof ConnectEventMap>(event: K, listener: ConnectEventMap[K]): this;\n  emit<K extends keyof ConnectEventMap>(event: K, ...args: ConnectEventArgs<K>): unknown;\n}\ndeclare interface ConnectMissingOptionalDependencyEvent {\n  name: string;\n  error: Error;\n}\ndeclare interface ConnectResolveSrvErrorEvent {\n  from: string;\n  error: Error;\n  duringLoad: boolean;\n  resolutionDetails: ConnectDnsResolutionDetail[];\n  durationMs: number | null;\n}\ndeclare interface ConnectResolveSrvSucceededEvent {\n  from: string;\n  to: string;\n  resolutionDetails: ConnectDnsResolutionDetail[];\n  durationMs: number | null;\n}\ndeclare interface ConnectRetryAfterTLSErrorEvent {\n  error: string;\n}\ndeclare interface ConnectUsedSystemCAEvent {\n  caCount: number;\n  asyncFallbackError: Error | undefined;\n  systemCertsError: Error | undefined;\n  messages: string[];\n}\n\n/** @public */\ndeclare interface CountDocumentsOptions extends AggregateOptions {\n  /** The number of documents to skip. */\n  skip?: number;\n  /** The maximum amount of documents to consider. */\n  limit?: number;\n}\n\n/** @public */\ndeclare interface CountOptions extends CommandOperationOptions {\n  /** The number of documents to skip. */\n  skip?: number;\n  /** The maximum amounts to count before aborting. */\n  limit?: number;\n  /**\n   * Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS?: number;\n  /** An index name hint for the query. */\n  hint?: string | Document_2;\n}\n\n/** @public */\ndeclare interface CreateCollectionOptions extends CommandOperationOptions {\n  /** Create a capped collection */\n  capped?: boolean;\n  /** @deprecated Create an index on the _id field of the document. This option is deprecated in MongoDB 3.2+ and will be removed once no longer supported by the server. */\n  autoIndexId?: boolean;\n  /** The size of the capped collection in bytes */\n  size?: number;\n  /** The maximum number of documents in the capped collection */\n  max?: number;\n  /** Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag */\n  flags?: number;\n  /** Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection */\n  storageEngine?: Document_2;\n  /** Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation */\n  validator?: Document_2;\n  /** Determines how strictly MongoDB applies the validation rules to existing documents during an update */\n  validationLevel?: string;\n  /** Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted */\n  validationAction?: string;\n  /** Allows users to specify a default configuration for indexes when creating a collection */\n  indexOptionDefaults?: Document_2;\n  /** The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view (i.e., does not include the database name and implies the same database as the view to create) */\n  viewOn?: string;\n  /** An array that consists of the aggregation pipeline stage. Creates the view by applying the specified pipeline to the viewOn collection or view */\n  pipeline?: Document_2[];\n  /** A primary key factory function for generation of custom _id keys. */\n  pkFactory?: PkFactory;\n  /** A document specifying configuration options for timeseries collections. */\n  timeseries?: TimeSeriesCollectionOptions;\n  /** A document specifying configuration options for clustered collections. For MongoDB 5.3 and above. */\n  clusteredIndex?: ClusteredCollectionOptions;\n  /** The number of seconds after which a document in a timeseries or clustered collection expires. */\n  expireAfterSeconds?: number;\n  /** @experimental */\n  encryptedFields?: Document_2;\n  /**\n   * If set, enables pre-update and post-update document events to be included for any\n   * change streams that listen on this collection.\n   */\n  changeStreamPreAndPostImages?: {\n    enabled: boolean;\n  };\n}\ndeclare interface CreateEncryptedCollectionOptions {\n  provider: ClientEncryptionDataKeyProvider;\n  createCollectionOptions: Omit<CreateCollectionOptions, 'encryptedFields'> & {\n    encryptedFields: Document_2;\n  };\n  masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;\n}\n\n/** @public */\ndeclare interface CreateIndexesOptions extends Omit<CommandOperationOptions, 'writeConcern'> {\n  /** Creates the index in the background, yielding whenever possible. */\n  background?: boolean;\n  /** Creates an unique index. */\n  unique?: boolean;\n  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */\n  name?: string;\n  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */\n  partialFilterExpression?: Document_2;\n  /** Creates a sparse index. */\n  sparse?: boolean;\n  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */\n  expireAfterSeconds?: number;\n  /** Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher) */\n  storageEngine?: Document_2;\n  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes. */\n  commitQuorum?: number | string;\n  /** Specifies the index version number, either 0 or 1. */\n  version?: number;\n  weights?: Document_2;\n  default_language?: string;\n  language_override?: string;\n  textIndexVersion?: number;\n  '2dsphereIndexVersion'?: number;\n  bits?: number;\n  /** For geospatial indexes set the lower bound for the co-ordinates. */\n  min?: number;\n  /** For geospatial indexes set the high bound for the co-ordinates. */\n  max?: number;\n  bucketSize?: number;\n  wildcardProjection?: Document_2;\n  /** Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher) */\n  hidden?: boolean;\n}\ndeclare interface CryptLibraryFoundEvent {\n  cryptSharedLibPath: string;\n  expectedVersion: {\n    versionStr: string;\n  };\n}\ndeclare interface CryptLibrarySkipEvent {\n  cryptSharedLibPath: string;\n  reason: string;\n  details?: any;\n}\n\n/** @public */\ndeclare type CSFLEKMSTlsOptions = {\n  aws?: ClientEncryptionTlsOptions;\n  gcp?: ClientEncryptionTlsOptions;\n  kmip?: ClientEncryptionTlsOptions;\n  local?: ClientEncryptionTlsOptions;\n  azure?: ClientEncryptionTlsOptions;\n  [key: string]: ClientEncryptionTlsOptions | undefined;\n};\nexport declare class Cursor extends AggregateOrFindCursor<ServiceProviderFindCursor> {\n  _tailable: boolean;\n  constructor(mongo: Mongo, cursor: ServiceProviderFindCursor);\n  toJSON(): void;\n  private _addFlag;\n  addOption(optionFlagNumber: number): Cursor;\n  allowDiskUse(allow?: boolean): Cursor;\n  allowPartialResults(): Cursor;\n  collation(spec: CollationOptions): Cursor;\n  comment(cmt: string): Cursor;\n  count(): number;\n  // @ts-expect-error The type of this function is not compatible with the type of the function in the base class\n  hasNext(): boolean;\n  hint(index: string): Cursor;\n  limit(value: number): Cursor;\n  max(indexBounds: Document_2): Cursor;\n  maxAwaitTimeMS(value: number): Cursor;\n  min(indexBounds: Document_2): Cursor;\n  // @ts-expect-error The type of this function is not compatible with the type of the function in the base class\n  next(): Document_2 | null;\n  noCursorTimeout(): Cursor;\n  oplogReplay(): Cursor;\n  readPref(mode: ReadPreferenceLike, tagSet?: TagSet[], hedgeOptions?: HedgeOptions): Cursor;\n  returnKey(enabled: boolean): Cursor;\n  size(): number;\n  tailable(opts?: {\n    awaitData: boolean;\n  }): Cursor;\n  maxScan(): void;\n  showRecordId(): Cursor;\n  readConcern(level: ReadConcernLevel): Cursor;\n}\n\n/** @public */\ndeclare const CURSOR_FLAGS: readonly [\"tailable\", \"oplogReplay\", \"noCursorTimeout\", \"awaitData\", \"exhaust\", \"partial\"];\n\n/** @public */\ndeclare type CursorFlag = (typeof CURSOR_FLAGS)[number];\nexport declare class CursorIterationResult extends ShellApiValueClass {\n  cursorHasMore: boolean;\n  documents: Document_2[];\n  constructor();\n}\n\n/** @public */\ndeclare interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document_2): Document_2;\n}\n\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\ndeclare const CursorTimeoutMode: Readonly<{\n  readonly ITERATION: \"iteration\";\n  readonly LIFETIME: \"cursorLifetime\";\n}>;\n\n/**\n * @public\n * @experimental\n */\ndeclare type CursorTimeoutMode = (typeof CursorTimeoutMode)[keyof typeof CursorTimeoutMode];\nexport declare type Database<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema> = DatabaseImpl<M, D> & { [k in StringKey<D>]: Collection<M, D, D[k], k> };\ndeclare class DatabaseImpl<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema> extends ShellApiWithMongoClass {\n  _mongo: Mongo<M>;\n  _name: StringKey<M>;\n  _collections: Record<string, Collection<M, D>>;\n  _session: Session | undefined;\n  _cachedCollectionNames: StringKey<D>[];\n  _cachedHello: Document_2 | null;\n  _typeLaunder(): Database<M, D>;\n  constructor(mongo: Mongo<M>, name: StringKey<M>, session?: Session);\n  _baseOptions(): Promise<CommandOperationOptions>;\n  _maybeCachedHello(): Promise<Document_2>;\n  [asPrintable](): string;\n  private _emitDatabaseApiCall;\n  _runCommand(cmd: Document_2, options?: CommandOperationOptions): Promise<Document_2>;\n  _runReadCommand(cmd: Document_2, options?: CommandOperationOptions): Promise<Document_2>;\n  _runAdminCommand(cmd: Document_2, options?: CommandOperationOptions): Promise<Document_2>;\n  _runAdminReadCommand(cmd: Document_2, options?: CommandOperationOptions): Promise<Document_2>;\n  _runCursorCommand(cmd: Document_2, options?: CommandOperationOptions): Promise<RunCommandCursor>;\n  _runAdminCursorCommand(cmd: Document_2, options?: CommandOperationOptions): Promise<RunCommandCursor>;\n  _listCollections(filter: Document_2, options: ListCollectionsOptions): Promise<Document_2[]>;\n  _getCollectionNames(options?: ListCollectionsOptions): Promise<string[]>;\n  _getCollectionNamesWithTypes(options?: ListCollectionsOptions): Promise<CollectionNamesWithTypes[]>;\n  _getCollectionNamesForCompletion(): Promise<string[]>;\n  _getLastErrorObj(w?: number | string, wTimeout?: number, j?: boolean): Promise<Document_2>;\n  getMongo(): Mongo<M>;\n  getName(): StringKey<M>;\n  getCollectionNames(): StringKey<D>[];\n  getCollectionInfos(filter?: Document_2, options?: ListCollectionsOptions): Document_2[];\n  runCommand(cmd: string | Document_2, options?: RunCommandOptions): Document_2;\n  adminCommand(cmd: string | Document_2): Document_2;\n  aggregate(pipeline: Document_2[], options: AggregateOptions & {\n    explain: ExplainVerbosityLike;\n  }): Document_2;\n  aggregate(pipeline: Document_2[], options?: AggregateOptions): AggregationCursor;\n  aggregate(...stages: Document_2[]): AggregationCursor;\n  getSiblingDB<K extends StringKey<M>>(db: K): Database<M, M[K]>;\n  getCollection<K extends StringKey<D>>(coll: K): Collection<M, D, D[K], K>;\n  dropDatabase(writeConcern?: WriteConcern): Document_2;\n  createUser(user: Document_2, writeConcern?: WriteConcern): Document_2;\n  updateUser(username: string, userDoc: Document_2, writeConcern?: WriteConcern): Document_2;\n  changeUserPassword(username: string, password: string, writeConcern?: WriteConcern): Document_2;\n  logout(): Document_2;\n  dropUser(username: string, writeConcern?: WriteConcern): Document_2;\n  dropAllUsers(writeConcern?: WriteConcern): Document_2;\n  auth(...args: [AuthDoc] | [string, string] | [string]): {\n    ok: number;\n  };\n  grantRolesToUser(username: string, roles: any[], writeConcern?: WriteConcern): Document_2;\n  revokeRolesFromUser(username: string, roles: any[], writeConcern?: WriteConcern): Document_2;\n  getUser(username: string, options?: Document_2): Document_2 | null;\n  getUsers(options?: Document_2): Document_2;\n  createCollection(name: string, options?: CreateCollectionOptions): {\n    ok: number;\n  };\n  createEncryptedCollection(name: string, options: CreateEncryptedCollectionOptions): {\n    collection: Collection;\n    encryptedFields: Document_2;\n  };\n  createView(name: string, source: string, pipeline: Document_2[], options?: CreateCollectionOptions): {\n    ok: number;\n  };\n  createRole(role: Document_2, writeConcern?: WriteConcern): Document_2;\n  updateRole(rolename: string, roleDoc: Document_2, writeConcern?: WriteConcern): Document_2;\n  dropRole(rolename: string, writeConcern?: WriteConcern): Document_2;\n  dropAllRoles(writeConcern?: WriteConcern): Document_2;\n  grantRolesToRole(rolename: string, roles: any[], writeConcern?: WriteConcern): Document_2;\n  revokeRolesFromRole(rolename: string, roles: any[], writeConcern?: WriteConcern): Document_2;\n  grantPrivilegesToRole(rolename: string, privileges: any[], writeConcern?: WriteConcern): Document_2;\n  revokePrivilegesFromRole(rolename: string, privileges: any[], writeConcern?: WriteConcern): Document_2;\n  getRole(rolename: string, options?: Document_2): Document_2 | null;\n  getRoles(options?: Document_2): Document_2;\n  _getCurrentOperations(opts: Document_2 | boolean): Promise<Document_2[]>;\n  currentOp(opts?: Document_2 | boolean): Document_2;\n  killOp(opId: number | string): Document_2;\n  shutdownServer(opts?: Document_2): Document_2;\n  fsyncLock(): Document_2;\n  fsyncUnlock(): Document_2;\n  version(): string;\n  serverBits(): Document_2;\n  isMaster(): Document_2;\n  hello(): Document_2;\n  serverBuildInfo(): Document_2;\n  serverStatus(opts?: {}): Document_2;\n  stats(scaleOrOptions?: number | Document_2): Document_2;\n  hostInfo(): Document_2;\n  serverCmdLineOpts(): Document_2;\n  rotateCertificates(message?: string): Document_2;\n  printCollectionStats(scale?: number): Document_2;\n  getProfilingStatus(): Document_2;\n  setProfilingLevel(level: number, opts?: number | Document_2): Document_2;\n  setLogLevel(logLevel: number, component?: Document_2 | string): Document_2;\n  getLogComponents(): Document_2;\n  cloneDatabase(): void;\n  cloneCollection(): void;\n  copyDatabase(): void;\n  commandHelp(name: string): Document_2;\n  listCommands(): CommandResult;\n  getLastErrorObj(w?: number | string, wTimeout?: number, j?: boolean): Document_2;\n  getLastError(w?: number | string, wTimeout?: number): Document_2 | null;\n  printShardingStatus(verbose?: boolean): CommandResult;\n  printSecondaryReplicationInfo(): CommandResult;\n  getReplicationInfo(): Document_2;\n  printReplicationInfo(): CommandResult;\n  printSlaveReplicationInfo(): never;\n  setSecondaryOk(): void;\n  watch(pipeline?: Document_2[] | ChangeStreamOptions, options?: ChangeStreamOptions): ChangeStreamCursor;\n  sql(sqlString: string, options?: AggregateOptions): AggregationCursor;\n  checkMetadataConsistency(options?: CheckMetadataConsistencyOptions): RunCommandCursor;\n}\n\n/**\n * @public\n * The schema for a DataKey in the key vault collection.\n */\ndeclare interface DataKey {\n  _id: UUID;\n  version?: number;\n  keyAltNames?: string[];\n  keyMaterial: Binary;\n  creationDate: Date;\n  updateDate: Date;\n  status: number;\n  masterKey: Document_2;\n}\ndeclare type DataKeyEncryptionKeyOptions = {\n  masterKey?: MasterKey;\n  keyAltNames?: AltNames;\n  keyMaterial?: Buffer | Binary;\n};\n\n/**\n * The **Db** class is a class that represents a MongoDB Database.\n * @public\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * interface Pet {\n *   name: string;\n *   kind: 'dog' | 'cat' | 'fish';\n * }\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * const db = client.db();\n *\n * // Create a collection that validates our union\n * await db.createCollection<Pet>('pets', {\n *   validator: { $expr: { $in: ['$kind', ['dog', 'cat', 'fish']] } }\n * })\n * ```\n */\ndeclare class Db {\n  /* Excluded from this release type: s */\n  /* Excluded from this release type: client */\n  static SYSTEM_NAMESPACE_COLLECTION: string;\n  static SYSTEM_INDEX_COLLECTION: string;\n  static SYSTEM_PROFILE_COLLECTION: string;\n  static SYSTEM_USER_COLLECTION: string;\n  static SYSTEM_COMMAND_COLLECTION: string;\n  static SYSTEM_JS_COLLECTION: string;\n  /**\n   * Creates a new Db instance.\n   *\n   * Db name cannot contain a dot, the server may apply more restrictions when an operation is run.\n   *\n   * @param client - The MongoClient for the database.\n   * @param databaseName - The name of the database this instance represents.\n   * @param options - Optional settings for Db construction.\n   */\n  constructor(client: MongoClient, databaseName: string, options?: DbOptions);\n  get databaseName(): string;\n  get options(): DbOptions | undefined;\n  /**\n   * Check if a secondary can be used (because the read preference is *not* set to primary)\n   */\n  get secondaryOk(): boolean;\n  get readConcern(): ReadConcern | undefined;\n  /**\n   * The current readPreference of the Db. If not explicitly defined for\n   * this Db, will be inherited from the parent MongoClient\n   */\n  get readPreference(): ReadPreference;\n  get bsonOptions(): BSONSerializeOptions;\n  get writeConcern(): WriteConcern | undefined;\n  get namespace(): string;\n  get timeoutMS(): number | undefined;\n  /**\n   * Create a new collection on a server with the specified options. Use this to create capped collections.\n   * More information about command options available at https://www.mongodb.com/docs/manual/reference/command/create/\n   *\n   * Collection namespace validation is performed server-side.\n   *\n   * @param name - The name of the collection to create\n   * @param options - Optional settings for the command\n   */\n  createCollection<TSchema extends Document_2 = Document_2>(name: string, options?: CreateCollectionOptions): Promise<Collection_2<TSchema>>;\n  /**\n   * Execute a command\n   *\n   * @remarks\n   * This command does not inherit options from the MongoClient.\n   *\n   * The driver will ensure the following fields are attached to the command sent to the server:\n   * - `lsid` - sourced from an implicit session or options.session\n   * - `$readPreference` - defaults to primary or can be configured by options.readPreference\n   * - `$db` - sourced from the name of this database\n   *\n   * If the client has a serverApi setting:\n   * - `apiVersion`\n   * - `apiStrict`\n   * - `apiDeprecationErrors`\n   *\n   * When in a transaction:\n   * - `readConcern` - sourced from readConcern set on the TransactionOptions\n   * - `writeConcern` - sourced from writeConcern set on the TransactionOptions\n   *\n   * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.\n   *\n   * @param command - The command to run\n   * @param options - Optional settings for the command\n   */\n  command(command: Document_2, options?: RunCommandOptions & Abortable): Promise<Document_2>;\n  /**\n   * Execute an aggregation framework pipeline against the database.\n   *\n   * @param pipeline - An array of aggregation stages to be executed\n   * @param options - Optional settings for the command\n   */\n  aggregate<T extends Document_2 = Document_2>(pipeline?: Document_2[], options?: AggregateOptions): AggregationCursor_2<T>;\n  /** Return the Admin db instance */\n  admin(): Admin;\n  /**\n   * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.\n   *\n   * Collection namespace validation is performed server-side.\n   *\n   * @param name - the collection name we wish to access.\n   * @returns return the new Collection instance\n   */\n  collection<TSchema extends Document_2 = Document_2>(name: string, options?: CollectionOptions): Collection_2<TSchema>;\n  /**\n   * Get all the db statistics.\n   *\n   * @param options - Optional settings for the command\n   */\n  stats(options?: DbStatsOptions): Promise<Document_2>;\n  /**\n   * List all collections of this database with optional filter\n   *\n   * @param filter - Query to filter collections by\n   * @param options - Optional settings for the command\n   */\n  listCollections(filter: Document_2, options: Exclude<ListCollectionsOptions, 'nameOnly'> & {\n    nameOnly: true;\n  } & Abortable): ListCollectionsCursor<Pick<CollectionInfo, 'name' | 'type'>>;\n  listCollections(filter: Document_2, options: Exclude<ListCollectionsOptions, 'nameOnly'> & {\n    nameOnly: false;\n  } & Abortable): ListCollectionsCursor<CollectionInfo>;\n  listCollections<T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo = Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo>(filter?: Document_2, options?: ListCollectionsOptions & Abortable): ListCollectionsCursor<T>;\n  /**\n   * Rename a collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the MongoClient.\n   *\n   * @param fromCollection - Name of current collection to rename\n   * @param toCollection - New name of of the collection\n   * @param options - Optional settings for the command\n   */\n  renameCollection<TSchema extends Document_2 = Document_2>(fromCollection: string, toCollection: string, options?: RenameOptions): Promise<Collection_2<TSchema>>;\n  /**\n   * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param name - Name of collection to drop\n   * @param options - Optional settings for the command\n   */\n  dropCollection(name: string, options?: DropCollectionOptions): Promise<boolean>;\n  /**\n   * Drop a database, removing it permanently from the server.\n   *\n   * @param options - Optional settings for the command\n   */\n  dropDatabase(options?: DropDatabaseOptions): Promise<boolean>;\n  /**\n   * Fetch all collections for the current db.\n   *\n   * @param options - Optional settings for the command\n   */\n  collections(options?: ListCollectionsOptions): Promise<Collection_2[]>;\n  /**\n   * Creates an index on the db and collection.\n   *\n   * @param name - Name of the collection to create the index on.\n   * @param indexSpec - Specify the field to index, or an index specification\n   * @param options - Optional settings for the command\n   */\n  createIndex(name: string, indexSpec: IndexSpecification, options?: CreateIndexesOptions): Promise<string>;\n  /**\n   * Remove a user from a database\n   *\n   * @param username - The username to remove\n   * @param options - Optional settings for the command\n   */\n  removeUser(username: string, options?: RemoveUserOptions): Promise<boolean>;\n  /**\n   * Set the current profiling level of MongoDB\n   *\n   * @param level - The new profiling level (off, slow_only, all).\n   * @param options - Optional settings for the command\n   */\n  setProfilingLevel(level: ProfilingLevel, options?: SetProfilingLevelOptions): Promise<ProfilingLevel>;\n  /**\n   * Retrieve the current profiling Level for MongoDB\n   *\n   * @param options - Optional settings for the command\n   */\n  profilingLevel(options?: ProfilingLevelOptions): Promise<string>;\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param name - The name of the collection.\n   * @param options - Optional settings for the command\n   */\n  indexInformation(name: string, options: IndexInformationOptions & {\n    full: true;\n  }): Promise<IndexDescriptionInfo[]>;\n  indexInformation(name: string, options: IndexInformationOptions & {\n    full?: false;\n  }): Promise<IndexDescriptionCompact>;\n  indexInformation(name: string, options: IndexInformationOptions): Promise<IndexDescriptionCompact | IndexDescriptionInfo[]>;\n  indexInformation(name: string): Promise<IndexDescriptionCompact>;\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this database. Will ignore all\n   * changes to system collections.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to provide the schema that may be defined for all the collections within this database\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   *\n   * @remarks\n   * When `timeoutMS` is configured for a change stream, it will have different behaviour depending\n   * on whether the change stream is in iterator mode or emitter mode. In both cases, a change\n   * stream will time out if it does not receive a change event within `timeoutMS` of the last change\n   * event.\n   *\n   * Note that if a change stream is consistently timing out when watching a collection, database or\n   * client that is being changed, then this may be due to the server timing out before it can finish\n   * processing the existing oplog. To address this, restart the change stream with a higher\n   * `timeoutMS`.\n   *\n   * If the change stream times out the initial aggregate operation to establish the change stream on\n   * the server, then the client will close the change stream. If the getMore calls to the server\n   * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError\n   * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in\n   * emitter mode.\n   *\n   * To determine whether or not the change stream is still open following a timeout, check the\n   * {@link ChangeStream.closed} getter.\n   *\n   * @example\n   * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.\n   * The next call can just be retried after this succeeds.\n   * ```ts\n   * const changeStream = collection.watch([], { timeoutMS: 100 });\n   * try {\n   *     await changeStream.next();\n   * } catch (e) {\n   *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {\n   *       await changeStream.next();\n   *     }\n   *     throw e;\n   * }\n   * ```\n   *\n   * @example\n   * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will\n   * emit an error event that returns a MongoOperationTimeoutError, but will not close the change\n   * stream unless the resume attempt fails. There is no need to re-establish change listeners as\n   * this will automatically continue emitting change events once the resume attempt completes.\n   *\n   * ```ts\n   * const changeStream = collection.watch([], { timeoutMS: 100 });\n   * changeStream.on('change', console.log);\n   * changeStream.on('error', e => {\n   *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {\n   *         // do nothing\n   *     } else {\n   *         changeStream.close();\n   *     }\n   * });\n   * ```\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TSchema - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch<TSchema extends Document_2 = Document_2, TChange extends Document_2 = ChangeStreamDocument<TSchema>>(pipeline?: Document_2[], options?: ChangeStreamOptions): ChangeStream<TSchema, TChange>;\n  /**\n   * A low level cursor API providing basic driver functionality:\n   * - ClientSession management\n   * - ReadPreference for server selection\n   * - Running getMores automatically when a local batch is exhausted\n   *\n   * @param command - The command that will start a cursor on the server.\n   * @param options - Configurations for running the command, bson options will apply to getMores\n   */\n  runCursorCommand(command: Document_2, options?: RunCursorCommandOptions): RunCommandCursor_2;\n}\n\n/** @public */\ndeclare interface DbOptions extends BSONSerializeOptions, WriteConcernOptions {\n  /** If the database authentication is dependent on another databaseName. */\n  authSource?: string;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\n  readPreference?: ReadPreferenceLike;\n  /** A primary key factory object for generation of custom _id keys. */\n  pkFactory?: PkFactory;\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcern;\n  /** Should retry failed writes */\n  retryWrites?: boolean;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n}\ndeclare class DBQuery extends ShellApiClass {\n  _instanceState: ShellInstanceState;\n  constructor(instanceState: ShellInstanceState);\n  get shellBatchSize(): number | undefined;\n  set shellBatchSize(value: number | undefined);\n}\n\n/**\n * A class representation of the BSON DBRef type.\n * @public\n * @category BSONType\n */\ndeclare class DBRef extends BSONValue {\n  get _bsontype(): 'DBRef';\n  collection: string;\n  oid: ObjectId;\n  db?: string;\n  fields: Document_2;\n  /**\n   * @param collection - the collection name.\n   * @param oid - the reference ObjectId.\n   * @param db - optional db name, if omitted the reference is local to the current db.\n   */\n  constructor(collection: string, oid: ObjectId, db?: string, fields?: Document_2);\n  /* Excluded from this release type: namespace */\n  /* Excluded from this release type: namespace */\n  toJSON(): DBRefLike & Document_2;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface DBRefLike {\n  $ref: string;\n  $id: ObjectId;\n  $db?: string;\n}\n\n/** @public */\ndeclare interface DbStatsOptions extends CommandOperationOptions {\n  /** Divide the returned sizes by scale value. */\n  scale?: number;\n}\n\n/**\n * A class representation of the BSON Decimal128 type.\n * @public\n * @category BSONType\n */\ndeclare class Decimal128 extends BSONValue {\n  get _bsontype(): 'Decimal128';\n  readonly bytes: Uint8Array;\n  /**\n   * @param bytes - a buffer containing the raw Decimal128 bytes in little endian order,\n   *                or a string representation as returned by .toString()\n   */\n  constructor(bytes: Uint8Array | string);\n  /**\n   * Create a Decimal128 instance from a string representation\n   *\n   * @param representation - a numeric string representation.\n   */\n  static fromString(representation: string): Decimal128;\n  /**\n   * Create a Decimal128 instance from a string representation, allowing for rounding to 34\n   * significant digits\n   *\n   * @example Example of a number that will be rounded\n   * ```ts\n   * > let d = Decimal128.fromString('37.499999999999999196428571428571375')\n   * Uncaught:\n   * BSONError: \"37.499999999999999196428571428571375\" is not a valid Decimal128 string - inexact rounding\n   * at invalidErr (/home/wajames/js-bson/lib/bson.cjs:1402:11)\n   * at Decimal128.fromStringInternal (/home/wajames/js-bson/lib/bson.cjs:1633:25)\n   * at Decimal128.fromString (/home/wajames/js-bson/lib/bson.cjs:1424:27)\n   *\n   * > d = Decimal128.fromStringWithRounding('37.499999999999999196428571428571375')\n   * new Decimal128(\"37.49999999999999919642857142857138\")\n   * ```\n   * @param representation - a numeric string representation.\n   */\n  static fromStringWithRounding(representation: string): Decimal128;\n  private static _fromString;\n  /** Create a string representation of the raw Decimal128 value */\n  toString(): string;\n  toJSON(): Decimal128Extended;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface Decimal128Extended {\n  $numberDecimal: string;\n}\n\n/** @public */\ndeclare interface DeleteManyModel<TSchema extends Document_2 = Document_2> {\n  /** The filter to limit the deleted documents. */\n  filter: Filter<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n}\n\n/** @public */\ndeclare interface DeleteOneModel<TSchema extends Document_2 = Document_2> {\n  /** The filter to limit the deleted documents. */\n  filter: Filter<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n}\n\n/** @public */\ndeclare interface DeleteOptions extends CommandOperationOptions, WriteConcernOptions {\n  /** If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails. */\n  ordered?: boolean;\n  /** Specifies the collation to use for the operation */\n  collation?: CollationOptions;\n  /** Specify that the update query should only consider plans using the hinted index */\n  hint?: string | Document_2;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n}\nexport declare class DeleteResult extends ShellApiValueClass {\n  acknowledged: boolean;\n  deletedCount: number | undefined;\n  constructor(acknowledged: boolean, deletedCount: number | undefined);\n}\n\n/** @public */\ndeclare interface DeleteResult_2 {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined. */\n  acknowledged: boolean;\n  /** The number of documents that were deleted */\n  deletedCount: number;\n}\n\n/** @public */\ndeclare interface DeleteStatement {\n  /** The query that matches documents to delete. */\n  q: Document_2;\n  /** The number of matching documents to delete. */\n  limit: number;\n  /** Specifies the collation to use for the operation. */\n  collation?: CollationOptions;\n  /** A document or string that specifies the index to use to support the query predicate. */\n  hint?: Hint;\n}\n\n/** @public */\ndeclare interface DeserializeOptions {\n  /**\n   * when deserializing a Long return as a BigInt.\n   * @defaultValue `false`\n   */\n  useBigInt64?: boolean;\n  /**\n   * when deserializing a Long will fit it into a Number if it's smaller than 53 bits.\n   * @defaultValue `true`\n   */\n  promoteLongs?: boolean;\n  /**\n   * when deserializing a Binary will return it as a node.js Buffer instance.\n   * @defaultValue `false`\n   */\n  promoteBuffers?: boolean;\n  /**\n   * when deserializing will promote BSON values to their Node.js closest equivalent types.\n   * @defaultValue `true`\n   */\n  promoteValues?: boolean;\n  /**\n   * allow to specify if there what fields we wish to return as unserialized raw buffer.\n   * @defaultValue `null`\n   */\n  fieldsAsRaw?: Document_2;\n  /**\n   * return BSON regular expressions as BSONRegExp instances.\n   * @defaultValue `false`\n   */\n  bsonRegExp?: boolean;\n  /**\n   * allows the buffer to be larger than the parsed BSON object.\n   * @defaultValue `false`\n   */\n  allowObjectSmallerThanBufferSize?: boolean;\n  /**\n   * Offset into buffer to begin reading document from\n   * @defaultValue `0`\n   */\n  index?: number;\n  raw?: boolean;\n  /** Allows for opt-out utf-8 validation for all keys or\n   * specified keys. Must be all true or all false.\n   *\n   * @example\n   * ```js\n   * // disables validation on all keys\n   *  validation: { utf8: false }\n   *\n   * // enables validation only on specified keys a, b, and c\n   *  validation: { utf8: { a: true, b: true, c: true } }\n   *\n   *  // disables validation only on specified keys a, b\n   *  validation: { utf8: { a: false, b: false } }\n   * ```\n   */\n  validation?: {\n    utf8: boolean | Record<string, true> | Record<string, false>;\n  };\n}\n\n/**\n * Information that the application needs to show to users when using the\n * Device Authorization flow.\n *\n * @public\n */\ndeclare interface DeviceFlowInformation {\n  verificationUrl: string;\n  userCode: string;\n}\ndeclare class DevtoolsConnectionState {\n  oidcPlugin: MongoDBOIDCPlugin;\n  productName: string;\n  private stateShareClient;\n  private stateShareServer;\n  constructor(options: Pick<DevtoolsConnectOptions, 'productDocsLink' | 'productName' | 'oidc' | 'parentHandle'>, logger: ConnectLogEmitter, ca: string | undefined);\n  getStateShareServer(): Promise<string>;\n  destroy(): Promise<void>;\n}\ndeclare interface DevtoolsConnectOptions extends MongoClientOptions {\n  productDocsLink: string;\n  productName: string;\n  oidc?: Omit<MongoDBOIDCPluginOptions, 'logger' | 'redirectServerRequestHandler'>;\n  parentState?: DevtoolsConnectionState;\n  parentHandle?: string;\n  proxy?: DevtoolsProxyOptions | AgentWithInitialize;\n  applyProxyToOIDC?: boolean;\n}\ndeclare interface DevtoolsProxyOptions {\n  proxy?: string;\n  noProxyHosts?: string;\n  useEnvironmentVariableProxies?: boolean;\n  sshOptions?: {\n    identityKeyFile?: string;\n    identityKeyPassphrase?: string;\n  };\n  ca?: ConnectionOptions['ca'];\n  env?: Record<string, string | undefined>;\n}\n\n/** @public */\ndeclare type DistinctOptions = CommandOperationOptions;\n\n/** @public */\ndeclare interface Document_2 {\n  [key: string]: any;\n}\n\n/**\n * A class representation of the BSON Double type.\n * @public\n * @category BSONType\n */\ndeclare class Double extends BSONValue {\n  get _bsontype(): 'Double';\n  value: number;\n  /**\n   * Create a Double type\n   *\n   * @param value - the number we want to represent as a double.\n   */\n  constructor(value: number);\n  /**\n   * Attempt to create an double type from string.\n   *\n   * This method will throw a BSONError on any string input that is not representable as a IEEE-754 64-bit double.\n   * Notably, this method will also throw on the following string formats:\n   * - Strings in non-decimal and non-exponential formats (binary, hex, or octal digits)\n   * - Strings with characters other than numeric, floating point, or leading sign characters (Note: 'Infinity', '-Infinity', and 'NaN' input strings are still allowed)\n   * - Strings with leading and/or trailing whitespace\n   *\n   * Strings with leading zeros, however, are also allowed\n   *\n   * @param value - the string we want to represent as a double.\n   */\n  static fromString(value: string): Double;\n  /**\n   * Access the number value.\n   *\n   * @returns returns the wrapped double number.\n   */\n  valueOf(): number;\n  toJSON(): number;\n  toString(radix?: number): string;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface DriverInfo {\n  name?: string;\n  version?: string;\n  platform?: string;\n}\n\n/** @public */\ndeclare interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document_2;\n}\n\n/** @public */\ndeclare type DropDatabaseOptions = CommandOperationOptions;\n\n/** @public */\ndeclare type DropIndexesOptions = CommandOperationOptions;\ndeclare interface EditorReadVscodeExtensionsDoneEvent {\n  vscodeDir: string;\n  hasMongodbExtension: boolean;\n}\ndeclare interface EditorReadVscodeExtensionsFailedEvent {\n  vscodeDir: string;\n  error: Error;\n}\ndeclare interface EditorRunEditCommandEvent {\n  tmpDoc: string;\n  editor: string;\n  code: string;\n}\n\n/** @public */\ndeclare type EJSONOptions = {\n  /**\n   * Output using the Extended JSON v1 spec\n   * @defaultValue `false`\n   */\n  legacy?: boolean;\n  /**\n   * Enable Extended JSON's `relaxed` mode, which attempts to return native JS types where possible, rather than BSON types\n   * @defaultValue `false` */\n  relaxed?: boolean;\n  /**\n   * Enable native bigint support\n   * @defaultValue `false`\n   */\n  useBigInt64?: boolean;\n};\n\n/** @public */\ndeclare interface EndSessionOptions {\n  /* Excluded from this release type: error */\n  force?: boolean;\n  forceClear?: boolean;\n  /** Specifies the time an operation will run until it throws a timeout error */\n  timeoutMS?: number;\n}\n\n/** TypeScript Omit (Exclude to be specific) does not work for objects with an \"any\" indexed type, and breaks discriminated unions @public */\ndeclare type EnhancedOmit<TRecordOrUnion, KeyUnion> = string extends keyof TRecordOrUnion ? TRecordOrUnion : TRecordOrUnion extends any ? Pick<TRecordOrUnion, Exclude<keyof TRecordOrUnion, KeyUnion>> : never;\n\n/** @public */\ndeclare interface EstimatedDocumentCountOptions extends CommandOperationOptions {\n  /**\n   * The maximum amount of time to allow the operation to run.\n   *\n   * This option is sent only if the caller explicitly provides a value. The default is to not send a value.\n   */\n  maxTimeMS?: number;\n}\ndeclare interface EvaluateInputEvent {\n  input: string;\n}\nexport declare interface EvaluationListener extends Partial<ConfigProvider<ShellUserConfig>> {\n  onPrint?: (value: ShellResult[], type: 'print' | 'printjson') => Promise<void> | void;\n  onPrompt?: (question: string, type: 'password' | 'yesno') => Promise<string> | string;\n  onClearCommand?: () => Promise<void> | void;\n  onExit?: (exitCode?: number) => Promise<never>;\n  onLoad?: (filename: string) => Promise<OnLoadResult> | OnLoadResult;\n  getCryptLibraryOptions?: () => Promise<AutoEncryptionOptions['extraOptions']>;\n  getLogPath?: () => string | undefined;\n}\n\n/** @public */\ndeclare type EventEmitterWithState = {\n  /* Excluded from this release type: stateChanged */\n};\n\n/**\n * Event description type\n * @public\n */\ndeclare type EventsDescription = Record<string, GenericListener>;\nexport declare class Explainable extends ShellApiWithMongoClass {\n  _mongo: Mongo;\n  _collection: Collection;\n  _verbosity: ExplainVerbosityLike;\n  constructor(mongo: Mongo, collection: Collection, verbosity: ExplainVerbosityLike);\n  [asPrintable](): string;\n  private _emitExplainableApiCall;\n  getCollection(): Collection;\n  getVerbosity(): ExplainVerbosityLike;\n  setVerbosity(verbosity: ExplainVerbosityLike): void;\n  find(query?: Document_2, projection?: Document_2, options?: FindOptions): ExplainableCursor;\n  aggregate(pipeline: Document_2[], options: Document_2): Document_2;\n  aggregate(...stages: Document_2[]): Document_2;\n  count(query?: {}, options?: CountOptions): Document_2;\n  distinct(field: string): Document_2;\n  distinct(field: string, query: Document_2): Document_2;\n  distinct(field: string, query: Document_2, options: DistinctOptions): Document_2;\n  findAndModify(options: FindAndModifyMethodShellOptions): Document_2 | null;\n  findOneAndDelete(filter: Document_2, options?: FindOneAndDeleteOptions): Document_2 | null;\n  findOneAndReplace(filter: Document_2, replacement: Document_2, options?: FindAndModifyShellOptions<FindOneAndReplaceOptions>): Document_2;\n  findOneAndUpdate(filter: Document_2, update: Document_2, options?: FindAndModifyShellOptions<FindOneAndUpdateOptions>): Document_2;\n  remove(query: Document_2, options?: boolean | RemoveShellOptions): Document_2;\n  update(filter: Document_2, update: Document_2, options?: UpdateOptions): Document_2;\n  mapReduce(map: Function | string, reduce: Function | string, optionsOrOutString: MapReduceShellOptions): Document_2;\n}\nexport declare class ExplainableCursor extends Cursor {\n  _baseCursor: Cursor;\n  _verbosity: ExplainVerbosityLike;\n  _explained: any;\n  constructor(mongo: Mongo, cursor: Cursor, verbosity: ExplainVerbosityLike);\n  [asPrintable](): Promise<any>;\n}\n\n/**\n * @public\n *\n * A base class for any cursors that have `explain()` methods.\n */\ndeclare abstract class ExplainableCursor_2<TSchema> extends AbstractCursor<TSchema> {\n  /** Execute the explain for the cursor */\n  abstract explain(): Promise<Document_2>;\n  abstract explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document_2>;\n  abstract explain(options: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  abstract explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions, options: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  abstract explain(verbosity?: ExplainVerbosityLike | ExplainCommandOptions | {\n    timeoutMS?: number;\n  }, options?: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  protected resolveExplainTimeoutOptions(verbosity?: ExplainVerbosityLike | ExplainCommandOptions | {\n    timeoutMS?: number;\n  }, options?: {\n    timeoutMS?: number;\n  }): {\n    timeout?: {\n      timeoutMS?: number;\n    };\n    explain?: ExplainVerbosityLike | ExplainCommandOptions;\n  };\n}\n\n/** @public */\ndeclare interface ExplainCommandOptions {\n  /** The explain verbosity for the command. */\n  verbosity: ExplainVerbosity;\n  /** The maxTimeMS setting for the command. */\n  maxTimeMS?: number;\n}\n\n/**\n * @public\n *\n * When set, this configures an explain command.  Valid values are boolean (for legacy compatibility,\n * see {@link ExplainVerbosityLike}), a string containing the explain verbosity, or an object containing the verbosity and\n * an optional maxTimeMS.\n *\n * Examples of valid usage:\n *\n * ```typescript\n * collection.find({ name: 'john doe' }, { explain: true });\n * collection.find({ name: 'john doe' }, { explain: false });\n * collection.find({ name: 'john doe' }, { explain: 'queryPlanner' });\n * collection.find({ name: 'john doe' }, { explain: { verbosity: 'queryPlanner' } });\n * ```\n *\n * maxTimeMS can be configured to limit the amount of time the server\n * spends executing an explain by providing an object:\n *\n * ```typescript\n * // limits the `explain` command to no more than 2 seconds\n * collection.find({ name: 'john doe' }, {\n *   explain:  {\n *    verbosity: 'queryPlanner',\n *    maxTimeMS: 2000\n *  }\n * });\n * ```\n */\ndeclare interface ExplainOptions {\n  /** Specifies the verbosity mode for the explain output. */\n  explain?: ExplainVerbosityLike | ExplainCommandOptions;\n}\n\n/** @public */\ndeclare const ExplainVerbosity: Readonly<{\n  readonly queryPlanner: \"queryPlanner\";\n  readonly queryPlannerExtended: \"queryPlannerExtended\";\n  readonly executionStats: \"executionStats\";\n  readonly allPlansExecution: \"allPlansExecution\";\n}>;\n\n/** @public */\ndeclare type ExplainVerbosity = string;\n\n/**\n * For backwards compatibility, true is interpreted as \"allPlansExecution\"\n * and false as \"queryPlanner\".\n * @public\n */\ndeclare type ExplainVerbosityLike = ExplainVerbosity | boolean;\ndeclare interface FetchingUpdateMetadataCompleteEvent {\n  latest: string | null;\n  currentVersion: string;\n  hasGreetingCTA: boolean;\n}\ndeclare interface FetchingUpdateMetadataEvent {\n  updateURL: string;\n  localFilePath: string;\n  currentVersion: string;\n}\n\n/** A MongoDB filter can be some portion of the schema or a set of operators @public */\ndeclare type Filter<TSchema> = { [P in keyof WithId<TSchema>]?: Condition<WithId<TSchema>[P]> } & RootFilterOperators<WithId<TSchema>>;\n\n/** @public */\ndeclare type FilterOperations<T> = T extends Record<string, any> ? { [key in keyof T]?: FilterOperators<T[key]> } : FilterOperators<T>;\n\n/** @public */\ndeclare interface FilterOperators<TValue> extends NonObjectIdLikeDocument {\n  $eq?: TValue;\n  $gt?: TValue;\n  $gte?: TValue;\n  $in?: ReadonlyArray<TValue>;\n  $lt?: TValue;\n  $lte?: TValue;\n  $ne?: TValue;\n  $nin?: ReadonlyArray<TValue>;\n  $not?: TValue extends string ? FilterOperators<TValue> | RegExp : FilterOperators<TValue>;\n  /**\n   * When `true`, `$exists` matches the documents that contain the field,\n   * including documents where the field value is null.\n   */\n  $exists?: boolean;\n  $type?: BSONType | BSONTypeAlias;\n  $expr?: Record<string, any>;\n  $jsonSchema?: Record<string, any>;\n  $mod?: TValue extends number ? [number, number] : never;\n  $regex?: TValue extends string ? RegExp | BSONRegExp | string : never;\n  $options?: TValue extends string ? string : never;\n  $geoIntersects?: {\n    $geometry: Document_2;\n  };\n  $geoWithin?: Document_2;\n  $near?: Document_2;\n  $nearSphere?: Document_2;\n  $maxDistance?: number;\n  $all?: ReadonlyArray<any>;\n  $elemMatch?: Document_2;\n  $size?: TValue extends ReadonlyArray<any> ? number : never;\n  $bitsAllClear?: BitwiseFilter;\n  $bitsAllSet?: BitwiseFilter;\n  $bitsAnyClear?: BitwiseFilter;\n  $bitsAnySet?: BitwiseFilter;\n  $rand?: Record<string, never>;\n}\nexport declare type FindAndModifyMethodShellOptions = {\n  query: Document_2;\n  sort?: (FindOneAndDeleteOptions | FindOneAndReplaceOptions | FindOneAndUpdateOptions)['sort'];\n  update?: Document_2 | Document_2[];\n  remove?: boolean;\n  new?: boolean;\n  fields?: Document_2;\n  projection?: Document_2;\n  upsert?: boolean;\n  bypassDocumentValidation?: boolean;\n  writeConcern?: Document_2;\n  collation?: (FindOneAndDeleteOptions | FindOneAndReplaceOptions | FindOneAndUpdateOptions)['collation'];\n  arrayFilters?: Document_2[];\n  explain?: ExplainVerbosityLike;\n};\nexport declare type FindAndModifyShellOptions<BaseOptions extends FindOneAndReplaceOptions | FindOneAndUpdateOptions> = BaseOptions & {\n  returnOriginal?: boolean;\n  returnNewDocument?: boolean;\n  new?: boolean;\n};\n\n/** @public */\ndeclare class FindCursor<TSchema = any> extends ExplainableCursor_2<TSchema> {\n  /* Excluded from this release type: cursorFilter */\n  /* Excluded from this release type: numReturned */\n  /* Excluded from this release type: findOptions */\n  /* Excluded from this release type: __constructor */\n  clone(): FindCursor<TSchema>;\n  map<T>(transform: (doc: TSchema) => T): FindCursor<T>;\n  /* Excluded from this release type: _initialize */\n  /* Excluded from this release type: getMore */\n  /**\n   * Get the count of documents for this cursor\n   * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead\n   */\n  count(options?: CountOptions): Promise<number>;\n  /** Execute the explain for the cursor */\n  explain(): Promise<Document_2>;\n  explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document_2>;\n  explain(options: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions, options: {\n    timeoutMS?: number;\n  }): Promise<Document_2>;\n  /** Set the cursor query */\n  filter(filter: Document_2): this;\n  /**\n   * Set the cursor hint\n   *\n   * @param hint - If specified, then the query system will only consider plans using the hinted index.\n   */\n  hint(hint: Hint): this;\n  /**\n   * Set the cursor min\n   *\n   * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.\n   */\n  min(min: Document_2): this;\n  /**\n   * Set the cursor max\n   *\n   * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.\n   */\n  max(max: Document_2): this;\n  /**\n   * Set the cursor returnKey.\n   * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.\n   * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.\n   *\n   * @param value - the returnKey value.\n   */\n  returnKey(value: boolean): this;\n  /**\n   * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.\n   *\n   * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.\n   */\n  showRecordId(value: boolean): this;\n  /**\n   * Add a query modifier to the cursor query\n   *\n   * @param name - The query modifier (must start with $, such as $orderby etc)\n   * @param value - The modifier value.\n   */\n  addQueryModifier(name: string, value: string | boolean | number | Document_2): this;\n  /**\n   * Add a comment to the cursor query allowing for tracking the comment in the log.\n   *\n   * @param value - The comment attached to this query.\n   */\n  comment(value: string): this;\n  /**\n   * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)\n   *\n   * @param value - Number of milliseconds to wait before aborting the tailed query.\n   */\n  maxAwaitTimeMS(value: number): this;\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this;\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic\n   * {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<{ a: number; b: string }> = coll.find();\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.find().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n  project<T extends Document_2 = Document_2>(value: Document_2): FindCursor<T>;\n  /**\n   * Sets the sort order of the cursor query.\n   *\n   * @param sort - The key or keys set for the sort.\n   * @param direction - The direction of the sorting (1 or -1).\n   */\n  sort(sort: Sort | string, direction?: SortDirection): this;\n  /**\n   * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)\n   *\n   * @remarks\n   * {@link https://www.mongodb.com/docs/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}\n   */\n  allowDiskUse(allow?: boolean): this;\n  /**\n   * Set the collation options for the cursor.\n   *\n   * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n   */\n  collation(value: CollationOptions): this;\n  /**\n   * Set the limit for the cursor.\n   *\n   * @param value - The limit for the cursor query.\n   */\n  limit(value: number): this;\n  /**\n   * Set the skip for the cursor.\n   *\n   * @param value - The skip for the cursor query.\n   */\n  skip(value: number): this;\n}\n\n/** @public */\ndeclare interface FindOneAndDeleteOptions extends CommandOperationOptions {\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document_2;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document_2;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @public */\ndeclare interface FindOneAndReplaceOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document_2;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document_2;\n  /** When set to 'after', returns the updated document rather than the original. The default is 'before'.  */\n  returnDocument?: ReturnDocument;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Upsert the document if it does not exist. */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @public */\ndeclare interface FindOneAndUpdateOptions extends CommandOperationOptions {\n  /** Optional list of array filters referenced in filtered positional operators */\n  arrayFilters?: Document_2[];\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document_2;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document_2;\n  /** When set to 'after', returns the updated document rather than the original. The default is 'before'.  */\n  returnDocument?: ReturnDocument;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Upsert the document if it does not exist. */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/**\n * A builder object that is returned from {@link BulkOperationBase#find}.\n * Is used to build a write operation that involves a query filter.\n *\n * @public\n */\ndeclare class FindOperators {\n  bulkOperation: BulkOperationBase;\n  /* Excluded from this release type: __constructor */\n  /** Add a multiple update operation to the bulk operation */\n  update(updateDocument: Document_2 | Document_2[]): BulkOperationBase;\n  /** Add a single update operation to the bulk operation */\n  updateOne(updateDocument: Document_2 | Document_2[]): BulkOperationBase;\n  /** Add a replace one operation to the bulk operation */\n  replaceOne(replacement: Document_2): BulkOperationBase;\n  /** Add a delete one operation to the bulk operation */\n  deleteOne(): BulkOperationBase;\n  /** Add a delete many operation to the bulk operation */\n  delete(): BulkOperationBase;\n  /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */\n  upsert(): this;\n  /** Specifies the collation for the query condition. */\n  collation(collation: CollationOptions): this;\n  /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */\n  arrayFilters(arrayFilters: Document_2[]): this;\n  /** Specifies hint for the bulk operation. */\n  hint(hint: Hint): this;\n}\n\n/**\n * @public\n * @typeParam TSchema - Unused schema definition, deprecated usage, only specify `FindOptions` with no generic\n */\ndeclare interface FindOptions<TSchema extends Document_2 = Document_2> extends Omit<CommandOperationOptions, 'writeConcern' | 'explain'>, AbstractCursorOptions {\n  /** Sets the limit of documents returned in the query. */\n  limit?: number;\n  /** Set to sort the documents coming back from the query. Array of indexes, `[['a', 1]]` etc. */\n  sort?: Sort;\n  /** The fields to return in the query. Object of fields to either include or exclude (one of, not both), `{'a':1, 'b': 1}` **or** `{'a': 0, 'b': 0}` */\n  projection?: Document_2;\n  /** Set to skip N documents ahead in your query (useful for pagination). */\n  skip?: number;\n  /** Tell the query to use specific indexes in the query. Object of indexes to use, `{'_id':1}` */\n  hint?: Hint;\n  /** Specify if the cursor can timeout. */\n  timeout?: boolean;\n  /** Specify if the cursor is tailable. */\n  tailable?: boolean;\n  /** Specify if the cursor is a tailable-await cursor. Requires `tailable` to be true */\n  awaitData?: boolean;\n  /** Set the batchSize for the getMoreCommand when iterating over the query results. */\n  batchSize?: number;\n  /** If true, returns only the index keys in the resulting documents. */\n  returnKey?: boolean;\n  /** The inclusive lower bound for a specific index */\n  min?: Document_2;\n  /** The exclusive upper bound for a specific index */\n  max?: Document_2;\n  /** Number of milliseconds to wait before aborting the query. */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true */\n  maxAwaitTimeMS?: number;\n  /** The server normally times out idle cursors after an inactivity period (10 minutes) to prevent excess memory use. Set this option to prevent that. */\n  noCursorTimeout?: boolean;\n  /** Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields). */\n  collation?: CollationOptions;\n  /** Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher) */\n  allowDiskUse?: boolean;\n  /** Determines whether to close the cursor after the first batch. Defaults to false. */\n  singleBatch?: boolean;\n  /** For queries against a sharded collection, allows the command (or subsequent getMore commands) to return partial results, rather than an error, if one or more queried shards are unavailable. */\n  allowPartialResults?: boolean;\n  /** Determines whether to return the record identifier for each document. If true, adds a field $recordId to the returned documents. */\n  showRecordId?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n  /**\n   * Option to enable an optimized code path for queries looking for a particular range of `ts` values in the oplog. Requires `tailable` to be true.\n   * @deprecated Starting from MongoDB 4.4 this flag is not needed and will be ignored.\n   */\n  oplogReplay?: boolean;\n  /**\n   * Specifies the verbosity mode for the explain output.\n   * @deprecated This API is deprecated in favor of `collection.find().explain()`.\n   */\n  explain?: ExplainOptions['explain'];\n  /* Excluded from this release type: timeoutMode */\n}\n\n/** @public */\ndeclare type Flatten<Type> = Type extends ReadonlyArray<infer Item> ? Item : Type;\n\n/**\n * @public\n * Configuration options for making an AWS encryption key\n */\ndeclare interface GCPEncryptionKeyOptions {\n  /**\n   * GCP project ID\n   */\n  projectId: string;\n  /**\n   * Location name (e.g. \"global\")\n   */\n  location: string;\n  /**\n   * Key ring name\n   */\n  keyRing: string;\n  /**\n   * Key name\n   */\n  keyName: string;\n  /**\n   * Key version\n   */\n  keyVersion?: string | undefined;\n  /**\n   * KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n   */\n  endpoint?: string | undefined;\n}\n\n/** @public */\ndeclare type GCPKMSProviderConfiguration = {\n  /**\n   * The service account email to authenticate\n   */\n  email: string;\n  /**\n   * A PKCS#8 encrypted key. This can either be a base64 string or a binary representation\n   */\n  privateKey: string | Buffer;\n  /**\n   * If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\n   * Defaults to \"oauth2.googleapis.com\"\n   */\n  endpoint?: string | undefined;\n} | {\n  /**\n   * If present, an access token to authenticate with GCP.\n   */\n  accessToken: string;\n};\nexport declare interface GenericCollectionSchema {\n  schema: Document_2;\n}\nexport declare interface GenericDatabaseSchema {\n  [key: string]: GenericCollectionSchema;\n}\n\n/** @public */\ndeclare type GenericListener = (...args: any[]) => void;\nexport declare interface GenericServerSideSchema {\n  [key: string]: GenericDatabaseSchema;\n}\ndeclare type GetShardDistributionResult = {\n  Totals: {\n    data: string;\n    docs: number;\n    chunks: number;\n  } & {\n    [individualShardDistribution: `Shard ${string}`]: [`${number} % data`, `${number} % docs in cluster`, `${string} avg obj size on shard`];\n  };\n  [individualShardResult: `Shard ${string} at ${string}`]: {\n    data: string;\n    docs: number;\n    chunks: number;\n    'estimated data per chunk': string;\n    'estimated docs per chunk': number;\n  };\n};\nexport declare function getShellApiType(rawValue: any): string | null;\ndeclare interface GlobalConfigFileLoadEvent {\n  filename: string;\n  found: boolean;\n}\n\n/** @public */\ndeclare const GSSAPICanonicalizationValue: Readonly<{\n  readonly on: true;\n  readonly off: false;\n  readonly none: \"none\";\n  readonly forward: \"forward\";\n  readonly forwardAndReverse: \"forwardAndReverse\";\n}>;\n\n/** @public */\ndeclare type GSSAPICanonicalizationValue = (typeof GSSAPICanonicalizationValue)[keyof typeof GSSAPICanonicalizationValue];\n\n/** @public */\ndeclare interface HedgeOptions {\n  /** Explicitly enable or disable hedged reads. */\n  enabled?: boolean;\n}\nexport declare class Help {\n  private help;\n  private docs;\n  private attr;\n  constructor(properties: HelpProperties, options?: HelpOptions);\n  [asPrintable](): HelpProperties;\n  get [shellApiType](): string;\n}\ndeclare type HelpOptions = {\n  translate(key: string): string | undefined;\n};\nexport declare type HelpProperties = {\n  help: string;\n  docs?: string;\n  attr?: HelpPropertiesAttr[];\n};\ndeclare type HelpPropertiesAttr = {\n  name?: string;\n  description: string;\n};\n\n/** @public */\ndeclare type Hint = string | Document_2;\n\n/** @public */\ndeclare class HostAddress {\n  host: string | undefined;\n  port: number | undefined;\n  socketPath: string | undefined;\n  isIPv6: boolean;\n  constructor(hostString: string);\n  inspect(): string;\n  toString(): string;\n  static fromString(this: void, s: string): HostAddress;\n  static fromHostPort(host: string, port: number): HostAddress;\n  static fromSrvRecord({\n    name,\n    port\n  }: SrvRecord): HostAddress;\n  toHostPort(): {\n    host: string;\n    port: number;\n  };\n}\ndeclare type HostInformation = {\n  is_localhost?: boolean;\n  is_atlas_url?: boolean;\n  is_do_url?: boolean;\n};\n\n/** @public */\ndeclare type HttpOptions = Partial<Pick<RequestOptions, 'agent' | 'ca' | 'cert' | 'crl' | 'headers' | 'key' | 'lookup' | 'passphrase' | 'pfx' | 'timeout'>>;\n\n/**\n * The information returned by the server on the IDP server.\n * @public\n */\ndeclare interface IdPInfo {\n  /**\n   * A URL which describes the Authentication Server. This identifier should\n   * be the iss of provided access tokens, and be viable for RFC8414 metadata\n   * discovery and RFC9207 identification.\n   */\n  issuer: string;\n  /** A unique client ID for this OIDC client. */\n  clientId: string;\n  /** A list of additional scopes to request from IdP. */\n  requestScopes?: string[];\n}\n\n/**\n * A copy of the Node.js driver's `IdPServerInfo`\n * @public\n */\ndeclare interface IdPServerInfo {\n  issuer: string;\n  clientId: string;\n  requestScopes?: string[];\n}\n\n/**\n * A copy of the Node.js driver's `IdPServerResponse`\n * @public\n */\ndeclare interface IdPServerResponse {\n  accessToken: string;\n  expiresInSeconds?: number;\n  refreshToken?: string;\n}\n\n/** @public */\ndeclare interface IndexDescription extends Pick<CreateIndexesOptions, 'background' | 'unique' | 'partialFilterExpression' | 'sparse' | 'hidden' | 'expireAfterSeconds' | 'storageEngine' | 'version' | 'weights' | 'default_language' | 'language_override' | 'textIndexVersion' | '2dsphereIndexVersion' | 'bits' | 'min' | 'max' | 'bucketSize' | 'wildcardProjection'> {\n  collation?: CollationOptions;\n  name?: string;\n  key: {\n    [key: string]: IndexDirection;\n  } | Map<string, IndexDirection>;\n}\n\n/** @public */\ndeclare type IndexDescriptionCompact = Record<string, [name: string, direction: IndexDirection][]>;\n\n/**\n * @public\n * The index information returned by the listIndexes command. https://www.mongodb.com/docs/manual/reference/command/listIndexes/#mongodb-dbcommand-dbcmd.listIndexes\n */\ndeclare type IndexDescriptionInfo = Omit<IndexDescription, 'key' | 'version'> & {\n  key: {\n    [key: string]: IndexDirection;\n  };\n  v?: IndexDescription['version'];\n} & Document_2;\n\n/** @public */\ndeclare type IndexDirection = -1 | 1 | '2d' | '2dsphere' | 'text' | 'geoHaystack' | 'hashed' | number;\n\n/** @public */\ndeclare interface IndexInformationOptions extends ListIndexesOptions {\n  /**\n   * When `true`, an array of index descriptions is returned.\n   * When `false`, the driver returns an object that with keys corresponding to index names with values\n   * corresponding to the entries of the indexes' key.\n   *\n   * For example, the given the following indexes:\n   * ```\n   * [ { name: 'a_1', key: { a: 1 } }, { name: 'b_1_c_1' , key: { b: 1, c: 1 } }]\n   * ```\n   *\n   * When `full` is `true`, the above array is returned.  When `full` is `false`, the following is returned:\n   * ```\n   * {\n   *   'a_1': [['a', 1]],\n   *   'b_1_c_1': [['b', 1], ['c', 1]],\n   * }\n   * ```\n   */\n  full?: boolean;\n}\n\n/** @public */\ndeclare type IndexSpecification = OneOrMore<string | [string, IndexDirection] | {\n  [key: string]: IndexDirection;\n} | Map<string, IndexDirection>>;\n\n/** Given an object shaped type, return the type of the _id field or default to ObjectId @public */\ndeclare type InferIdType<TSchema> = TSchema extends {\n  _id: infer IdType;\n} ? Record<any, never> extends IdType ? never : IdType : TSchema extends {\n  _id?: infer IdType;\n} ? unknown extends IdType ? ObjectId : IdType : ObjectId;\nexport declare class InsertManyResult extends ShellApiValueClass {\n  acknowledged: boolean;\n  insertedIds: {\n    [key: number]: ObjectId;\n  };\n  constructor(acknowledged: boolean, insertedIds: {\n    [key: number]: ObjectId;\n  });\n}\n\n/** @public */\ndeclare interface InsertManyResult_2<TSchema = Document_2> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: {\n    [key: number]: InferIdType<TSchema>;\n  };\n}\n\n/** @public */\ndeclare interface InsertOneModel<TSchema extends Document_2 = Document_2> {\n  /** The document to insert. */\n  document: OptionalId<TSchema>;\n}\n\n/** @public */\ndeclare interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\nexport declare class InsertOneResult extends ShellApiValueClass {\n  acknowledged: boolean;\n  insertedId: ObjectId | undefined;\n  constructor(acknowledged: boolean, insertedId?: ObjectId);\n}\n\n/** @public */\ndeclare interface InsertOneResult_2<TSchema = Document_2> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\ndeclare type InspectFn = (x: unknown, options?: unknown) => string;\ndeclare const instanceStateSymbol: unique symbol;\ndeclare const instanceStateSymbol_2: unique symbol;\n\n/**\n * A class representation of a BSON Int32 type.\n * @public\n * @category BSONType\n */\ndeclare class Int32 extends BSONValue {\n  get _bsontype(): 'Int32';\n  value: number;\n  /**\n   * Create an Int32 type\n   *\n   * @param value - the number we want to represent as an int32.\n   */\n  constructor(value: number | string);\n  /**\n   * Attempt to create an Int32 type from string.\n   *\n   * This method will throw a BSONError on any string input that is not representable as an Int32.\n   * Notably, this method will also throw on the following string formats:\n   * - Strings in non-decimal formats (exponent notation, binary, hex, or octal digits)\n   * - Strings non-numeric and non-leading sign characters (ex: '2.0', '24,000')\n   * - Strings with leading and/or trailing whitespace\n   *\n   * Strings with leading zeros, however, are allowed.\n   *\n   * @param value - the string we want to represent as an int32.\n   */\n  static fromString(value: string): Int32;\n  /**\n   * Access the number value.\n   *\n   * @returns returns the wrapped int32 number.\n   */\n  valueOf(): number;\n  toString(radix?: number): string;\n  toJSON(): number;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare type IntegerType = number | Int32 | Long | bigint;\nexport declare class InterruptFlag {\n  private interrupted;\n  private onInterruptListeners;\n  isSet(): boolean;\n  checkpoint(): void;\n  asPromise(): InterruptWatcher;\n  set(): Promise<void>;\n  reset(): void;\n  withOverrideInterruptBehavior<Action extends (watcher: InterruptWatcher) => any, OnInterrupt extends () => Promise<void> | void>(fn: Action, onInterrupt: OnInterrupt): Promise<ReturnType<Action>>;\n}\ndeclare interface InterruptWatcher {\n  destroy: () => void;\n  promise: Promise<never>;\n}\n\n/** @public */\ndeclare type IsAny<Type, ResultIfAny, ResultIfNotAny> = true extends false & Type ? ResultIfAny : ResultIfNotAny;\n\n/** @public */\ndeclare type KeysOfAType<TSchema, Type> = { [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never }[keyof TSchema];\n\n/** @public */\ndeclare type KeysOfOtherType<TSchema, Type> = { [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key }[keyof TSchema];\ndeclare class KeyVault extends ShellApiWithMongoClass {\n  _mongo: Mongo;\n  _clientEncryption: ClientEncryption_2;\n  private _keyColl;\n  constructor(clientEncryption: ClientEncryption_2);\n  _init(): Promise<void>;\n  [asPrintable](): string;\n  createKey(kms: 'local', keyAltNames?: string[]): Binary;\n  createKey(kms: ClientEncryptionDataKeyProvider, legacyMasterKey: string, keyAltNames?: string[]): Binary;\n  createKey(kms: ClientEncryptionDataKeyProvider, options: MasterKey | DataKeyEncryptionKeyOptions | undefined): Binary;\n  createKey(kms: ClientEncryptionDataKeyProvider, options: MasterKey | DataKeyEncryptionKeyOptions | undefined, keyAltNames: string[]): Binary;\n  getKey(keyId: Binary): Document_2 | null;\n  getKeyByAltName(keyAltName: string): Document_2 | null;\n  getKeys(): Cursor;\n  deleteKey(keyId: Binary): DeleteResult | Document_2;\n  addKeyAlternateName(keyId: Binary, keyAltName: string): Document_2 | null;\n  removeKeyAlternateName(keyId: Binary, keyAltName: string): Document_2 | null;\n  rewrapManyDataKey(filter: Document_2, options?: Document_2): Document_2;\n  createDataKey(...args: Parameters<KeyVault['createKey']>): ReturnType<KeyVault['createKey']>;\n  removeKeyAltName(...args: Parameters<KeyVault['removeKeyAlternateName']>): ReturnType<KeyVault['removeKeyAlternateName']>;\n  addKeyAltName(...args: Parameters<KeyVault['addKeyAlternateName']>): ReturnType<KeyVault['addKeyAlternateName']>;\n}\n\n/**\n * @public\n * Configuration options for making a KMIP encryption key\n */\ndeclare interface KMIPEncryptionKeyOptions {\n  /**\n   * keyId is the KMIP Unique Identifier to a 96 byte KMIP Secret Data managed object.\n   *\n   * If keyId is omitted, a random 96 byte KMIP Secret Data managed object will be created.\n   */\n  keyId?: string;\n  /**\n   * Host with optional port.\n   */\n  endpoint?: string;\n  /**\n   * If true, this key should be decrypted by the KMIP server.\n   *\n   * Requires `mongodb-client-encryption>=6.0.1`.\n   */\n  delegated?: boolean;\n}\n\n/** @public */\ndeclare interface KMIPKMSProviderConfiguration {\n  /**\n   * The output endpoint string.\n   * The endpoint consists of a hostname and port separated by a colon.\n   * E.g. \"example.com:123\". A port is always present.\n   */\n  endpoint?: string;\n}\n\n/**\n * @public\n * Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n *\n * Named KMS providers _are not supported_ for automatic KMS credential fetching.\n */\ndeclare interface KMSProviders {\n  /**\n   * Configuration options for using 'aws' as your KMS provider\n   */\n  aws?: AWSKMSProviderConfiguration | Record<string, never>;\n  [key: `aws:${string}`]: AWSKMSProviderConfiguration;\n  /**\n   * Configuration options for using 'local' as your KMS provider\n   */\n  local?: LocalKMSProviderConfiguration;\n  [key: `local:${string}`]: LocalKMSProviderConfiguration;\n  /**\n   * Configuration options for using 'kmip' as your KMS provider\n   */\n  kmip?: KMIPKMSProviderConfiguration;\n  [key: `kmip:${string}`]: KMIPKMSProviderConfiguration;\n  /**\n   * Configuration options for using 'azure' as your KMS provider\n   */\n  azure?: AzureKMSProviderConfiguration | Record<string, never>;\n  [key: `azure:${string}`]: AzureKMSProviderConfiguration;\n  /**\n   * Configuration options for using 'gcp' as your KMS provider\n   */\n  gcp?: GCPKMSProviderConfiguration | Record<string, never>;\n  [key: `gcp:${string}`]: GCPKMSProviderConfiguration;\n}\n\n/** @public */\ndeclare const LEGAL_TCP_SOCKET_OPTIONS: readonly [\"autoSelectFamily\", \"autoSelectFamilyAttemptTimeout\", \"family\", \"hints\", \"localAddress\", \"localPort\", \"lookup\"];\n\n/** @public */\ndeclare const LEGAL_TLS_SOCKET_OPTIONS: readonly [\"allowPartialTrustChain\", \"ALPNProtocols\", \"ca\", \"cert\", \"checkServerIdentity\", \"ciphers\", \"crl\", \"ecdhCurve\", \"key\", \"minDHSize\", \"passphrase\", \"pfx\", \"rejectUnauthorized\", \"secureContext\", \"secureProtocol\", \"servername\", \"session\"];\n\n/** @public */\ndeclare class ListCollectionsCursor<T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo = Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo> extends AbstractCursor<T> {\n  parent: Db;\n  filter: Document_2;\n  options?: ListCollectionsOptions & Abortable;\n  constructor(db: Db, filter: Document_2, options?: ListCollectionsOptions & Abortable);\n  clone(): ListCollectionsCursor<T>;\n  /* Excluded from this release type: _initialize */\n}\n\n/** @public */\ndeclare interface ListCollectionsOptions extends Omit<CommandOperationOptions, 'writeConcern'>, Abortable {\n  /** Since 4.0: If true, will only return the collection name in the response, and will omit additional info */\n  nameOnly?: boolean;\n  /** Since 4.0: If true and nameOnly is true, allows a user without the required privilege (i.e. listCollections action on the database) to run the command when access control is enforced. */\n  authorizedCollections?: boolean;\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n  /* Excluded from this release type: timeoutMode */\n  /* Excluded from this release type: timeoutContext */\n}\n\n/** @public */\ndeclare interface ListDatabasesOptions extends CommandOperationOptions {\n  /** A query predicate that determines which databases are listed */\n  filter?: Document_2;\n  /** A flag to indicate whether the command should return just the database names, or return both database names and size information */\n  nameOnly?: boolean;\n  /** A flag that determines which databases are returned based on the user privileges when access control is enabled */\n  authorizedDatabases?: boolean;\n}\n\n/** @public */\ndeclare interface ListDatabasesResult {\n  databases: ({\n    name: string;\n    sizeOnDisk?: number;\n    empty?: boolean;\n  } & Document_2)[];\n  totalSize?: number;\n  totalSizeMb?: number;\n  ok: 1 | 0;\n}\n\n/** @public */\ndeclare class ListIndexesCursor extends AbstractCursor {\n  parent: Collection_2;\n  options?: ListIndexesOptions;\n  constructor(collection: Collection_2, options?: ListIndexesOptions);\n  clone(): ListIndexesCursor;\n  /* Excluded from this release type: _initialize */\n}\n\n/** @public */\ndeclare type ListIndexesOptions = AbstractCursorOptions & {\n  /* Excluded from this release type: omitMaxTimeMS */\n};\n\n/** @public */\ndeclare class ListSearchIndexesCursor extends AggregationCursor_2<{\n  name: string;\n}> {\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare type ListSearchIndexesOptions = Omit<AggregateOptions, 'readConcern' | 'writeConcern'>;\ndeclare const loadCallNestingLevelSymbol: unique symbol;\n\n/** @public */\ndeclare interface LocalKMSProviderConfiguration {\n  /**\n   * The master key used to encrypt/decrypt data keys.\n   * A 96-byte long Buffer or base64 encoded string.\n   */\n  key: Binary | Uint8Array | string;\n}\n\n/** @public */\ndeclare interface Log extends Record<string, any> {\n  t: Date;\n  c: MongoLoggableComponent;\n  s: SeverityLevel;\n  message?: string;\n}\n\n/** @public */\ndeclare interface LogComponentSeveritiesClientOptions {\n  /** Optional severity level for command component */\n  command?: SeverityLevel;\n  /** Optional severity level for topology component */\n  topology?: SeverityLevel;\n  /** Optional severity level for server selection component */\n  serverSelection?: SeverityLevel;\n  /** Optional severity level for connection component */\n  connection?: SeverityLevel;\n  /** Optional severity level for client component */\n  client?: SeverityLevel;\n  /** Optional default severity level to be used if any of the above are unset */\n  default?: SeverityLevel;\n}\n\n/**\n * A class representing a 64-bit integer\n * @public\n * @category BSONType\n * @remarks\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16 bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n * Common constant values ZERO, ONE, NEG_ONE, etc. are found as static properties on this class.\n */\ndeclare class Long extends BSONValue {\n  get _bsontype(): 'Long';\n  /** An indicator used to reliably determine if an object is a Long or not. */\n  get __isLong__(): boolean;\n  /**\n   * The high 32 bits as a signed value.\n   */\n  high: number;\n  /**\n   * The low 32 bits as a signed value.\n   */\n  low: number;\n  /**\n   * Whether unsigned or not.\n   */\n  unsigned: boolean;\n  /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *\n   * @param low - The low (signed) 32 bits of the long\n   * @param high - The high (signed) 32 bits of the long\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   */\n  constructor(low: number, high?: number, unsigned?: boolean);\n  /**\n   * Constructs a 64 bit two's-complement integer, given a bigint representation.\n   *\n   * @param value - BigInt representation of the long value\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   */\n  constructor(value: bigint, unsigned?: boolean);\n  /**\n   * Constructs a 64 bit two's-complement integer, given a string representation.\n   *\n   * @param value - String representation of the long value\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   */\n  constructor(value: string, unsigned?: boolean);\n  static TWO_PWR_24: Long;\n  /** Maximum unsigned value. */\n  static MAX_UNSIGNED_VALUE: Long;\n  /** Signed zero */\n  static ZERO: Long;\n  /** Unsigned zero. */\n  static UZERO: Long;\n  /** Signed one. */\n  static ONE: Long;\n  /** Unsigned one. */\n  static UONE: Long;\n  /** Signed negative one. */\n  static NEG_ONE: Long;\n  /** Maximum signed value. */\n  static MAX_VALUE: Long;\n  /** Minimum signed value. */\n  static MIN_VALUE: Long;\n  /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits.\n   * Each is assumed to use 32 bits.\n   * @param lowBits - The low 32 bits\n   * @param highBits - The high 32 bits\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long;\n  /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @param value - The 32 bit integer in question\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromInt(value: number, unsigned?: boolean): Long;\n  /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @param value - The number in question\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromNumber(value: number, unsigned?: boolean): Long;\n  /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @param value - The number in question\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromBigInt(value: bigint, unsigned?: boolean): Long;\n  /* Excluded from this release type: _fromString */\n  /**\n   * Returns a signed Long representation of the given string, written using radix 10.\n   * Will throw an error if the given text is not exactly representable as a Long.\n   * Throws an error if any of the following conditions are true:\n   * - the string contains invalid characters for the radix 10\n   * - the string contains whitespace\n   * - the value the string represents is too large or too small to be a Long\n   * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n   * @param str - The textual representation of the Long\n   * @returns The corresponding Long value\n   */\n  static fromStringStrict(str: string): Long;\n  /**\n   * Returns a Long representation of the given string, written using the radix 10.\n   * Will throw an error if the given parameters are not exactly representable as a Long.\n   * Throws an error if any of the following conditions are true:\n   * - the string contains invalid characters for the given radix\n   * - the string contains whitespace\n   * - the value the string represents is too large or too small to be a Long\n   * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n   * @param str - The textual representation of the Long\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromStringStrict(str: string, unsigned?: boolean): Long;\n  /**\n   * Returns a signed Long representation of the given string, written using the specified radix.\n   * Will throw an error if the given parameters are not exactly representable as a Long.\n   * Throws an error if any of the following conditions are true:\n   * - the string contains invalid characters for the given radix\n   * - the string contains whitespace\n   * - the value the string represents is too large or too small to be a Long\n   * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n   * @param str - The textual representation of the Long\n   * @param radix - The radix in which the text is written (2-36), defaults to 10\n   * @returns The corresponding Long value\n   */\n  static fromStringStrict(str: string, radix?: boolean): Long;\n  /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * Will throw an error if the given parameters are not exactly representable as a Long.\n   * Throws an error if any of the following conditions are true:\n   * - the string contains invalid characters for the given radix\n   * - the string contains whitespace\n   * - the value the string represents is too large or too small to be a Long\n   * Unlike Long.fromString, this method does not coerce '+/-Infinity' and 'NaN' to Long.Zero\n   * @param str - The textual representation of the Long\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @param radix - The radix in which the text is written (2-36), defaults to 10\n   * @returns The corresponding Long value\n   */\n  static fromStringStrict(str: string, unsigned?: boolean, radix?: number): Long;\n  /**\n   * Returns a signed Long representation of the given string, written using radix 10.\n   *\n   * If the input string is empty, this function will throw a BSONError.\n   *\n   * If input string does not have valid signed 64-bit Long representation, this method will return a coerced value:\n   * - inputs that overflow 64-bit signed long will be coerced to Long.MAX_VALUE and Long.MIN_VALUE respectively\n   * - 'NaN' or '+/-Infinity' are coerced to Long.ZERO\n   * - other invalid characters sequences have variable behavior\n   *\n   * @param str - The textual representation of the Long\n   * @returns The corresponding Long value\n   */\n  static fromString(str: string): Long;\n  /**\n   * Returns a signed Long representation of the given string, written using the provided radix.\n   *\n   * If the input string is empty or a provided radix is not within (2-36), this function will throw a BSONError.\n   *\n   * If input parameters do not have valid signed 64-bit Long representation, this method will return a coerced value:\n   * - inputs that overflow 64-bit signed long will be coerced to Long.MAX_VALUE and Long.MIN_VALUE respectively\n   * - if the radix is less than 24, 'NaN' is coerced to Long.ZERO\n   * - if the radix is less than 35, '+/-Infinity' inputs are coerced to Long.ZERO\n   * - other invalid characters sequences have variable behavior\n   * @param str - The textual representation of the Long\n   * @param radix - The radix in which the text is written (2-36), defaults to 10\n   * @returns The corresponding Long value\n   */\n  static fromString(str: string, radix?: number): Long;\n  /**\n   * Returns a Long representation of the given string, written using radix 10.\n   *\n   * If the input string is empty, this function will throw a BSONError.\n   *\n   * If input parameters do not have a valid 64-bit Long representation, this method will return a coerced value:\n   * - inputs that overflow 64-bit long will be coerced to max or min (if signed) values\n   * - if the radix is less than 24, 'NaN' is coerced to Long.ZERO\n   * - if the radix is less than 35, '+/-Infinity' inputs are coerced to Long.ZERO\n   * - other invalid characters sequences have variable behavior\n   * @param str - The textual representation of the Long\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromString(str: string, unsigned?: boolean): Long;\n  /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   *\n   * If the input string is empty or a provided radix is not within (2-36), this function will throw a BSONError.\n   *\n   * If input parameters do not have a valid 64-bit Long representation, this method will return a coerced value:\n   * - inputs that overflow 64-bit long will be coerced to max or min (if signed) values\n   * - if the radix is less than 24, 'NaN' is coerced to Long.ZERO\n   * - if the radix is less than 35, '+/-Infinity' inputs are coerced to Long.ZERO\n   * - other invalid characters sequences have variable behavior\n   * @param str - The textual representation of the Long\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @param radix - The radix in which the text is written (2-36), defaults to 10\n   * @returns The corresponding Long value\n   */\n  static fromString(str: string, unsigned?: boolean, radix?: number): Long;\n  /**\n   * Creates a Long from its byte representation.\n   * @param bytes - Byte representation\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @param le - Whether little or big endian, defaults to big endian\n   * @returns The corresponding Long value\n   */\n  static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long;\n  /**\n   * Creates a Long from its little endian byte representation.\n   * @param bytes - Little endian byte representation\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromBytesLE(bytes: number[], unsigned?: boolean): Long;\n  /**\n   * Creates a Long from its big endian byte representation.\n   * @param bytes - Big endian byte representation\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   * @returns The corresponding Long value\n   */\n  static fromBytesBE(bytes: number[], unsigned?: boolean): Long;\n  /**\n   * Tests if the specified object is a Long.\n   */\n  static isLong(value: unknown): value is Long;\n  /**\n   * Converts the specified value to a Long.\n   * @param unsigned - Whether unsigned or not, defaults to signed\n   */\n  static fromValue(val: number | string | {\n    low: number;\n    high: number;\n    unsigned?: boolean;\n  }, unsigned?: boolean): Long;\n  /** Returns the sum of this and the specified Long. */\n  add(addend: string | number | Long | Timestamp): Long;\n  /**\n   * Returns the sum of this and the specified Long.\n   * @returns Sum\n   */\n  and(other: string | number | Long | Timestamp): Long;\n  /**\n   * Compares this Long's value with the specified's.\n   * @returns 0 if they are the same, 1 if the this is greater and -1 if the given one is greater\n   */\n  compare(other: string | number | Long | Timestamp): 0 | 1 | -1;\n  /** This is an alias of {@link Long.compare} */\n  comp(other: string | number | Long | Timestamp): 0 | 1 | -1;\n  /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.\n   * @returns Quotient\n   */\n  divide(divisor: string | number | Long | Timestamp): Long;\n  /**This is an alias of {@link Long.divide} */\n  div(divisor: string | number | Long | Timestamp): Long;\n  /**\n   * Tests if this Long's value equals the specified's.\n   * @param other - Other value\n   */\n  equals(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.equals} */\n  eq(other: string | number | Long | Timestamp): boolean;\n  /** Gets the high 32 bits as a signed integer. */\n  getHighBits(): number;\n  /** Gets the high 32 bits as an unsigned integer. */\n  getHighBitsUnsigned(): number;\n  /** Gets the low 32 bits as a signed integer. */\n  getLowBits(): number;\n  /** Gets the low 32 bits as an unsigned integer. */\n  getLowBitsUnsigned(): number;\n  /** Gets the number of bits needed to represent the absolute value of this Long. */\n  getNumBitsAbs(): number;\n  /** Tests if this Long's value is greater than the specified's. */\n  greaterThan(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.greaterThan} */\n  gt(other: string | number | Long | Timestamp): boolean;\n  /** Tests if this Long's value is greater than or equal the specified's. */\n  greaterThanOrEqual(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.greaterThanOrEqual} */\n  gte(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.greaterThanOrEqual} */\n  ge(other: string | number | Long | Timestamp): boolean;\n  /** Tests if this Long's value is even. */\n  isEven(): boolean;\n  /** Tests if this Long's value is negative. */\n  isNegative(): boolean;\n  /** Tests if this Long's value is odd. */\n  isOdd(): boolean;\n  /** Tests if this Long's value is positive. */\n  isPositive(): boolean;\n  /** Tests if this Long's value equals zero. */\n  isZero(): boolean;\n  /** Tests if this Long's value is less than the specified's. */\n  lessThan(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long#lessThan}. */\n  lt(other: string | number | Long | Timestamp): boolean;\n  /** Tests if this Long's value is less than or equal the specified's. */\n  lessThanOrEqual(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.lessThanOrEqual} */\n  lte(other: string | number | Long | Timestamp): boolean;\n  /** Returns this Long modulo the specified. */\n  modulo(divisor: string | number | Long | Timestamp): Long;\n  /** This is an alias of {@link Long.modulo} */\n  mod(divisor: string | number | Long | Timestamp): Long;\n  /** This is an alias of {@link Long.modulo} */\n  rem(divisor: string | number | Long | Timestamp): Long;\n  /**\n   * Returns the product of this and the specified Long.\n   * @param multiplier - Multiplier\n   * @returns Product\n   */\n  multiply(multiplier: string | number | Long | Timestamp): Long;\n  /** This is an alias of {@link Long.multiply} */\n  mul(multiplier: string | number | Long | Timestamp): Long;\n  /** Returns the Negation of this Long's value. */\n  negate(): Long;\n  /** This is an alias of {@link Long.negate} */\n  neg(): Long;\n  /** Returns the bitwise NOT of this Long. */\n  not(): Long;\n  /** Tests if this Long's value differs from the specified's. */\n  notEquals(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.notEquals} */\n  neq(other: string | number | Long | Timestamp): boolean;\n  /** This is an alias of {@link Long.notEquals} */\n  ne(other: string | number | Long | Timestamp): boolean;\n  /**\n   * Returns the bitwise OR of this Long and the specified.\n   */\n  or(other: number | string | Long): Long;\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @param numBits - Number of bits\n   * @returns Shifted Long\n   */\n  shiftLeft(numBits: number | Long): Long;\n  /** This is an alias of {@link Long.shiftLeft} */\n  shl(numBits: number | Long): Long;\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @param numBits - Number of bits\n   * @returns Shifted Long\n   */\n  shiftRight(numBits: number | Long): Long;\n  /** This is an alias of {@link Long.shiftRight} */\n  shr(numBits: number | Long): Long;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @param numBits - Number of bits\n   * @returns Shifted Long\n   */\n  shiftRightUnsigned(numBits: Long | number): Long;\n  /** This is an alias of {@link Long.shiftRightUnsigned} */\n  shr_u(numBits: number | Long): Long;\n  /** This is an alias of {@link Long.shiftRightUnsigned} */\n  shru(numBits: number | Long): Long;\n  /**\n   * Returns the difference of this and the specified Long.\n   * @param subtrahend - Subtrahend\n   * @returns Difference\n   */\n  subtract(subtrahend: string | number | Long | Timestamp): Long;\n  /** This is an alias of {@link Long.subtract} */\n  sub(subtrahend: string | number | Long | Timestamp): Long;\n  /** Converts the Long to a 32 bit integer, assuming it is a 32 bit integer. */\n  toInt(): number;\n  /** Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa). */\n  toNumber(): number;\n  /** Converts the Long to a BigInt (arbitrary precision). */\n  toBigInt(): bigint;\n  /**\n   * Converts this Long to its byte representation.\n   * @param le - Whether little or big endian, defaults to big endian\n   * @returns Byte representation\n   */\n  toBytes(le?: boolean): number[];\n  /**\n   * Converts this Long to its little endian byte representation.\n   * @returns Little endian byte representation\n   */\n  toBytesLE(): number[];\n  /**\n   * Converts this Long to its big endian byte representation.\n   * @returns Big endian byte representation\n   */\n  toBytesBE(): number[];\n  /**\n   * Converts this Long to signed.\n   */\n  toSigned(): Long;\n  /**\n   * Converts the Long to a string written in the specified radix.\n   * @param radix - Radix (2-36), defaults to 10\n   * @throws RangeError If `radix` is out of range\n   */\n  toString(radix?: number): string;\n  /** Converts this Long to unsigned. */\n  toUnsigned(): Long;\n  /** Returns the bitwise XOR of this Long and the given one. */\n  xor(other: Long | number | string): Long;\n  /** This is an alias of {@link Long.isZero} */\n  eqz(): boolean;\n  /** This is an alias of {@link Long.lessThanOrEqual} */\n  le(other: string | number | Long | Timestamp): boolean;\n  toExtendedJSON(options?: EJSONOptions): number | LongExtended;\n  static fromExtendedJSON(doc: {\n    $numberLong: string;\n  }, options?: EJSONOptions): number | Long | bigint;\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface LongExtended {\n  $numberLong: string;\n}\ndeclare type LongWithoutAccidentallyExposedMethods = Omit<typeof bson.Long, 'fromExtendedJSON'>;\n\n/** @public */\ndeclare type LongWithoutOverrides = new (low: unknown, high?: number | boolean, unsigned?: boolean) => { [P in Exclude<keyof Long, TimestampOverrides>]: Long[P] };\n\n/** @public */\ndeclare const LongWithoutOverridesClass: LongWithoutOverrides;\ndeclare type MapReduceShellOptions = Document_2 | string;\ndeclare type MasterKey = AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;\n\n/** @public */\ndeclare type MatchKeysAndValues<TSchema> = Readonly<Partial<TSchema>> & Record<string, any>;\n\n/**\n * A class representation of the BSON MaxKey type.\n * @public\n * @category BSONType\n */\ndeclare class MaxKey extends BSONValue {\n  get _bsontype(): 'MaxKey';\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(): string;\n}\n\n/**\n * A class representation of the BSON MinKey type.\n * @public\n * @category BSONType\n */\ndeclare class MinKey extends BSONValue {\n  get _bsontype(): 'MinKey';\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(): string;\n}\n\n/** @public */\ndeclare interface ModifyResult<TSchema = Document_2> {\n  value: WithId<TSchema> | null;\n  lastErrorObject?: Document_2;\n  ok: 0 | 1;\n}\nexport declare class Mongo<M extends GenericServerSideSchema = GenericServerSideSchema> extends ShellApiClass {\n  private __serviceProvider;\n  readonly _databases: Record<StringKey<M>, Database<M>>;\n  _instanceState: ShellInstanceState;\n  _connectionInfo: ConnectionInfo;\n  private _explicitEncryptionOnly;\n  private _keyVault;\n  private _clientEncryption;\n  private _readPreferenceWasExplicitlyRequested;\n  private _cachedDatabaseNames;\n  constructor(instanceState: ShellInstanceState, uri?: string | Mongo, fleOptions?: ClientSideFieldLevelEncryptionOptions, otherOptions?: {\n    api?: ServerApi | ServerApiVersion;\n  }, sp?: ServiceProvider);\n  get _uri(): string;\n  get _fleOptions(): AutoEncryptionOptions | undefined;\n  get _serviceProvider(): ServiceProvider;\n  set _serviceProvider(sp: ServiceProvider);\n  _displayBatchSize(): Promise<number>;\n  [asPrintable](): string;\n  private _emitMongoApiCall;\n  connect(username?: string, password?: string): Promise<void>;\n  _getDb<K extends StringKey<M>>(name: K): Database<M, M[K]>;\n  getDB<K extends StringKey<M>>(db: K): Database<M, M[K]>;\n  getCollection<KD extends StringKey<M>, KC extends StringKey<M[KD]>>(name: `${KD}.${KC}`): Collection<M, M[KD], M[KD][KC]>;\n  getURI(): string;\n  use(db: StringKey<M>): string;\n  _listDatabases(opts?: ListDatabasesOptions): Promise<{\n    databases: {\n      name: string;\n      sizeOnDisk: number | ShellBson['Long'];\n      empty: boolean;\n    }[];\n    ok: 1;\n  }>;\n  _getDatabaseNamesForCompletion(): Promise<string[]>;\n  getDBs(options?: ListDatabasesOptions): {\n    databases: {\n      name: string;\n      sizeOnDisk: number | ShellBson['Long'];\n      empty: boolean;\n    }[];\n    ok: 1;\n  };\n  bulkWrite(models: AnyClientBulkWriteModel<Document_2>[], options?: ClientBulkWriteOptions): ClientBulkWriteResult_2;\n  getDBNames(options?: ListDatabasesOptions): StringKey<M>[];\n  show(cmd: string, arg?: string, tracked?: boolean): CommandResult;\n  close(force?: boolean): Promise<void>;\n  _suspend(): Promise<() => Promise<void>>;\n  getReadPrefMode(): ReadPreferenceMode;\n  getReadPrefTagSet(): Record<string, string>[] | undefined;\n  getReadPref(): ReadPreference;\n  _getExplicitlyRequestedReadPref(): {\n    readPreference: ReadPreference;\n  } | undefined;\n  getReadConcern(): string | undefined;\n  getWriteConcern(): WriteConcern | undefined;\n  setReadPref(mode: ReadPreferenceLike, tagSet?: Record<string, string>[], hedgeOptions?: Document_2): void;\n  setReadConcern(level: ReadConcernLevel): void;\n  setWriteConcern(concern: WriteConcern): void;\n  setWriteConcern(wValue: string | number, wtimeoutMSValue?: number | undefined, jValue?: boolean | undefined): void;\n  startSession(options?: Document_2): Session;\n  setCausalConsistency(): void;\n  isCausalConsistency(): void;\n  setSlaveOk(): void;\n  setSecondaryOk(): void;\n  watch(pipeline?: Document_2[] | ChangeStreamOptions, options?: ChangeStreamOptions): ChangeStreamCursor;\n  getClientEncryption(): ClientEncryption_2;\n  getKeyVault(): KeyVault;\n  convertShardKeyToHashed(value: any): unknown;\n}\n\n/** @public */\ndeclare const MONGO_CLIENT_EVENTS: readonly [\"connectionPoolCreated\", \"connectionPoolReady\", \"connectionPoolCleared\", \"connectionPoolClosed\", \"connectionCreated\", \"connectionReady\", \"connectionClosed\", \"connectionCheckOutStarted\", \"connectionCheckOutFailed\", \"connectionCheckedOut\", \"connectionCheckedIn\", \"commandStarted\", \"commandSucceeded\", \"commandFailed\", \"serverOpening\", \"serverClosed\", \"serverDescriptionChanged\", \"topologyOpening\", \"topologyClosed\", \"topologyDescriptionChanged\", \"error\", \"timeout\", \"close\", \"serverHeartbeatStarted\", \"serverHeartbeatSucceeded\", \"serverHeartbeatFailed\"];\n\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * // Enable command monitoring for debugging\n * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });\n *\n * client.on('commandStarted', started => console.log(started));\n * client.db().collection('pets');\n * await client.insertOne({ name: 'spot', kind: 'dog' });\n * ```\n */\ndeclare class MongoClient extends TypedEventEmitter<MongoClientEvents> implements AsyncDisposable_2 {\n  /* Excluded from this release type: s */\n  /* Excluded from this release type: topology */\n  /* Excluded from this release type: mongoLogger */\n  /* Excluded from this release type: connectionLock */\n  /* Excluded from this release type: closeLock */\n  /**\n   * The consolidate, parsed, transformed and merged options.\n   */\n  readonly options: Readonly<Omit<MongoOptions, 'monitorCommands' | 'ca' | 'crl' | 'key' | 'cert'>> & Pick<MongoOptions, 'monitorCommands' | 'ca' | 'crl' | 'key' | 'cert'>;\n  constructor(url: string, options?: MongoClientOptions);\n  /* Excluded from this release type: [Symbol.asyncDispose] */\n  /* Excluded from this release type: asyncDispose */\n  /* Excluded from this release type: checkForNonGenuineHosts */\n  get serverApi(): Readonly<ServerApi | undefined>;\n  /* Excluded from this release type: monitorCommands */\n  /* Excluded from this release type: monitorCommands */\n  /* Excluded from this release type: autoEncrypter */\n  get readConcern(): ReadConcern | undefined;\n  get writeConcern(): WriteConcern | undefined;\n  get readPreference(): ReadPreference;\n  get bsonOptions(): BSONSerializeOptions;\n  get timeoutMS(): number | undefined;\n  /**\n   * Executes a client bulk write operation, available on server 8.0+.\n   * @param models - The client bulk write models.\n   * @param options - The client bulk write options.\n   * @returns A ClientBulkWriteResult for acknowledged writes and ok: 1 for unacknowledged writes.\n   */\n  bulkWrite<SchemaMap extends Record<string, Document_2> = Record<string, Document_2>>(models: ReadonlyArray<ClientBulkWriteModel<SchemaMap>>, options?: ClientBulkWriteOptions): Promise<ClientBulkWriteResult>;\n  /**\n   * Connect to MongoDB using a url\n   *\n   * @remarks\n   * Calling `connect` is optional since the first operation you perform will call `connect` if it's needed.\n   * `timeoutMS` will bound the time any operation can take before throwing a timeout error.\n   * However, when the operation being run is automatically connecting your `MongoClient` the `timeoutMS` will not apply to the time taken to connect the MongoClient.\n   * This means the time to setup the `MongoClient` does not count against `timeoutMS`.\n   * If you are using `timeoutMS` we recommend connecting your client explicitly in advance of any operation to avoid this inconsistent execution time.\n   *\n   * @remarks\n   * The driver will look up corresponding SRV and TXT records if the connection string starts with `mongodb+srv://`.\n   * If those look ups throw a DNS Timeout error, the driver will retry the look up once.\n   *\n   * @see docs.mongodb.org/manual/reference/connection-string/\n   */\n  connect(): Promise<this>;\n  /* Excluded from this release type: _connect */\n  /**\n   * Cleans up client-side resources used by the MongoCLient and .  This includes:\n   *\n   * - Closes all open, unused connections (see note).\n   * - Ends all in-use sessions with {@link ClientSession#endSession|ClientSession.endSession()}.\n   * - Ends all unused sessions server-side.\n   * - Cleans up any resources being used for auto encryption if auto encryption is enabled.\n   *\n   * @remarks Any in-progress operations are not killed and any connections used by in progress operations\n   * will be cleaned up lazily as operations finish.\n   *\n   * @param force - Force close, emitting no events\n   */\n  close(force?: boolean): Promise<void>;\n  private _close;\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n  db(dbName?: string, options?: DbOptions): Db;\n  /**\n   * Connect to MongoDB using a url\n   *\n   * @remarks\n   * Calling `connect` is optional since the first operation you perform will call `connect` if it's needed.\n   * `timeoutMS` will bound the time any operation can take before throwing a timeout error.\n   * However, when the operation being run is automatically connecting your `MongoClient` the `timeoutMS` will not apply to the time taken to connect the MongoClient.\n   * This means the time to setup the `MongoClient` does not count against `timeoutMS`.\n   * If you are using `timeoutMS` we recommend connecting your client explicitly in advance of any operation to avoid this inconsistent execution time.\n   *\n   * @remarks\n   * The programmatically provided options take precedence over the URI options.\n   *\n   * @remarks\n   * The driver will look up corresponding SRV and TXT records if the connection string starts with `mongodb+srv://`.\n   * If those look ups throw a DNS Timeout error, the driver will retry the look up once.\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/connection-string/\n   */\n  static connect(url: string, options?: MongoClientOptions): Promise<MongoClient>;\n  /**\n   * Creates a new ClientSession. When using the returned session in an operation\n   * a corresponding ServerSession will be created.\n   *\n   * @remarks\n   * A ClientSession instance may only be passed to operations being performed on the same\n   * MongoClient it was started from.\n   */\n  startSession(options?: ClientSessionOptions): ClientSession;\n  /**\n   * A convenience method for creating and handling the clean up of a ClientSession.\n   * The session will always be ended when the executor finishes.\n   *\n   * @param executor - An executor function that all operations using the provided session must be invoked in\n   * @param options - optional settings for the session\n   */\n  withSession<T = any>(executor: WithSessionCallback<T>): Promise<T>;\n  withSession<T = any>(options: ClientSessionOptions, executor: WithSessionCallback<T>): Promise<T>;\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to provide the schema that may be defined for all the data within the current cluster\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   *\n   * @remarks\n   * When `timeoutMS` is configured for a change stream, it will have different behaviour depending\n   * on whether the change stream is in iterator mode or emitter mode. In both cases, a change\n   * stream will time out if it does not receive a change event within `timeoutMS` of the last change\n   * event.\n   *\n   * Note that if a change stream is consistently timing out when watching a collection, database or\n   * client that is being changed, then this may be due to the server timing out before it can finish\n   * processing the existing oplog. To address this, restart the change stream with a higher\n   * `timeoutMS`.\n   *\n   * If the change stream times out the initial aggregate operation to establish the change stream on\n   * the server, then the client will close the change stream. If the getMore calls to the server\n   * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError\n   * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in\n   * emitter mode.\n   *\n   * To determine whether or not the change stream is still open following a timeout, check the\n   * {@link ChangeStream.closed} getter.\n   *\n   * @example\n   * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.\n   * The next call can just be retried after this succeeds.\n   * ```ts\n   * const changeStream = collection.watch([], { timeoutMS: 100 });\n   * try {\n   *     await changeStream.next();\n   * } catch (e) {\n   *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {\n   *       await changeStream.next();\n   *     }\n   *     throw e;\n   * }\n   * ```\n   *\n   * @example\n   * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will\n   * emit an error event that returns a MongoOperationTimeoutError, but will not close the change\n   * stream unless the resume attempt fails. There is no need to re-establish change listeners as\n   * this will automatically continue emitting change events once the resume attempt completes.\n   *\n   * ```ts\n   * const changeStream = collection.watch([], { timeoutMS: 100 });\n   * changeStream.on('change', console.log);\n   * changeStream.on('error', e => {\n   *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {\n   *         // do nothing\n   *     } else {\n   *         changeStream.close();\n   *     }\n   * });\n   * ```\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TSchema - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch<TSchema extends Document_2 = Document_2, TChange extends Document_2 = ChangeStreamDocument<TSchema>>(pipeline?: Document_2[], options?: ChangeStreamOptions): ChangeStream<TSchema, TChange>;\n}\n\n/** @public */\ndeclare type MongoClientEvents = Pick<TopologyEvents, (typeof MONGO_CLIENT_EVENTS)[number]> & {\n  open(mongoClient: MongoClient): void;\n};\n\n/**\n * Describes all possible URI query options for the mongo client\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/connection-string\n */\ndeclare interface MongoClientOptions extends BSONSerializeOptions, SupportedNodeConnectionOptions {\n  /** Specifies the name of the replica set, if the mongod is a member of a replica set. */\n  replicaSet?: string;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n  /** Enables or disables TLS/SSL for the connection. */\n  tls?: boolean;\n  /** A boolean to enable or disables TLS/SSL for the connection. (The ssl option is equivalent to the tls option.) */\n  ssl?: boolean;\n  /** Specifies the location of a local .pem file that contains either the client's TLS/SSL certificate and key. */\n  tlsCertificateKeyFile?: string;\n  /** Specifies the password to de-crypt the tlsCertificateKeyFile. */\n  tlsCertificateKeyFilePassword?: string;\n  /** Specifies the location of a local .pem file that contains the root certificate chain from the Certificate Authority. This file is used to validate the certificate presented by the mongod/mongos instance. */\n  tlsCAFile?: string;\n  /** Specifies the location of a local CRL .pem file that contains the client revokation list. */\n  tlsCRLFile?: string;\n  /** Bypasses validation of the certificates presented by the mongod/mongos instance */\n  tlsAllowInvalidCertificates?: boolean;\n  /** Disables hostname validation of the certificate presented by the mongod/mongos instance. */\n  tlsAllowInvalidHostnames?: boolean;\n  /** Disables various certificate validations. */\n  tlsInsecure?: boolean;\n  /** The time in milliseconds to attempt a connection before timing out. */\n  connectTimeoutMS?: number;\n  /** The time in milliseconds to attempt a send or receive on a socket before the attempt times out. */\n  socketTimeoutMS?: number;\n  /** An array or comma-delimited string of compressors to enable network compression for communication between this client and a mongod/mongos instance. */\n  compressors?: CompressorName[] | string;\n  /** An integer that specifies the compression level if using zlib for network compression. */\n  zlibCompressionLevel?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | undefined;\n  /** The maximum number of hosts to connect to when using an srv connection string, a setting of `0` means unlimited hosts */\n  srvMaxHosts?: number;\n  /**\n   * Modifies the srv URI to look like:\n   *\n   * `_{srvServiceName}._tcp.{hostname}.{domainname}`\n   *\n   * Querying this DNS URI is expected to respond with SRV records\n   */\n  srvServiceName?: string;\n  /** The maximum number of connections in the connection pool. */\n  maxPoolSize?: number;\n  /** The minimum number of connections in the connection pool. */\n  minPoolSize?: number;\n  /** The maximum number of connections that may be in the process of being established concurrently by the connection pool. */\n  maxConnecting?: number;\n  /** The maximum number of milliseconds that a connection can remain idle in the pool before being removed and closed. */\n  maxIdleTimeMS?: number;\n  /** The maximum time in milliseconds that a thread can wait for a connection to become available. */\n  waitQueueTimeoutMS?: number;\n  /** Specify a read concern for the collection (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The level of isolation */\n  readConcernLevel?: ReadConcernLevel;\n  /** Specifies the read preferences for this connection */\n  readPreference?: ReadPreferenceMode | ReadPreference;\n  /** Specifies, in seconds, how stale a secondary can be before the client stops using it for read operations. */\n  maxStalenessSeconds?: number;\n  /** Specifies the tags document as a comma-separated list of colon-separated key-value pairs.  */\n  readPreferenceTags?: TagSet[];\n  /** The auth settings for when connection to server. */\n  auth?: Auth;\n  /** Specify the database name associated with the users credentials. */\n  authSource?: string;\n  /** Specify the authentication mechanism that MongoDB will use to authenticate the connection. */\n  authMechanism?: AuthMechanism;\n  /** Specify properties for the specified authMechanism as a comma-separated list of colon-separated key-value pairs. */\n  authMechanismProperties?: AuthMechanismProperties;\n  /** The size (in milliseconds) of the latency window for selecting among multiple suitable MongoDB instances. */\n  localThresholdMS?: number;\n  /** Specifies how long (in milliseconds) to block for server selection before throwing an exception.  */\n  serverSelectionTimeoutMS?: number;\n  /** heartbeatFrequencyMS controls when the driver checks the state of the MongoDB deployment. Specify the interval (in milliseconds) between checks, counted from the end of the previous check until the beginning of the next one. */\n  heartbeatFrequencyMS?: number;\n  /** Sets the minimum heartbeat frequency. In the event that the driver has to frequently re-check a server's availability, it will wait at least this long since the previous check to avoid wasted effort. */\n  minHeartbeatFrequencyMS?: number;\n  /** The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections */\n  appName?: string;\n  /** Enables retryable reads. */\n  retryReads?: boolean;\n  /** Enable retryable writes. */\n  retryWrites?: boolean;\n  /** Allow a driver to force a Single topology type with a connection string containing one host */\n  directConnection?: boolean;\n  /** Instruct the driver it is connecting to a load balancer fronting a mongos like service */\n  loadBalanced?: boolean;\n  /**\n   * The write concern w value\n   * @deprecated Please use the `writeConcern` option instead\n   */\n  w?: W;\n  /**\n   * The write concern timeout\n   * @deprecated Please use the `writeConcern` option instead\n   */\n  wtimeoutMS?: number;\n  /**\n   * The journal write concern\n   * @deprecated Please use the `writeConcern` option instead\n   */\n  journal?: boolean;\n  /**\n   * A MongoDB WriteConcern, which describes the level of acknowledgement\n   * requested from MongoDB for write operations.\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/write-concern/\n   */\n  writeConcern?: WriteConcern | WriteConcernSettings;\n  /** TCP Connection no delay */\n  noDelay?: boolean;\n  /** Force server to assign `_id` values instead of driver */\n  forceServerObjectId?: boolean;\n  /** A primary key factory function for generation of custom `_id` keys */\n  pkFactory?: PkFactory;\n  /** Enable command monitoring for this client */\n  monitorCommands?: boolean;\n  /** Server API version */\n  serverApi?: ServerApi | ServerApiVersion;\n  /**\n   * Optionally enable in-use auto encryption\n   *\n   * @remarks\n   *  Automatic encryption is an enterprise only feature that only applies to operations on a collection. Automatic encryption is not supported for operations on a database or view, and operations that are not bypassed will result in error\n   *  (see [libmongocrypt: Auto Encryption Allow-List](https://github.com/mongodb/specifications/blob/master/source/client-side-encryption/client-side-encryption.md#libmongocrypt-auto-encryption-allow-list)). To bypass automatic encryption for all operations, set bypassAutoEncryption=true in AutoEncryptionOpts.\n   *\n   *  Automatic encryption requires the authenticated user to have the [listCollections privilege action](https://www.mongodb.com/docs/manual/reference/command/listCollections/#dbcmd.listCollections).\n   *\n   *  If a MongoClient with a limited connection pool size (i.e a non-zero maxPoolSize) is configured with AutoEncryptionOptions, a separate internal MongoClient is created if any of the following are true:\n   *  - AutoEncryptionOptions.keyVaultClient is not passed.\n   *  - AutoEncryptionOptions.bypassAutomaticEncryption is false.\n   *\n   * If an internal MongoClient is created, it is configured with the same options as the parent MongoClient except minPoolSize is set to 0 and AutoEncryptionOptions is omitted.\n   */\n  autoEncryption?: AutoEncryptionOptions;\n  /** Allows a wrapping driver to amend the client metadata generated by the driver to include information about the wrapping driver */\n  driverInfo?: DriverInfo;\n  /** Configures a Socks5 proxy host used for creating TCP connections. */\n  proxyHost?: string;\n  /** Configures a Socks5 proxy port used for creating TCP connections. */\n  proxyPort?: number;\n  /** Configures a Socks5 proxy username when the proxy in proxyHost requires username/password authentication. */\n  proxyUsername?: string;\n  /** Configures a Socks5 proxy password when the proxy in proxyHost requires username/password authentication. */\n  proxyPassword?: string;\n  /** Instructs the driver monitors to use a specific monitoring mode */\n  serverMonitoringMode?: ServerMonitoringMode;\n  /**\n   * @public\n   * Specifies the destination of the driver's logging. The default is stderr.\n   */\n  mongodbLogPath?: 'stderr' | 'stdout' | MongoDBLogWritable;\n  /**\n   * @public\n   * Enable logging level per component or use `default` to control any unset components.\n   */\n  mongodbLogComponentSeverities?: LogComponentSeveritiesClientOptions;\n  /**\n   * @public\n   * All BSON documents are stringified to EJSON. This controls the maximum length of those strings.\n   * It is defaulted to 1000.\n   */\n  mongodbLogMaxDocumentLength?: number;\n  /* Excluded from this release type: srvPoller */\n  /* Excluded from this release type: connectionType */\n  /* Excluded from this release type: __skipPingOnConnect */\n}\n\n/**\n * A representation of the credentials used by MongoDB\n * @public\n */\ndeclare class MongoCredentials {\n  /** The username used for authentication */\n  readonly username: string;\n  /** The password used for authentication */\n  readonly password: string;\n  /** The database that the user should authenticate against */\n  readonly source: string;\n  /** The method used to authenticate */\n  readonly mechanism: AuthMechanism;\n  /** Special properties used by some types of auth mechanisms */\n  readonly mechanismProperties: AuthMechanismProperties;\n  constructor(options: MongoCredentialsOptions);\n  /** Determines if two MongoCredentials objects are equivalent */\n  equals(other: MongoCredentials): boolean;\n  /**\n   * If the authentication mechanism is set to \"default\", resolves the authMechanism\n   * based on the server version and server supported sasl mechanisms.\n   *\n   * @param hello - A hello response from the server\n   */\n  resolveAuthMechanism(hello: Document_2 | null): MongoCredentials;\n  validate(): void;\n  static merge(creds: MongoCredentials | undefined, options: Partial<MongoCredentialsOptions>): MongoCredentials;\n}\n\n/** @public */\ndeclare interface MongoCredentialsOptions {\n  username?: string;\n  password: string;\n  source: string;\n  db?: string;\n  mechanism?: AuthMechanism;\n  mechanismProperties: AuthMechanismProperties;\n}\n\n/**\n * @public\n *\n * A class representing a collection's namespace.  This class enforces (through Typescript) that\n * the `collection` portion of the namespace is defined and should only be\n * used in scenarios where this can be guaranteed.\n */\ndeclare class MongoDBCollectionNamespace extends MongoDBNamespace {\n  collection: string;\n  constructor(db: string, collection: string);\n  static fromString(namespace?: string): MongoDBCollectionNamespace;\n}\n\n/**\n * @public\n *\n * A custom destination for structured logging messages.\n */\ndeclare interface MongoDBLogWritable {\n  /**\n   * This function will be called for every enabled log message.\n   *\n   * It can be sync or async:\n   * - If it is synchronous it will block the driver from proceeding until this method returns.\n   * - If it is asynchronous the driver will not await the returned promise. It will attach fulfillment handling (`.then`).\n   *   If the promise rejects the logger will write an error message to stderr and stop functioning.\n   *   If the promise resolves the driver proceeds to the next log message (or waits for new ones to occur).\n   *\n   * Tips:\n   * - We recommend writing an async `write` function that _never_ rejects.\n   *   Instead handle logging errors as necessary to your use case and make the write function a noop, until it can be recovered.\n   * - The Log messages are structured but **subject to change** since the intended purpose is informational.\n   *   Program against this defensively and err on the side of stringifying whatever is passed in to write in some form or another.\n   *\n   */\n  write(log: Log): PromiseLike<unknown> | unknown;\n}\n\n/** @public */\ndeclare class MongoDBNamespace {\n  db: string;\n  collection?: string | undefined;\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db: string, collection?: string | undefined);\n  toString(): string;\n  withCollection(collection: string): MongoDBCollectionNamespace;\n  static fromString(namespace?: string): MongoDBNamespace;\n}\n\n/** @public */\ndeclare interface MongoDBOIDCLogEventsMap {\n  'mongodb-oidc-plugin:deserialization-failed': (event: {\n    error: string;\n  }) => void;\n  'mongodb-oidc-plugin:state-updated': (event: {\n    updateId: number;\n    timerDuration: number | undefined;\n  }) => void;\n  'mongodb-oidc-plugin:local-redirect-accessed': (event: {\n    id: string;\n  }) => void;\n  'mongodb-oidc-plugin:oidc-callback-accepted': (event: {\n    method: string;\n    hasBody: boolean;\n    errorCode?: string;\n  }) => void;\n  'mongodb-oidc-plugin:oidc-callback-rejected': (event: {\n    method: string;\n    hasBody: boolean;\n    errorCode: string;\n    isAcceptedOIDCResponse: boolean;\n  }) => void;\n  'mongodb-oidc-plugin:unknown-url-accessed': (event: {\n    method: string;\n    path: string;\n  }) => void;\n  'mongodb-oidc-plugin:local-listen-started': (event: {\n    url: string;\n    urlPort: number;\n  }) => void;\n  'mongodb-oidc-plugin:local-listen-resolved-hostname': (event: {\n    url: string;\n    urlPort: number;\n    hostname: string;\n    interfaces: {\n      family: number;\n      address: string;\n    }[];\n  }) => void;\n  'mongodb-oidc-plugin:local-listen-failed': (event: {\n    url: string;\n    error: string;\n  }) => void;\n  'mongodb-oidc-plugin:local-listen-succeeded': (event: {\n    url: string;\n    interfaces: {\n      family: number;\n      address: string;\n    }[];\n  }) => void;\n  'mongodb-oidc-plugin:local-server-close': (event: {\n    url: string;\n  }) => void;\n  'mongodb-oidc-plugin:open-browser': (event: {\n    customOpener: boolean;\n  }) => void;\n  'mongodb-oidc-plugin:open-browser-complete': () => void;\n  'mongodb-oidc-plugin:notify-device-flow': () => void;\n  'mongodb-oidc-plugin:auth-attempt-started': (event: {\n    flow: string;\n  }) => void;\n  'mongodb-oidc-plugin:auth-attempt-succeeded': () => void;\n  'mongodb-oidc-plugin:auth-attempt-failed': (event: {\n    error: string;\n  }) => void;\n  'mongodb-oidc-plugin:refresh-skipped': (event: {\n    triggeringUpdateId: number;\n    expectedRefreshToken: string | null;\n    actualRefreshToken: string | null;\n  }) => void;\n  'mongodb-oidc-plugin:refresh-started': (event: {\n    triggeringUpdateId: number;\n    refreshToken: string | null;\n  }) => void;\n  'mongodb-oidc-plugin:refresh-succeeded': (event: {\n    triggeringUpdateId: number;\n    refreshToken: string | null;\n  }) => void;\n  'mongodb-oidc-plugin:refresh-failed': (event: {\n    error: string;\n    triggeringUpdateId: number;\n    refreshToken: string | null;\n  }) => void;\n  'mongodb-oidc-plugin:skip-auth-attempt': (event: {\n    reason: string;\n  }) => void;\n  'mongodb-oidc-plugin:auth-failed': (event: {\n    error: string;\n  }) => void;\n  'mongodb-oidc-plugin:auth-succeeded': (event: {\n    tokenType: string | null;\n    refreshToken: string | null;\n    expiresAt: string | null;\n    passIdTokenAsAccessToken: boolean;\n    tokens: {\n      accessToken: string | undefined;\n      idToken: string | undefined;\n      refreshToken: string | undefined;\n    };\n  }) => void;\n  'mongodb-oidc-plugin:destroyed': () => void;\n  'mongodb-oidc-plugin:missing-id-token': () => void;\n  'mongodb-oidc-plugin:outbound-http-request': (event: {\n    url: string;\n  }) => void;\n  'mongodb-oidc-plugin:inbound-http-request': (event: {\n    url: string;\n  }) => void;\n  'mongodb-oidc-plugin:received-server-params': (event: {\n    params: OIDCCallbackParams_2;\n  }) => void;\n}\n\n/** @public */\ndeclare interface MongoDBOIDCPlugin {\n  /**\n   * A subset of MongoClientOptions that need to be set in order\n   * for the MongoClient to an instance of this plugin.\n   *\n   * This object should be deep-merged with other, pre-existing\n   * MongoClient driver options.\n   *\n   * @public\n   */\n  readonly mongoClientOptions: MongoDBOIDCPluginMongoClientOptions;\n  /**\n   * The logger instance passed in the options, or a default one otherwise.\n   */\n  readonly logger: TypedEventEmitter_2<MongoDBOIDCLogEventsMap>;\n  /**\n   * Create a serialized representation of this plugin's state. The result\n   * can be stored and be later passed to new plugin instances to make\n   * that instance behave as a resumed version of this instance.\n   *\n   * Be aware that this string contains OIDC tokens in plaintext! Do not\n   * store it without appropriate security mechanisms in place.\n   */\n  serialize(): Promise<string>;\n  /**\n   * Destroy this plugin instance. Currently, this only clears timers\n   * for automatic token refreshing.\n   */\n  destroy(): Promise<void>;\n}\n\n/** @public */\ndeclare interface MongoDBOIDCPluginMongoClientOptions {\n  readonly authMechanismProperties: {\n    readonly OIDC_HUMAN_CALLBACK: OIDCCallbackFunction_2;\n  };\n}\n\n/** @public */\ndeclare interface MongoDBOIDCPluginOptions {\n  /**\n   * A local URL to listen on. If this is not provided, a default URL\n   * standardized for MongoDB applications is used.\n   *\n   * This is only used when the Authorization Code flow is enabled,\n   * and when it is possible to open a browser.\n   */\n  redirectURI?: string;\n  /**\n   * A function that opens an URL in a browser window. If this is `false`,\n   * then all flows involving automatic browser operation (currently\n   * Authorization Code flow) are disabled.\n   *\n   * If a `{ command: string }` object is provided, `command` will be spawned\n   * inside a shell and receive the target URL as an argument. If `abortable`\n   * is set, then a possible AbortSignal will be passed on and the child\n   * process will be killed once that is reached. (This does not typically\n   * make sense for GUI browsers, but can for command-line browsers.)\n   *\n   * If this option is missing or undefined, the default behavior is to use\n   * `shell.openExternal()` if this is running inside of electron, and\n   * the `open` package otherwise.\n   */\n  openBrowser?: undefined | false | {\n    command: string;\n    abortable?: boolean;\n  } | ((options: OpenBrowserOptions) => Promise<OpenBrowserReturnType>);\n  /**\n   * The maximum time that the plugin waits for an opened browser to access\n   * the URL that was passed to it, in milliseconds. The default is 10 seconds.\n   * Passing a value of zero will disable the timeout altogether.\n   */\n  openBrowserTimeout?: number;\n  /**\n   * A callback to provide users with the information required to operate\n   * the Device Authorization flow.\n   */\n  notifyDeviceFlow?: (information: DeviceFlowInformation) => Promise<void> | void;\n  /**\n   * Restrict possible OIDC authorization flows to a subset.\n   *\n   * The default value is `['auth-code']`, i.e. the Device Authorization Grant\n   * flow is not enabled by default and needs to be enabled explicitly.\n   *\n   * Order of the entries is not relevant. The Authorization Code Flow always\n   * takes precedence over the Device Authorization Grant flow.\n   *\n   * This can either be a static list of supported flows or a function which\n   * returns such a list. In the latter case, the function will be called\n   * for each authentication attempt. The AbortSignal argument can be used\n   * to get insight into when the auth attempt is being aborted, by the\n   * driver or through some other means. (For example, this callback\n   * could be used to inform a user about the fact that re-authentication\n   * is required, and reject if they decline to do so.)\n   */\n  allowedFlows?: AuthFlowType[] | ((options: {\n    signal: AbortSignal;\n  }) => Promise<AuthFlowType[]> | AuthFlowType[]);\n  /**\n   * An optional EventEmitter that can be used for recording log events.\n   */\n  logger?: TypedEventEmitter_2<MongoDBOIDCLogEventsMap>;\n  /**\n   * An AbortSignal that can be used to explicitly cancel authentication\n   * attempts, for example if a user intentionally aborts a connection\n   * attempt.\n   *\n   * Note that the driver also registers its own AbortSignal with individual\n   * authentication attempts in order to enforce a timeout, which has the\n   * same effect for authentication attempts from that driver MongoClient\n   * instance (but does not prevent other MongoClients from using this\n   * plugin instance to authenticate).\n   */\n  signal?: OIDCAbortSignal;\n  /**\n   * A custom handler for providing HTTP responses for requests to the\n   * redirect HTTP server used in the Authorization Code Flow.\n   *\n   * The default handler serves simple text/plain messages.\n   */\n  redirectServerRequestHandler?: RedirectServerRequestHandler;\n  /**\n   * A serialized representation of a previous plugin instance's state\n   * as returned by `.serialize()`.\n   *\n   * This option should only be passed if it comes from a trusted source,\n   * since it contains access tokens that will be sent to MongoDB servers.\n   */\n  serializedState?: string;\n  /**\n   * If set to true, creating the plugin will throw an exception when\n   * `serializedState` is provided but cannot be deserialized.\n   * If set to false, invalid serialized state will result in a log\n   * message being emitted but otherwise be ignored.\n   */\n  throwOnIncompatibleSerializedState?: boolean;\n  /**\n   * Provide custom HTTP options for individual HTTP calls.\n   */\n  customHttpOptions?: HttpOptions | ((url: string, options: Readonly<HttpOptions>) => HttpOptions);\n  /**\n   * Pass ID tokens in place of access tokens. For debugging/working around\n   * broken identity providers.\n   */\n  passIdTokenAsAccessToken?: boolean;\n  /**\n   * Skip the nonce parameter in the Authorization Code request. This could\n   * be used to work with providers that don't support the nonce parameter.\n   *\n   * Default is `false`.\n   */\n  skipNonceInAuthCodeRequest?: boolean;\n}\n\n/**\n * @public\n * @category Error\n *\n * @privateRemarks\n * mongodb-client-encryption has a dependency on this error, it uses the constructor with a string argument\n */\ndeclare class MongoError extends Error {\n  /* Excluded from this release type: errorLabelSet */\n  get errorLabels(): string[];\n  /**\n   * This is a number in MongoServerError and a string in MongoDriverError\n   * @privateRemarks\n   * Define the type override on the subclasses when we can use the override keyword\n   */\n  code?: number | string;\n  topologyVersion?: TopologyVersion;\n  connectionGeneration?: number;\n  cause?: Error;\n  /**\n   * **Do not use this constructor!**\n   *\n   * Meant for internal use only.\n   *\n   * @remarks\n   * This class is only meant to be constructed within the driver. This constructor is\n   * not subject to semantic versioning compatibility guarantees and may change at any time.\n   *\n   * @public\n   **/\n  constructor(message: string, options?: {\n    cause?: Error;\n  });\n  /* Excluded from this release type: buildErrorMessage */\n  get name(): string;\n  /** Legacy name for server error responses */\n  get errmsg(): string;\n  /**\n   * Checks the error to see if it has an error label\n   *\n   * @param label - The error label to check for\n   * @returns returns true if the error has the provided error label\n   */\n  hasErrorLabel(label: string): boolean;\n  addErrorLabel(label: string): void;\n}\n\n/** @public */\ndeclare const MongoLoggableComponent: Readonly<{\n  readonly COMMAND: \"command\";\n  readonly TOPOLOGY: \"topology\";\n  readonly SERVER_SELECTION: \"serverSelection\";\n  readonly CONNECTION: \"connection\";\n  readonly CLIENT: \"client\";\n}>;\n\n/** @public */\ndeclare type MongoLoggableComponent = (typeof MongoLoggableComponent)[keyof typeof MongoLoggableComponent];\n\n/**\n * Parsed Mongo Client Options.\n *\n * User supplied options are documented by `MongoClientOptions`.\n *\n * **NOTE:** The client's options parsing is subject to change to support new features.\n * This type is provided to aid with inspection of options after parsing, it should not be relied upon programmatically.\n *\n * Options are sourced from:\n * - connection string\n * - options object passed to the MongoClient constructor\n * - file system (ex. tls settings)\n * - environment variables\n * - DNS SRV records and TXT records\n *\n * Not all options may be present after client construction as some are obtained from asynchronous operations.\n *\n * @public\n */\ndeclare interface MongoOptions extends Required<Pick<MongoClientOptions, 'autoEncryption' | 'connectTimeoutMS' | 'directConnection' | 'driverInfo' | 'forceServerObjectId' | 'minHeartbeatFrequencyMS' | 'heartbeatFrequencyMS' | 'localThresholdMS' | 'maxConnecting' | 'maxIdleTimeMS' | 'maxPoolSize' | 'minPoolSize' | 'monitorCommands' | 'noDelay' | 'pkFactory' | 'raw' | 'replicaSet' | 'retryReads' | 'retryWrites' | 'serverSelectionTimeoutMS' | 'socketTimeoutMS' | 'srvMaxHosts' | 'srvServiceName' | 'tlsAllowInvalidCertificates' | 'tlsAllowInvalidHostnames' | 'tlsInsecure' | 'waitQueueTimeoutMS' | 'zlibCompressionLevel'>>, SupportedNodeConnectionOptions {\n  appName?: string;\n  hosts: HostAddress[];\n  srvHost?: string;\n  credentials?: MongoCredentials;\n  readPreference: ReadPreference;\n  readConcern: ReadConcern;\n  loadBalanced: boolean;\n  directConnection: boolean;\n  serverApi: ServerApi;\n  compressors: CompressorName[];\n  writeConcern: WriteConcern;\n  dbName: string;\n  metadata: ClientMetadata;\n  /* Excluded from this release type: extendedMetadata */\n  /* Excluded from this release type: autoEncrypter */\n  /* Excluded from this release type: tokenCache */\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n  serverMonitoringMode: ServerMonitoringMode;\n  /* Excluded from this release type: connectionType */\n  /* Excluded from this release type: authProviders */\n  /* Excluded from this release type: encrypter */\n  /* Excluded from this release type: userSpecifiedAuthSource */\n  /* Excluded from this release type: userSpecifiedReplicaSet */\n  /**\n   * # NOTE ABOUT TLS Options\n   *\n   * If `tls` is provided as an option, it is equivalent to setting the `ssl` option.\n   *\n   * NodeJS native TLS options are passed through to the socket and retain their original types.\n   *\n   * ### Additional options:\n   *\n   * | nodejs native option  | driver spec equivalent option name            | driver option type |\n   * |:----------------------|:----------------------------------------------|:-------------------|\n   * | `ca`                  | `tlsCAFile`                                   | `string`           |\n   * | `crl`                 | `tlsCRLFile`                                  | `string`           |\n   * | `cert`                | `tlsCertificateKeyFile`                       | `string`           |\n   * | `key`                 | `tlsCertificateKeyFile`                       | `string`           |\n   * | `passphrase`          | `tlsCertificateKeyFilePassword`               | `string`           |\n   * | `rejectUnauthorized`  | `tlsAllowInvalidCertificates`                 | `boolean`          |\n   * | `checkServerIdentity` | `tlsAllowInvalidHostnames`                    | `boolean`          |\n   * | see note below        | `tlsInsecure`                                 | `boolean`          |\n   *\n   * If `tlsInsecure` is set to `true`, then it will set the node native options `checkServerIdentity`\n   * to a no-op and `rejectUnauthorized` to `false`.\n   *\n   * If `tlsInsecure` is set to `false`, then it will set the node native options `checkServerIdentity`\n   * to a no-op and `rejectUnauthorized` to the inverse value of `tlsAllowInvalidCertificates`. If\n   * `tlsAllowInvalidCertificates` is not set, then `rejectUnauthorized` will be set to `true`.\n   *\n   * ### Note on `tlsCAFile`, `tlsCertificateKeyFile` and `tlsCRLFile`\n   *\n   * The files specified by the paths passed in to the `tlsCAFile`, `tlsCertificateKeyFile` and `tlsCRLFile`\n   * fields are read lazily on the first call to `MongoClient.connect`. Once these files have been read and\n   * the `ca`, `cert`, `crl` and `key` fields are populated, they will not be read again on subsequent calls to\n   * `MongoClient.connect`. As a result, until the first call to `MongoClient.connect`, the `ca`,\n   * `cert`, `crl` and `key` fields will be undefined.\n   */\n  tls: boolean;\n  tlsCAFile?: string;\n  tlsCRLFile?: string;\n  tlsCertificateKeyFile?: string;\n  /* Excluded from this release type: mongoLoggerOptions */\n  /* Excluded from this release type: mongodbLogPath */\n  timeoutMS?: number;\n  /* Excluded from this release type: __skipPingOnConnect */\n}\ndeclare interface MongoshBus {\n  on<K extends keyof MongoshBusEventsMap>(event: K, listener: MongoshBusEventsMap[K]): this;\n  once<K extends keyof MongoshBusEventsMap>(event: K, listener: MongoshBusEventsMap[K]): this;\n  emit<K extends keyof MongoshBusEventsMap>(event: K, ...args: MongoshBusEventsMap[K] extends ((...args: infer P) => any) ? P : never): unknown;\n}\ndeclare interface MongoshBusEventsMap extends ConnectEventMap {\n  'mongosh:connect': (ev: ConnectEvent) => void;\n  'mongosh:start-session': (ev: SessionStartedEvent) => void;\n  'mongosh:new-user': (identity: {\n    userId: string;\n    anonymousId: string;\n  }) => void;\n  'mongosh:update-user': (identity: {\n    userId: string;\n    anonymousId?: string;\n  }) => void;\n  'mongosh:error': (error: Error, component: string) => void;\n  'mongosh:evaluate-input': (ev: EvaluateInputEvent) => void;\n  'mongosh:evaluate-started': () => void;\n  'mongosh:evaluate-finished': () => void;\n  'mongosh:use': (ev: UseEvent) => void;\n  'mongosh:getDB': (ev: UseEvent) => void;\n  'mongosh:show': (ev: ShowEvent) => void;\n  'mongosh:setCtx': (ev: ApiEventWithArguments) => void;\n  'mongosh:api-call-with-arguments': (ev: ApiEventWithArguments) => void;\n  'mongosh:api-call': (ev: ApiEvent) => void;\n  'mongosh:warn': (ev: ApiWarning) => void;\n  'mongosh:api-load-file': (ev: ScriptLoadFileEvent) => void;\n  'mongosh:start-loading-cli-scripts': (event: StartLoadingCliScriptsEvent) => void;\n  'mongosh:write-custom-log': (ev: WriteCustomLogEvent) => void;\n  'mongosh:start-mongosh-repl': (ev: StartMongoshReplEvent) => void;\n  'mongosh:mongoshrc-load': () => void;\n  'mongosh:globalconfig-load': (ev: GlobalConfigFileLoadEvent) => void;\n  'mongosh:mongoshrc-mongorc-warn': () => void;\n  'mongosh:eval-cli-script': () => void;\n  'mongosh:eval-interrupted': () => void;\n  'mongosh:crypt-library-load-skip': (ev: CryptLibrarySkipEvent) => void;\n  'mongosh:crypt-library-load-found': (ev: CryptLibraryFoundEvent) => void;\n  'mongosh:closed': () => void;\n  'mongosh:eval-complete': () => void;\n  'mongosh:autocompletion-complete': () => void;\n  'mongosh:interrupt-complete': () => void;\n  'mongosh-snippets:loaded': (ev: SnippetsLoadedEvent) => void;\n  'mongosh-snippets:npm-lookup': (ev: SnippetsNpmLookupEvent) => void;\n  'mongosh-snippets:npm-lookup-stopped': () => void;\n  'mongosh-snippets:npm-download-failed': (ev: SnippetsNpmDownloadFailedEvent) => void;\n  'mongosh-snippets:npm-download-active': (ev: SnippetsNpmDownloadActiveEvent) => void;\n  'mongosh-snippets:fetch-index': (ev: SnippetsFetchIndexEvent) => void;\n  'mongosh-snippets:fetch-cache-invalid': () => void;\n  'mongosh-snippets:fetch-index-error': (ev: SnippetsFetchIndexErrorEvent) => void;\n  'mongosh-snippets:fetch-index-done': () => void;\n  'mongosh-snippets:package-json-edit-error': (ev: SnippetsErrorEvent) => void;\n  'mongosh-snippets:spawn-child': (ev: SnippetsRunNpmEvent) => void;\n  'mongosh-snippets:load-snippet': (ev: SnippetsLoadSnippetEvent) => void;\n  'mongosh-snippets:snippet-command': (ev: SnippetsCommandEvent) => void;\n  'mongosh-snippets:transform-error': (ev: SnippetsTransformErrorEvent) => void;\n  'mongosh-sp:reset-connection-options': () => void;\n  'mongosh-editor:run-edit-command': (ev: EditorRunEditCommandEvent) => void;\n  'mongosh-editor:read-vscode-extensions-done': (ev: EditorReadVscodeExtensionsDoneEvent) => void;\n  'mongosh-editor:read-vscode-extensions-failed': (ev: EditorReadVscodeExtensionsFailedEvent) => void;\n  'mongosh:fetching-update-metadata': (ev: FetchingUpdateMetadataEvent) => void;\n  'mongosh:fetching-update-metadata-complete': (ev: FetchingUpdateMetadataCompleteEvent) => void;\n  'mongosh:log-initialized': () => void;\n}\nexport declare interface Namespace {\n  db: string;\n  collection: string;\n}\ndeclare const namespaceInfo: unique symbol;\n\n/**\n * @public\n * A type that extends Document but forbids anything that \"looks like\" an object id.\n */\ndeclare type NonObjectIdLikeDocument = { [key in keyof ObjectIdLike]?: never } & Document_2;\n\n/** It avoids using fields with not acceptable types @public */\ndeclare type NotAcceptedFields<TSchema, FieldType> = { readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never };\n\n/** @public */\ndeclare type NumericType = IntegerType | Decimal128 | Double;\n\n/**\n * A class representation of the BSON ObjectId type.\n * @public\n * @category BSONType\n */\ndeclare class ObjectId extends BSONValue {\n  get _bsontype(): 'ObjectId';\n  /* Excluded from this release type: index */\n  static cacheHexString: boolean;\n  /* Excluded from this release type: buffer */\n  /**\n   * Create ObjectId from a number.\n   *\n   * @param inputId - A number.\n   * @deprecated Instead, use `static createFromTime()` to set a numeric value for the new ObjectId.\n   */\n  constructor(inputId: number);\n  /**\n   * Create ObjectId from a 24 character hex string.\n   *\n   * @param inputId - A 24 character hex string.\n   */\n  constructor(inputId: string);\n  /**\n   * Create ObjectId from the BSON ObjectId type.\n   *\n   * @param inputId - The BSON ObjectId type.\n   */\n  constructor(inputId: ObjectId);\n  /**\n   * Create ObjectId from the object type that has the toHexString method.\n   *\n   * @param inputId - The ObjectIdLike type.\n   */\n  constructor(inputId: ObjectIdLike);\n  /**\n   * Create ObjectId from a 12 byte binary Buffer.\n   *\n   * @param inputId - A 12 byte binary Buffer.\n   */\n  constructor(inputId: Uint8Array);\n  /** To generate a new ObjectId, use ObjectId() with no argument. */\n  constructor();\n  /**\n   * Implementation overload.\n   *\n   * @param inputId - All input types that are used in the constructor implementation.\n   */\n  constructor(inputId?: string | number | ObjectId | ObjectIdLike | Uint8Array);\n  /**\n   * The ObjectId bytes\n   * @readonly\n   */\n  get id(): Uint8Array;\n  set id(value: Uint8Array);\n  /* Excluded from this release type: validateHexString */\n  /** Returns the ObjectId id as a 24 lowercase character hex string representation */\n  toHexString(): string;\n  /* Excluded from this release type: getInc */\n  /**\n   * Generate a 12 byte id buffer used in ObjectId's\n   *\n   * @param time - pass in a second based timestamp.\n   */\n  static generate(time?: number): Uint8Array;\n  /**\n   * Converts the id into a 24 character hex string for printing, unless encoding is provided.\n   * @param encoding - hex or base64\n   */\n  toString(encoding?: 'hex' | 'base64'): string;\n  /** Converts to its JSON the 24 character hex string representation. */\n  toJSON(): string;\n  /* Excluded from this release type: is */\n  /**\n   * Compares the equality of this ObjectId with `otherID`.\n   *\n   * @param otherId - ObjectId instance to compare against.\n   */\n  equals(otherId: string | ObjectId | ObjectIdLike | undefined | null): boolean;\n  /** Returns the generation date (accurate up to the second) that this ID was generated. */\n  getTimestamp(): Date;\n  /* Excluded from this release type: createPk */\n  /* Excluded from this release type: serializeInto */\n  /**\n   * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\n   *\n   * @param time - an integer number representing a number of seconds.\n   */\n  static createFromTime(time: number): ObjectId;\n  /**\n   * Creates an ObjectId from a hex string representation of an ObjectId.\n   *\n   * @param hexString - create a ObjectId from a passed in 24 character hexstring.\n   */\n  static createFromHexString(hexString: string): ObjectId;\n  /** Creates an ObjectId instance from a base64 string */\n  static createFromBase64(base64: string): ObjectId;\n  /**\n   * Checks if a value can be used to create a valid bson ObjectId\n   * @param id - any JS value\n   */\n  static isValid(id: string | number | ObjectId | ObjectIdLike | Uint8Array): boolean;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  /* Excluded from this release type: isCached */\n  /**\n   * Converts to a string representation of this Id.\n   *\n   * @returns return the 24 character hex string representation.\n   */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface ObjectIdLike {\n  id: string | Uint8Array;\n  __id?: string;\n  toHexString(): string;\n}\n\n/** @public */\ndeclare type OIDCAbortSignal = {\n  aborted: boolean;\n  reason?: unknown;\n  addEventListener(type: 'abort', callback: () => void, options?: {\n    once: boolean;\n  }): void;\n  removeEventListener(type: 'abort', callback: () => void): void;\n};\n\n/**\n * The signature of the human or machine callback functions.\n * @public\n */\ndeclare type OIDCCallbackFunction = (params: OIDCCallbackParams) => Promise<OIDCResponse>;\n\n/**\n * A copy of the Node.js driver's `OIDCRefreshFunction`\n * @public\n */\ndeclare type OIDCCallbackFunction_2 = (params: OIDCCallbackParams_2) => Promise<IdPServerResponse>;\n\n/**\n * The parameters that the driver provides to the user supplied\n * human or machine callback.\n *\n * The version number is used to communicate callback API changes that are not breaking but that\n * users may want to know about and review their implementation. Users may wish to check the version\n * number and throw an error if their expected version number and the one provided do not match.\n * @public\n */\ndeclare interface OIDCCallbackParams {\n  /** Optional username. */\n  username?: string;\n  /** The context in which to timeout the OIDC callback. */\n  timeoutContext: AbortSignal;\n  /** The current OIDC API version. */\n  version: 1;\n  /** The IdP information returned from the server. */\n  idpInfo?: IdPInfo;\n  /** The refresh token, if applicable, to be used by the callback to request a new token from the issuer. */\n  refreshToken?: string;\n}\n\n/**\n * A copy of the Node.js driver's `OIDCCallbackParams` using `OIDCAbortSignal` instead of `AbortSignal`\n * @public\n */\ndeclare interface OIDCCallbackParams_2 {\n  refreshToken?: string;\n  timeoutContext?: OIDCAbortSignal;\n  version: 1;\n  username?: string;\n  idpInfo?: IdPServerInfo;\n}\n\n/**\n * The response required to be returned from the machine or\n * human callback workflows' callback.\n * @public\n */\ndeclare interface OIDCResponse {\n  /** The OIDC access token. */\n  accessToken: string;\n  /** The time when the access token expires. For future use. */\n  expiresInSeconds?: number;\n  /** The refresh token, if applicable, to be used by the callback to request a new token from the issuer. */\n  refreshToken?: string;\n}\n\n/** @public */\ndeclare type OneOrMore<T> = T | ReadonlyArray<T>;\nexport declare interface OnLoadResult {\n  resolvedFilename: string;\n  evaluate(): Promise<void>;\n}\n\n/** @public */\ndeclare type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = IsAny<TSchema[keyof TSchema], AssignableType extends FieldType ? Record<string, FieldType> : Record<string, AssignableType>, AcceptedFields<TSchema, FieldType, AssignableType> & NotAcceptedFields<TSchema, FieldType> & Record<string, AssignableType>>;\n\n/** @public */\ndeclare interface OpenBrowserOptions {\n  /**\n   * The URL to open the browser with.\n   */\n  url: string;\n  /**\n   * A signal that is aborted when the user or the driver abort\n   * an authentication attempt.\n   */\n  signal: AbortSignal;\n}\n\n/** @public */\ndeclare type OpenBrowserReturnType = void | undefined | (TypedEventEmitter_2<{\n  exit(exitCode: number): void;\n  error(err: unknown): void;\n}> & {\n  spawnargs?: string[];\n});\n\n/** @public */\ndeclare interface OperationOptions extends BSONSerializeOptions {\n  /** Specify ClientSession for this command */\n  session?: ClientSession;\n  willRetryWrite?: boolean;\n  /** The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest). */\n  readPreference?: ReadPreferenceLike;\n  /* Excluded from this release type: bypassPinningCheck */\n  omitReadPreference?: boolean;\n  /* Excluded from this release type: omitMaxTimeMS */\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n}\n\n/**\n * Represents a specific point in time on a server. Can be retrieved by using `db.command()`\n * @public\n * @see https://www.mongodb.com/docs/manual/reference/method/db.runCommand/#response\n */\ndeclare type OperationTime = Timestamp;\n\n/**\n * Add an optional _id field to an object shaped type\n * @public\n */\ndeclare type OptionalId<TSchema> = EnhancedOmit<TSchema, '_id'> & {\n  _id?: InferIdType<TSchema>;\n};\n\n/**\n * Adds an optional _id field to an object shaped type, unless the _id field is required on that type.\n * In the case _id is required, this method continues to require_id.\n *\n * @public\n *\n * @privateRemarks\n * `ObjectId extends TSchema['_id']` is a confusing ordering at first glance. Rather than ask\n * `TSchema['_id'] extends ObjectId` which translated to \"Is the _id property ObjectId?\"\n * we instead ask \"Does ObjectId look like (have the same shape) as the _id?\"\n */\ndeclare type OptionalUnlessRequiredId<TSchema> = TSchema extends {\n  _id: any;\n} ? TSchema : OptionalId<TSchema>;\n\n/** @public */\ndeclare class OrderedBulkOperation extends BulkOperationBase {\n  /* Excluded from this release type: __constructor */\n  addToOperationsList(batchType: BatchType, document: Document_2 | UpdateStatement | DeleteStatement): this;\n}\n\n/** @public */\ndeclare interface PkFactory {\n  createPk(): any;\n}\ndeclare class PlanCache extends ShellApiWithMongoClass {\n  _collection: Collection;\n  constructor(collection: Collection);\n  get _mongo(): Mongo;\n  [asPrintable](): string;\n  clear(): Document_2;\n  clearPlansByQuery(query: Document_2, projection?: Document_2, sort?: Document_2): Document_2;\n  list(pipeline?: Document_2[]): Document_2[];\n  listQueryShapes(): never;\n  getPlansByQuery(): never;\n}\n\n/** @public */\ndeclare const ProfilingLevel: Readonly<{\n  readonly off: \"off\";\n  readonly slowOnly: \"slow_only\";\n  readonly all: \"all\";\n}>;\n\n/** @public */\ndeclare type ProfilingLevel = (typeof ProfilingLevel)[keyof typeof ProfilingLevel];\n\n/** @public */\ndeclare type ProfilingLevelOptions = CommandOperationOptions;\ndeclare type ProxyEventArgs<K extends keyof ProxyEventMap> = ProxyEventMap[K] extends ((...args: infer P) => any) ? P : never;\ndeclare interface ProxyEventMap {\n  'socks5:authentication-complete': (ev: {\n    success: boolean;\n  }) => void;\n  'socks5:skip-auth-setup': () => void;\n  'socks5:start-listening': (ev: {\n    proxyHost: string;\n    proxyPort: number;\n  }) => void;\n  'socks5:forwarding-error': (ev: {\n    error: string;\n  } & Partial<BaseSocks5RequestMetadata>) => void;\n  'socks5:agent-initialized': () => void;\n  'socks5:closing-tunnel': () => void;\n  'socks5:got-forwarding-request': (ev: BaseSocks5RequestMetadata) => void;\n  'socks5:accepted-forwarding-request': (ev: BaseSocks5RequestMetadata) => void;\n  'socks5:failed-forwarding-request': (ev: {\n    error: string;\n  } & Partial<BaseSocks5RequestMetadata>) => void;\n  'socks5:forwarded-socket-closed': (ev: BaseSocks5RequestMetadata) => void;\n  'ssh:client-closed': () => void;\n  'ssh:establishing-conection': (ev: {\n    host: string | undefined;\n    port: number | undefined;\n    password: boolean;\n    passphrase: boolean;\n    privateKey: boolean;\n  }) => void;\n  'ssh:failed-connection': (ev: {\n    error: string;\n  }) => void;\n  'ssh:established-connection': () => void;\n  'ssh:failed-forward': (ev: {\n    error: string;\n    host: string;\n    retryableError: boolean;\n    retriesLeft: number;\n  }) => void;\n}\ndeclare interface ProxyLogEmitter {\n  on<K extends keyof ProxyEventMap>(event: K, listener: ProxyEventMap[K]): this;\n  off?<K extends keyof ProxyEventMap>(event: K, listener: ProxyEventMap[K]): this;\n  once<K extends keyof ProxyEventMap>(event: K, listener: ProxyEventMap[K]): this;\n  emit<K extends keyof ProxyEventMap>(event: K, ...args: ProxyEventArgs<K>): unknown;\n}\n\n/** @public */\ndeclare interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\ndeclare type PullAllOperator<TSchema> = ({ readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key] } & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: ReadonlyArray<any>;\n};\n\n/** @public */\ndeclare type PullOperator<TSchema> = ({ readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: Partial<Flatten<TSchema[key]>> | FilterOperations<Flatten<TSchema[key]>> } & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: FilterOperators<any> | any;\n};\n\n/** @public */\ndeclare type PushOperator<TSchema> = ({ readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: Flatten<TSchema[key]> | ArrayOperator<Array<Flatten<TSchema[key]>>> } & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: ArrayOperator<any> | any;\n};\n\n/**\n * @public\n * RangeOptions specifies index options for a Queryable Encryption field supporting \"range\" queries.\n * min, max, sparsity, trimFactor and range must match the values set in the encryptedFields of the destination collection.\n * For double and decimal128, min/max/precision must all be set, or all be unset.\n */\ndeclare interface RangeOptions {\n  /** min is the minimum value for the encrypted index. Required if precision is set. */\n  min?: any;\n  /** max is the minimum value for the encrypted index. Required if precision is set. */\n  max?: any;\n  /** sparsity may be used to tune performance. must be non-negative. When omitted, a default value is used. */\n  sparsity?: Long | bigint;\n  /** trimFactor may be used to tune performance. must be non-negative. When omitted, a default value is used. */\n  trimFactor?: Int32 | number;\n  precision?: number;\n}\ndeclare interface Readable_2 {\n  aggregate(database: string, collection: string, pipeline: Document_2[], options?: AggregateOptions, dbOptions?: DbOptions): ServiceProviderAggregationCursor;\n  aggregateDb(database: string, pipeline: Document_2[], options?: AggregateOptions, dbOptions?: DbOptions): ServiceProviderAggregationCursor;\n  count(db: string, coll: string, query?: Document_2, options?: CountOptions, dbOptions?: DbOptions): Promise<number>;\n  countDocuments(database: string, collection: string, filter?: Document_2, options?: CountDocumentsOptions, dbOptions?: DbOptions): Promise<number>;\n  distinct(database: string, collection: string, fieldName: string, filter?: Document_2, options?: DistinctOptions, dbOptions?: DbOptions): Promise<Document_2>;\n  estimatedDocumentCount(database: string, collection: string, options?: EstimatedDocumentCountOptions, dbOptions?: DbOptions): Promise<number>;\n  find(database: string, collection: string, filter?: Document_2, options?: FindOptions, dbOptions?: DbOptions): ServiceProviderFindCursor;\n  getTopology(): any;\n  getIndexes(database: string, collection: string, options: ListIndexesOptions, dbOptions?: DbOptions): Promise<Document_2[]>;\n  listCollections(database: string, filter?: Document_2, options?: ListCollectionsOptions, dbOptions?: DbOptions): Promise<Document_2[]>;\n  readPreferenceFromOptions(options?: Omit<ReadPreferenceFromOptions, 'session'>): ReadPreferenceLike | undefined;\n  watch(pipeline: Document_2[], options: ChangeStreamOptions, dbOptions?: DbOptions, db?: string, coll?: string): ServiceProviderChangeStream;\n  getSearchIndexes(database: string, collection: string, indexName?: string, options?: Document_2, dbOptions?: DbOptions): Promise<Document_2[]>;\n}\n\n/**\n * The MongoDB ReadConcern, which allows for control of the consistency and isolation properties\n * of the data read from replica sets and replica set shards.\n * @public\n *\n * @see https://www.mongodb.com/docs/manual/reference/read-concern/index.html\n */\ndeclare class ReadConcern {\n  level: ReadConcernLevel | string;\n  /** Constructs a ReadConcern from the read concern level.*/\n  constructor(level: ReadConcernLevel);\n  /**\n   * Construct a ReadConcern given an options object.\n   *\n   * @param options - The options object from which to extract the write concern.\n   */\n  static fromOptions(options?: {\n    readConcern?: ReadConcernLike;\n    level?: ReadConcernLevel;\n  }): ReadConcern | undefined;\n  static get MAJORITY(): 'majority';\n  static get AVAILABLE(): 'available';\n  static get LINEARIZABLE(): 'linearizable';\n  static get SNAPSHOT(): 'snapshot';\n  toJSON(): Document_2;\n}\n\n/** @public */\ndeclare const ReadConcernLevel: Readonly<{\n  readonly local: \"local\";\n  readonly majority: \"majority\";\n  readonly linearizable: \"linearizable\";\n  readonly available: \"available\";\n  readonly snapshot: \"snapshot\";\n}>;\n\n/** @public */\ndeclare type ReadConcernLevel = (typeof ReadConcernLevel)[keyof typeof ReadConcernLevel];\n\n/** @public */\ndeclare type ReadConcernLike = ReadConcern | {\n  level: ReadConcernLevel;\n} | ReadConcernLevel;\n\n/**\n * The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is\n * used to construct connections.\n * @public\n *\n * @see https://www.mongodb.com/docs/manual/core/read-preference/\n */\ndeclare class ReadPreference {\n  mode: ReadPreferenceMode;\n  tags?: TagSet[];\n  hedge?: HedgeOptions;\n  maxStalenessSeconds?: number;\n  minWireVersion?: number;\n  static PRIMARY: \"primary\";\n  static PRIMARY_PREFERRED: \"primaryPreferred\";\n  static SECONDARY: \"secondary\";\n  static SECONDARY_PREFERRED: \"secondaryPreferred\";\n  static NEAREST: \"nearest\";\n  static primary: ReadPreference;\n  static primaryPreferred: ReadPreference;\n  static secondary: ReadPreference;\n  static secondaryPreferred: ReadPreference;\n  static nearest: ReadPreference;\n  /**\n   * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)\n   * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.\n   * @param options - Additional read preference options\n   */\n  constructor(mode: ReadPreferenceMode, tags?: TagSet[], options?: ReadPreferenceOptions);\n  get preference(): ReadPreferenceMode;\n  static fromString(mode: string): ReadPreference;\n  /**\n   * Construct a ReadPreference given an options object.\n   *\n   * @param options - The options object from which to extract the read preference.\n   */\n  static fromOptions(options?: ReadPreferenceFromOptions): ReadPreference | undefined;\n  /**\n   * Replaces options.readPreference with a ReadPreference instance\n   */\n  static translate(options: ReadPreferenceLikeOptions): ReadPreferenceLikeOptions;\n  /**\n   * Validate if a mode is legal\n   *\n   * @param mode - The string representing the read preference mode.\n   */\n  static isValid(mode: string): boolean;\n  /**\n   * Validate if a mode is legal\n   *\n   * @param mode - The string representing the read preference mode.\n   */\n  isValid(mode?: string): boolean;\n  /**\n   * Indicates that this readPreference needs the \"SecondaryOk\" bit when sent over the wire\n   * @see https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#op-query\n   */\n  secondaryOk(): boolean;\n  /**\n   * Check if the two ReadPreferences are equivalent\n   *\n   * @param readPreference - The read preference with which to check equality\n   */\n  equals(readPreference: ReadPreference): boolean;\n  /** Return JSON representation */\n  toJSON(): Document_2;\n}\n\n/** @public */\ndeclare interface ReadPreferenceFromOptions extends ReadPreferenceLikeOptions {\n  session?: ClientSession;\n  readPreferenceTags?: TagSet[];\n  hedge?: HedgeOptions;\n}\n\n/** @public */\ndeclare type ReadPreferenceLike = ReadPreference | ReadPreferenceMode;\n\n/** @public */\ndeclare interface ReadPreferenceLikeOptions extends ReadPreferenceOptions {\n  readPreference?: ReadPreferenceLike | {\n    mode?: ReadPreferenceMode;\n    preference?: ReadPreferenceMode;\n    tags?: TagSet[];\n    maxStalenessSeconds?: number;\n  };\n}\n\n/** @public */\ndeclare const ReadPreferenceMode: Readonly<{\n  readonly primary: \"primary\";\n  readonly primaryPreferred: \"primaryPreferred\";\n  readonly secondary: \"secondary\";\n  readonly secondaryPreferred: \"secondaryPreferred\";\n  readonly nearest: \"nearest\";\n}>;\n\n/** @public */\ndeclare type ReadPreferenceMode = (typeof ReadPreferenceMode)[keyof typeof ReadPreferenceMode];\n\n/** @public */\ndeclare interface ReadPreferenceOptions {\n  /** Max secondary read staleness in seconds, Minimum value is 90 seconds.*/\n  maxStalenessSeconds?: number;\n  /** Server mode in which the same query is dispatched in parallel to multiple replica set members. */\n  hedge?: HedgeOptions;\n}\n\n/** @public */\ndeclare type RedirectServerRequestHandler = (data: RedirectServerRequestInfo) => void;\n\n/** @public */\ndeclare type RedirectServerRequestInfo = {\n  /** The incoming HTTP request. */\n  req: IncomingMessage;\n  /** The outgoing HTTP response. */\n  res: ServerResponse;\n  /** The suggested HTTP status code. For unknown-url, this is 404. */\n  status: number;\n} & ({\n  result: 'redirecting';\n  location: string;\n} | {\n  result: 'rejected';\n  /** Error information reported by the IdP as defined in RFC6749 section 4.1.2.1 */\n  error?: string;\n  /** Error information reported by the IdP as defined in RFC6749 section 4.1.2.1 */\n  errorDescription?: string;\n  /** Error information reported by the IdP as defined in RFC6749 section 4.1.2.1 */\n  errorURI?: string;\n} | {\n  result: 'accepted';\n} | {\n  result: 'unknown-url';\n});\n\n/** @public */\ndeclare type RegExpOrString<T> = T extends string ? BSONRegExp | RegExp | T : T;\nexport declare type RemoveShellOptions = DeleteOptions & {\n  justOne?: boolean;\n};\n\n/** @public */\ndeclare type RemoveUserOptions = CommandOperationOptions;\n\n/** @public */\ndeclare interface RenameOptions extends CommandOperationOptions {\n  /** Drop the target name collection if it previously exists. */\n  dropTarget?: boolean;\n  /** Unclear */\n  new_collection?: boolean;\n}\n\n/** @public */\ndeclare interface ReplaceOneModel<TSchema extends Document_2 = Document_2> {\n  /** The filter to limit the replaced document. */\n  filter: Filter<TSchema>;\n  /** The document with which to replace the matched document. */\n  replacement: WithoutId<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\ndeclare interface ReplaceOptions extends CommandOperationOptions {\n  /** If true, allows the write to opt-out of document level validation */\n  bypassDocumentValidation?: boolean;\n  /** Specifies a collation */\n  collation?: CollationOptions;\n  /** Specify that the update query should only consider plans using the hinted index */\n  hint?: string | Document_2;\n  /** When true, creates a new document if no document matches the query */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n}\nexport declare class ReplicaSet<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema> extends ShellApiWithMongoClass {\n  _database: Database<M, D>;\n  constructor(database: Database<M, D>);\n  get _mongo(): Mongo<M>;\n  initiate(config?: Partial<ReplSetConfig>): Document_2;\n  _getConfig(): Promise<ReplSetConfig>;\n  config(): ReplSetConfig;\n  conf(): ReplSetConfig;\n  reconfig(config: Partial<ReplSetConfig>, options?: {}): Document_2;\n  reconfigForPSASet(newMemberIndex: number, config: Partial<ReplSetConfig>, options?: {}): Document_2;\n  status(): Document_2;\n  isMaster(): Document_2;\n  hello(): Document_2;\n  printSecondaryReplicationInfo(): CommandResult;\n  printSlaveReplicationInfo(): never;\n  printReplicationInfo(): CommandResult;\n  add(hostport: string | Partial<ReplSetMemberConfig>, arb?: boolean): Document_2;\n  addArb(hostname: string): Document_2;\n  remove(hostname: string): Document_2;\n  freeze(secs: number): Document_2;\n  stepDown(stepdownSecs?: number, catchUpSecs?: number): Document_2;\n  syncFrom(host: string): Document_2;\n  secondaryOk(): void;\n  [asPrintable](): string;\n  private _emitReplicaSetApiCall;\n}\ndeclare type ReplPlatform = 'CLI' | 'Browser' | 'Compass' | 'JavaShell';\ndeclare type ReplSetConfig = {\n  version: number;\n  _id: string;\n  members: ReplSetMemberConfig[];\n  protocolVersion: number;\n};\ndeclare type ReplSetMemberConfig = {\n  _id: number;\n  host: string;\n  priority?: number;\n  votes?: number;\n  arbiterOnly?: boolean;\n};\n\n/**\n * Represents the logical starting point for a new ChangeStream or resuming a ChangeStream on the server.\n * @see https://www.mongodb.com/docs/manual/changeStreams/#std-label-change-stream-resume\n * @public\n */\ndeclare type ResumeToken = unknown;\n\n/** @public */\ndeclare const ReturnDocument: Readonly<{\n  readonly BEFORE: \"before\";\n  readonly AFTER: \"after\";\n}>;\n\n/** @public */\ndeclare type ReturnDocument = (typeof ReturnDocument)[keyof typeof ReturnDocument];\n\n/** @public */\ndeclare interface RootFilterOperators<TSchema> extends Document_2 {\n  $and?: Filter<TSchema>[];\n  $nor?: Filter<TSchema>[];\n  $or?: Filter<TSchema>[];\n  $text?: {\n    $search: string;\n    $language?: string;\n    $caseSensitive?: boolean;\n    $diacriticSensitive?: boolean;\n  };\n  $where?: string | ((this: TSchema) => boolean);\n  $comment?: string | Document_2;\n}\nexport declare class RunCommandCursor extends AbstractCursor_2<ServiceProviderRunCommandCursor> {\n  constructor(mongo: Mongo, cursor: ServiceProviderRunCommandCursor);\n}\n\n/** @public */\ndeclare class RunCommandCursor_2 extends AbstractCursor {\n  readonly command: Readonly<Record<string, any>>;\n  readonly getMoreOptions: {\n    comment?: any;\n    maxAwaitTimeMS?: number;\n    batchSize?: number;\n  };\n  /**\n   * Controls the `getMore.comment` field\n   * @param comment - any BSON value\n   */\n  setComment(comment: any): this;\n  /**\n   * Controls the `getMore.maxTimeMS` field. Only valid when cursor is tailable await\n   * @param maxTimeMS - the number of milliseconds to wait for new data\n   */\n  setMaxTimeMS(maxTimeMS: number): this;\n  /**\n   * Controls the `getMore.batchSize` field\n   * @param batchSize - the number documents to return in the `nextBatch`\n   */\n  setBatchSize(batchSize: number): this;\n  /** Unsupported for RunCommandCursor */\n  clone(): never;\n  /** Unsupported for RunCommandCursor: readConcern must be configured directly on command document */\n  withReadConcern(_: ReadConcernLike): never;\n  /** Unsupported for RunCommandCursor: various cursor flags must be configured directly on command document */\n  addCursorFlag(_: string, __: boolean): never;\n  /**\n   * Unsupported for RunCommandCursor: maxTimeMS must be configured directly on command document\n   */\n  maxTimeMS(_: number): never;\n  /** Unsupported for RunCommandCursor: batchSize must be configured directly on command document */\n  batchSize(_: number): never;\n  /* Excluded from this release type: db */\n  /* Excluded from this release type: __constructor */\n  /* Excluded from this release type: _initialize */\n  /* Excluded from this release type: getMore */\n}\n\n/** @public */\ndeclare type RunCommandOptions = {\n  /** Specify ClientSession for this command */\n  session?: ClientSession;\n  /** The read preference */\n  readPreference?: ReadPreferenceLike;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error\n   */\n  timeoutMS?: number;\n  /* Excluded from this release type: omitMaxTimeMS */\n} & BSONSerializeOptions;\n\n/** @public */\ndeclare type RunCursorCommandOptions = {\n  readPreference?: ReadPreferenceLike;\n  session?: ClientSession;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error. Note that if\n   * `maxTimeMS` is provided in the command in addition to setting `timeoutMS` in the options, then\n   * the original value of `maxTimeMS` will be overwritten.\n   */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n  tailable?: boolean;\n  awaitData?: boolean;\n} & BSONSerializeOptions;\ndeclare interface ScriptLoadFileEvent {\n  nested: boolean;\n  filename: string;\n}\ndeclare type SearchIndexDefinition = Document_2;\n\n/**\n * @public\n */\ndeclare interface SearchIndexDescription extends Document_2 {\n  /** The name of the index. */\n  name?: string;\n  /** The index definition. */\n  definition: Document_2;\n  /** The type of the index.  Currently `search` or `vectorSearch` are supported. */\n  type?: string;\n}\n\n/** @public */\ndeclare interface SerializeOptions {\n  /**\n   * the serializer will check if keys are valid.\n   * @defaultValue `false`\n   */\n  checkKeys?: boolean;\n  /**\n   * serialize the javascript functions\n   * @defaultValue `false`\n   */\n  serializeFunctions?: boolean;\n  /**\n   * serialize will not emit undefined fields\n   * note that the driver sets this to `false`\n   * @defaultValue `true`\n   */\n  ignoreUndefined?: boolean;\n  /* Excluded from this release type: minInternalBufferSize */\n  /**\n   * the index in the buffer where we wish to start serializing into\n   * @defaultValue `0`\n   */\n  index?: number;\n}\n\n/** @public */\ndeclare interface ServerApi {\n  version: ServerApiVersion;\n  strict?: boolean;\n  deprecationErrors?: boolean;\n}\n\n/** @public */\ndeclare const ServerApiVersion: Readonly<{\n  readonly v1: \"1\";\n}>;\n\n/** @public */\ndeclare type ServerApiVersion = (typeof ServerApiVersion)[keyof typeof ServerApiVersion];\n\n/**\n * Emitted when server is closed.\n * @public\n * @category Event\n */\ndeclare class ServerClosedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The address (host/port pair) of the server */\n  address: string;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\ndeclare class ServerDescription {\n  address: string;\n  type: ServerType;\n  hosts: string[];\n  passives: string[];\n  arbiters: string[];\n  tags: TagSet;\n  error: MongoError | null;\n  topologyVersion: TopologyVersion | null;\n  minWireVersion: number;\n  maxWireVersion: number;\n  roundTripTime: number;\n  /** The minimum measurement of the last 10 measurements of roundTripTime that have been collected */\n  minRoundTripTime: number;\n  lastUpdateTime: number;\n  lastWriteDate: number;\n  me: string | null;\n  primary: string | null;\n  setName: string | null;\n  setVersion: number | null;\n  electionId: ObjectId | null;\n  logicalSessionTimeoutMinutes: number | null;\n  /** The max message size in bytes for the server. */\n  maxMessageSizeBytes: number | null;\n  /** The max number of writes in a bulk write command. */\n  maxWriteBatchSize: number | null;\n  /** The max bson object size. */\n  maxBsonObjectSize: number | null;\n  /** Indicates server is a mongocryptd instance. */\n  iscryptd: boolean;\n  $clusterTime?: ClusterTime;\n  /* Excluded from this release type: __constructor */\n  get hostAddress(): HostAddress;\n  get allHosts(): string[];\n  /** Is this server available for reads*/\n  get isReadable(): boolean;\n  /** Is this server data bearing */\n  get isDataBearing(): boolean;\n  /** Is this server available for writes */\n  get isWritable(): boolean;\n  get host(): string;\n  get port(): number;\n  /**\n   * Determines if another `ServerDescription` is equal to this one per the rules defined in the SDAM specification.\n   * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.md\n   */\n  equals(other?: ServerDescription | null): boolean;\n}\n\n/**\n * Emitted when server description changes, but does NOT include changes to the RTT.\n * @public\n * @category Event\n */\ndeclare class ServerDescriptionChangedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The address (host/port pair) of the server */\n  address: string;\n  /** The previous server description */\n  previousDescription: ServerDescription;\n  /** The new server description */\n  newDescription: ServerDescription;\n  name: \"serverDescriptionChanged\";\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare type ServerEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  /* Excluded from this release type: connect */\n  descriptionReceived(description: ServerDescription): void;\n  closed(): void;\n  ended(): void;\n} & ConnectionPoolEvents & EventEmitterWithState;\n\n/**\n * Emitted when the server monitors hello fails, either with an ok: 0 or a socket exception.\n * @public\n * @category Event\n */\ndeclare class ServerHeartbeatFailedEvent {\n  /** The connection id for the command */\n  connectionId: string;\n  /** The execution time of the event in ms */\n  duration: number;\n  /** The command failure */\n  failure: Error;\n  /** Is true when using the streaming protocol */\n  awaited: boolean;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * Emitted when the server monitors hello command is started - immediately before\n * the hello command is serialized into raw BSON and written to the socket.\n *\n * @public\n * @category Event\n */\ndeclare class ServerHeartbeatStartedEvent {\n  /** The connection id for the command */\n  connectionId: string;\n  /** Is true when using the streaming protocol */\n  awaited: boolean;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * Emitted when the server monitors hello succeeds.\n * @public\n * @category Event\n */\ndeclare class ServerHeartbeatSucceededEvent {\n  /** The connection id for the command */\n  connectionId: string;\n  /** The execution time of the event in ms */\n  duration: number;\n  /** The command reply */\n  reply: Document_2;\n  /** Is true when using the streaming protocol */\n  awaited: boolean;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare const ServerMonitoringMode: Readonly<{\n  readonly auto: \"auto\";\n  readonly poll: \"poll\";\n  readonly stream: \"stream\";\n}>;\n\n/** @public */\ndeclare type ServerMonitoringMode = (typeof ServerMonitoringMode)[keyof typeof ServerMonitoringMode];\n\n/**\n * Emitted when server is initialized.\n * @public\n * @category Event\n */\ndeclare class ServerOpeningEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The address (host/port pair) of the server */\n  address: string;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\ndeclare class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n  /* Excluded from this release type: __constructor */\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean;\n}\n\n/** @public */\ndeclare type ServerSessionId = {\n  id: Binary;\n};\n\n/**\n * An enumeration of server types we know about\n * @public\n */\ndeclare const ServerType: Readonly<{\n  readonly Standalone: \"Standalone\";\n  readonly Mongos: \"Mongos\";\n  readonly PossiblePrimary: \"PossiblePrimary\";\n  readonly RSPrimary: \"RSPrimary\";\n  readonly RSSecondary: \"RSSecondary\";\n  readonly RSArbiter: \"RSArbiter\";\n  readonly RSOther: \"RSOther\";\n  readonly RSGhost: \"RSGhost\";\n  readonly Unknown: \"Unknown\";\n  readonly LoadBalancer: \"LoadBalancer\";\n}>;\n\n/** @public */\ndeclare type ServerType = (typeof ServerType)[keyof typeof ServerType];\nexport declare enum ServerVersions {\n  latest = \"999.999.999\",\n  earliest = \"0.0.0\",\n}\ndeclare interface ServiceProvider extends Readable_2, Writable, Closable, Admin_2 {}\ndeclare interface ServiceProviderAbstractCursor<TSchema = Document_2> extends ServiceProviderBaseCursor<TSchema> {\n  batchSize(number: number): void;\n  maxTimeMS(value: number): void;\n  bufferedCount(): number;\n  readBufferedDocuments(number?: number): TSchema[];\n  toArray(): Promise<TSchema[]>;\n}\ndeclare interface ServiceProviderAggregationCursor<TSchema = Document_2> extends ServiceProviderAggregationOrFindCursor<TSchema> {}\ndeclare interface ServiceProviderAggregationOrFindCursor<TSchema = Document_2> extends ServiceProviderAbstractCursor<TSchema> {\n  project($project: Document_2): void;\n  skip($skip: number): void;\n  sort($sort: Document_2): void;\n  explain(verbosity?: ExplainVerbosityLike): Promise<Document_2>;\n  addCursorFlag(flag: CursorFlag, value: boolean): void;\n  withReadPreference(readPreference: ReadPreferenceLike): this;\n  withReadConcern(readConcern: ReadConcernLike): this;\n}\ndeclare interface ServiceProviderBaseCursor<TSchema = Document_2> {\n  close(): Promise<void>;\n  hasNext(): Promise<boolean>;\n  next(): Promise<TSchema | null>;\n  tryNext(): Promise<TSchema | null>;\n  readonly closed: boolean;\n  [Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void>;\n}\ndeclare interface ServiceProviderChangeStream<TSchema = Document_2> extends ServiceProviderBaseCursor<TSchema> {\n  next(): Promise<TSchema>;\n  readonly resumeToken: ResumeToken;\n}\ndeclare interface ServiceProviderFindCursor<TSchema = Document_2> extends ServiceProviderAggregationOrFindCursor<TSchema> {\n  allowDiskUse(allow?: boolean): void;\n  collation(value: CollationOptions): void;\n  comment(value: string): void;\n  maxAwaitTimeMS(value: number): void;\n  count(options?: CountOptions): Promise<number>;\n  hint(hint: string | Document_2): void;\n  max(max: Document_2): void;\n  min(min: Document_2): void;\n  limit(value: number): void;\n  skip(value: number): void;\n  returnKey(value: boolean): void;\n  showRecordId(value: boolean): void;\n}\ndeclare interface ServiceProviderRunCommandCursor<TSchema = Document_2> extends ServiceProviderAbstractCursor<TSchema> {}\ndeclare class Session<M extends GenericServerSideSchema = GenericServerSideSchema> extends ShellApiWithMongoClass {\n  id: ServerSessionId | undefined;\n  _session: ClientSession;\n  _options: ClientSessionOptions;\n  _mongo: Mongo<M>;\n  private _databases;\n  constructor(mongo: Mongo<M>, options: ClientSessionOptions, session: ClientSession);\n  [asPrintable](): ServerSessionId | undefined;\n  getDatabase<K extends StringKey<M>>(name: K): Database<M, M[K]>;\n  advanceOperationTime(ts: Timestamp): void;\n  advanceClusterTime(clusterTime: ClusterTime): void;\n  endSession(): void;\n  hasEnded(): boolean | undefined;\n  getClusterTime(): ClusterTime | undefined;\n  getOperationTime(): Timestamp | undefined;\n  getOptions(): ClientSessionOptions;\n  startTransaction(options?: TransactionOptions): void;\n  commitTransaction(): void;\n  abortTransaction(): void;\n  withTransaction<T extends (...args: any) => any>(fn: T, options?: TransactionOptions): ReturnType<T>;\n}\ndeclare interface SessionStartedEvent {\n  isInteractive: boolean;\n  jsContext: string;\n  timings: {\n    [category: string]: number;\n  };\n}\n\n/** @public */\ndeclare type SetFields<TSchema> = ({ readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?: OptionalId<Flatten<TSchema[key]>> | AddToSetOperators<Array<OptionalId<Flatten<TSchema[key]>>>> } & IsAny<TSchema[keyof TSchema], object, NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>>) & {\n  readonly [key: string]: AddToSetOperators<any> | any;\n};\n\n/** @public */\ndeclare type SetProfilingLevelOptions = CommandOperationOptions;\n\n/**\n * @public\n * Severity levels align with unix syslog.\n * Most typical driver functions will log to debug.\n */\ndeclare const SeverityLevel: Readonly<{\n  readonly EMERGENCY: \"emergency\";\n  readonly ALERT: \"alert\";\n  readonly CRITICAL: \"critical\";\n  readonly ERROR: \"error\";\n  readonly WARNING: \"warn\";\n  readonly NOTICE: \"notice\";\n  readonly INFORMATIONAL: \"info\";\n  readonly DEBUG: \"debug\";\n  readonly TRACE: \"trace\";\n  readonly OFF: \"off\";\n}>;\n\n/** @public */\ndeclare type SeverityLevel = (typeof SeverityLevel)[keyof typeof SeverityLevel];\nexport declare class Shard<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema> extends ShellApiWithMongoClass {\n  _database: Database<M, D>;\n  constructor(database: Database<M, D>);\n  get _mongo(): Mongo<M>;\n  [asPrintable](): string;\n  private _emitShardApiCall;\n  enableSharding(database: string, primaryShard?: string): Document_2;\n  commitReshardCollection(namespace: string): Document_2;\n  abortReshardCollection(namespace: string): Document_2;\n  shardCollection(namespace: string, key: Document_2, unique?: boolean | Document_2, options?: Document_2): Document_2;\n  reshardCollection(namespace: string, key: Document_2, unique?: boolean | Document_2, options?: Document_2): Document_2;\n  _runShardCollection(command: 'shardCollection' | 'reshardCollection', namespace: string, key: Document_2, unique?: boolean | Document_2, options?: Document_2): Promise<Document_2>;\n  status(verbose?: boolean, configDB?: Database<M, D>): CommandResult<ShardingStatusResult>;\n  addShard(url: string): Document_2;\n  addShardToZone(shard: string, zone: string): Document_2;\n  addShardTag(shard: string, tag: string): Document_2;\n  updateZoneKeyRange(namespace: string, min: Document_2, max: Document_2, zone: string | null): Document_2;\n  addTagRange(namespace: string, min: Document_2, max: Document_2, zone: string): Document_2;\n  removeRangeFromZone(ns: string, min: Document_2, max: Document_2): Document_2;\n  removeTagRange(ns: string, min: Document_2, max: Document_2): Document_2;\n  removeShardFromZone(shard: string, zone: string): Document_2;\n  removeShardTag(shard: string, tag: string): Document_2;\n  enableAutoSplit(): UpdateResult;\n  disableAutoSplit(): UpdateResult;\n  splitAt(ns: string, query: Document_2): Document_2;\n  splitFind(ns: string, query: Document_2): Document_2;\n  moveChunk(ns: string, query: Document_2, destination: string): Document_2;\n  moveRange(ns: string, toShard: string, min?: Document_2, max?: Document_2): Document_2;\n  balancerCollectionStatus(ns: string): Document_2;\n  enableBalancing(ns: string): UpdateResult;\n  disableBalancing(ns: string): UpdateResult;\n  getBalancerState(): boolean;\n  isBalancerRunning(): Document_2;\n  startBalancer(timeout?: number): Document_2;\n  stopBalancer(timeout?: number): Document_2;\n  setBalancerState(state: boolean): Document_2;\n  getShardedDataDistribution(options?: {}): AggregationCursor;\n  startAutoMerger(): UpdateResult;\n  stopAutoMerger(): UpdateResult;\n  isAutoMergerEnabled(): boolean;\n  disableAutoMerger(ns: string): UpdateResult;\n  enableAutoMerger(ns: string): UpdateResult;\n  checkMetadataConsistency(options?: CheckMetadataConsistencyOptions): RunCommandCursor;\n  shardAndDistributeCollection(ns: string, key: Document_2, unique?: boolean | Document_2, options?: Document_2): Document_2;\n  moveCollection(ns: string, toShard: string): Document_2;\n  abortMoveCollection(ns: string): Document_2;\n  unshardCollection(ns: string, toShard: string): Document_2;\n  abortUnshardCollection(ns: string): Document_2;\n  listShards(): ShardInfo[];\n  isConfigShardEnabled(): Document_2;\n}\ndeclare type ShardedDataDistribution = {\n  ns: string;\n  shards: {\n    shardName: string;\n    numOrphanedDocs: number;\n    numOwnedDocuments: number;\n    orphanedSizeBytes: number;\n    ownedSizeBytes: number;\n  }[];\n}[];\ndeclare type ShardInfo = {\n  _id: string;\n  host: string;\n  state: number;\n  tags?: string[];\n  topologyTime: Timestamp;\n  replSetConfigVersion: Long;\n};\ndeclare type ShardingStatusResult = {\n  shardingVersion: {\n    _id: number;\n    clusterId: ObjectId;\n    currentVersion?: number;\n  };\n  shards: ShardInfo[];\n  [mongoses: `${string} mongoses`]: 'none' | {\n    [version: string]: number | {\n      up: number;\n      waiting: boolean;\n    };\n  }[];\n  autosplit: {\n    'Currently enabled': 'yes' | 'no';\n  };\n  automerge?: {\n    'Currently enabled': 'yes' | 'no';\n  };\n  balancer: {\n    'Currently enabled': 'yes' | 'no';\n    'Currently running': 'yes' | 'no' | 'unknown';\n    'Failed balancer rounds in last 5 attempts': number;\n    'Migration Results for the last 24 hours': 'No recent migrations' | {\n      [count: number]: 'Success' | `Failed with error '${string}', from ${string} to ${string}`;\n    };\n    'Balancer active window is set between'?: `${string} and ${string} server local time`;\n    'Last reported error'?: string;\n    'Time of Reported error'?: string;\n    'Collections with active migrations'?: `${string} started at ${string}`[];\n  };\n  shardedDataDistribution?: ShardedDataDistribution;\n  databases: {\n    database: Document_2;\n    collections: Document_2;\n  }[];\n};\nexport declare class ShellApi extends ShellApiClass {\n  [instanceStateSymbol]: ShellInstanceState;\n  [loadCallNestingLevelSymbol]: number;\n  DBQuery: DBQuery;\n  config: ShellConfig;\n  constructor(instanceState: ShellInstanceState);\n  get log(): ShellLog;\n  get _instanceState(): ShellInstanceState;\n  get loadCallNestingLevel(): number;\n  set loadCallNestingLevel(value: number);\n  use(db: string): any;\n  show(cmd: string, arg?: string): CommandResult;\n  _untrackedShow(cmd: string, arg?: string): Promise<CommandResult>;\n  exit(exitCode?: number): never;\n  quit(exitCode?: number): never;\n  Mongo(uri?: string, fleOptions?: ClientSideFieldLevelEncryptionOptions, otherOptions?: {\n    api?: ServerApi | ServerApiVersion;\n  }): Mongo;\n  connect(uri: string, user?: string, pwd?: string): Database;\n  it(): any;\n  version(): string;\n  load(filename: string): true;\n  enableTelemetry(): any;\n  disableTelemetry(): any;\n  passwordPrompt(): string;\n  sleep(ms: number): void;\n  private _print;\n  print(...origArgs: any[]): void;\n  printjson(...origArgs: any[]): void;\n  convertShardKeyToHashed(value: any): unknown;\n  cls(): void;\n  isInteractive(): boolean;\n}\ndeclare abstract class ShellApiClass {\n  help: any;\n  abstract get _instanceState(): ShellInstanceState;\n  get [shellApiType](): string;\n  set [shellApiType](value: string);\n  [asPrintable](): any;\n}\ndeclare const shellApiType: unique symbol;\ndeclare abstract class ShellApiValueClass extends ShellApiClass {\n  get _mongo(): never;\n  get _instanceState(): never;\n}\ndeclare abstract class ShellApiWithMongoClass extends ShellApiClass {\n  abstract get _mongo(): Mongo;\n  get _instanceState(): ShellInstanceState;\n}\ndeclare interface ShellAuthOptions {\n  user: string;\n  pwd: string;\n  mechanism?: string;\n  digestPassword?: boolean;\n  authDb?: string;\n}\nexport declare type ShellBson = WithHelp<ShellBsonBase>;\ndeclare interface ShellBsonBase {\n  DBRef: (namespace: string, oid: any, db?: string, fields?: Document_2) => typeof bson.DBRef.prototype;\n  bsonsize: (object: any) => number;\n  MaxKey: () => typeof bson.MaxKey.prototype;\n  MinKey: () => typeof bson.MinKey.prototype;\n  ObjectId: (id?: string | number | typeof bson.ObjectId.prototype | Buffer) => typeof bson.ObjectId.prototype;\n  Timestamp: (t?: number | typeof bson.Long.prototype | {\n    t: number;\n    i: number;\n  }, i?: number) => typeof bson.Timestamp.prototype;\n  Code: (c?: string | Function, s?: any) => typeof bson.Code.prototype;\n  NumberDecimal: (s?: string) => typeof bson.Decimal128.prototype;\n  NumberInt: (v?: string) => typeof bson.Int32.prototype;\n  NumberLong: (s?: string | number) => typeof bson.Long.prototype;\n  ISODate: (input?: string) => Date;\n  BinData: (subtype: number, b64string: string) => Binary;\n  HexData: (subtype: number, hexstr: string) => Binary;\n  UUID: (hexstr?: string) => Binary;\n  MD5: (hexstr: string) => Binary;\n  Decimal128: typeof bson.Decimal128;\n  BSONSymbol: typeof bson.BSONSymbol;\n  Int32: typeof bson.Int32;\n  Long: LongWithoutAccidentallyExposedMethods;\n  Binary: typeof bson.Binary;\n  Double: typeof bson.Double;\n  EJSON: typeof bson.EJSON;\n  BSONRegExp: typeof bson.BSONRegExp;\n}\nexport declare interface ShellCliOptions {\n  nodb?: boolean;\n}\ndeclare interface ShellCommandAutocompleteParameters {\n  getCollectionCompletionsForCurrentDb: (collName: string) => string[] | Promise<string[]>;\n  getDatabaseCompletions: (dbName: string) => string[] | Promise<string[]>;\n}\ndeclare type ShellCommandCompleter = (params: ShellCommandAutocompleteParameters, args: string[]) => Promise<string[] | undefined>;\ndeclare class ShellConfig extends ShellApiClass {\n  _instanceState: ShellInstanceState;\n  defaults: Readonly<ShellUserConfig>;\n  constructor(instanceState: ShellInstanceState);\n  set<K extends keyof ShellUserConfig>(key: K, value: ShellUserConfig[K]): string;\n  get<K extends keyof ShellUserConfig>(key: K): ShellUserConfig[K];\n  reset<K extends keyof ShellUserConfig>(key: K): string;\n  _allKeys(): Promise<(keyof ShellUserConfig)[]>;\n  [asPrintable](): Promise<Map<keyof ShellUserConfig, ShellUserConfig[keyof ShellUserConfig]>>;\n}\nexport declare class ShellInstanceState {\n  currentCursor: Cursor | AggregationCursor | ChangeStreamCursor | RunCommandCursor | null;\n  currentDb: Database;\n  messageBus: MongoshBus;\n  initialServiceProvider: ServiceProvider;\n  private connectionInfoCache;\n  context: any;\n  mongos: Mongo[];\n  shellApi: ShellApi;\n  shellLog: ShellLog;\n  shellBson: ShellBson;\n  cliOptions: ShellCliOptions;\n  evaluationListener: EvaluationListener;\n  displayBatchSizeFromDBQuery: number | undefined;\n  isInteractive: boolean;\n  apiCallDepth: number;\n  private warningsShown;\n  readonly interrupted: InterruptFlag;\n  resumeMongosAfterInterrupt: Array<{\n    mongo: Mongo;\n    resume: (() => Promise<void>) | null;\n  }> | undefined;\n  private plugins;\n  private alreadyTransformedErrors;\n  private preFetchCollectionAndDatabaseNames;\n  constructor(initialServiceProvider: ServiceProvider, messageBus?: any, cliOptions?: ShellCliOptions);\n  fetchConnectionInfo(): Promise<ConnectionInfo_2 | undefined>;\n  cachedConnectionInfo(): ConnectionInfo_2 | undefined;\n  close(force: boolean): Promise<void>;\n  setPreFetchCollectionAndDatabaseNames(value: boolean): void;\n  setDbFunc(newDb: any): Database;\n  setCtx(contextObject: any): void;\n  get currentServiceProvider(): ServiceProvider;\n  emitApiCallWithArgs(event: ApiEventWithArguments): void;\n  emitApiCall(event: Omit<ApiEvent, 'callDepth'>): void;\n  setEvaluationListener(listener: EvaluationListener): void;\n  getAutocompleteParameters(): AutocompleteParameters;\n  apiVersionInfo(): Required<ServerApi> | undefined;\n  onInterruptExecution(): Promise<boolean>;\n  onResumeExecution(): Promise<boolean>;\n  getDefaultPrompt(): Promise<string>;\n  private getDefaultPromptPrefix;\n  private getTopologySpecificPrompt;\n  private getTopologySinglePrompt;\n  registerPlugin(plugin: ShellPlugin): void;\n  transformError(err: any): any;\n  printDeprecationWarning(message: string): Promise<void>;\n  printWarning(message: string): Promise<void>;\n}\ndeclare class ShellLog extends ShellApiClass {\n  [instanceStateSymbol_2]: ShellInstanceState;\n  get _instanceState(): ShellInstanceState;\n  constructor(instanceState: ShellInstanceState);\n  getPath(): string | undefined;\n  info(message: string, attr?: unknown): void;\n  warn(message: string, attr?: unknown): void;\n  error(message: string, attr?: unknown): void;\n  fatal(message: string, attr?: unknown): void;\n  debug(message: string, attr?: unknown, level?: 1 | 2 | 3 | 4 | 5): void;\n}\nexport declare interface ShellPlugin {\n  transformError?: (err: Error) => Error;\n}\nexport declare interface ShellResult {\n  rawValue: any;\n  printable: any;\n  type: string | null;\n  source?: ShellResultSourceInformation;\n}\ndeclare interface ShellResultSourceInformation {\n  namespace: Namespace;\n}\ndeclare class ShellUserConfig {\n  displayBatchSize: number;\n  maxTimeMS: number | null;\n  enableTelemetry: boolean;\n  editor: string | null;\n  logLocation: string | undefined;\n}\ndeclare interface ShowEvent {\n  method: string;\n}\ndeclare interface Signatures {\n  [key: string]: TypeSignature;\n}\nexport declare const signatures: Signatures;\ndeclare interface SnippetsCommandEvent {\n  args: string[];\n}\ndeclare interface SnippetsErrorEvent {\n  error: string;\n}\ndeclare interface SnippetsFetchIndexErrorEvent {\n  action: string;\n  url?: string;\n  status?: number;\n  error?: string;\n}\ndeclare interface SnippetsFetchIndexEvent {\n  refreshMode: string;\n}\ndeclare interface SnippetsLoadedEvent {\n  installdir: string;\n}\ndeclare interface SnippetsLoadSnippetEvent {\n  source: string;\n  name: string;\n}\ndeclare interface SnippetsNpmDownloadActiveEvent {\n  npmMetadataURL: string;\n  npmTarballURL: string;\n}\ndeclare interface SnippetsNpmDownloadFailedEvent {\n  npmMetadataURL: string;\n  npmTarballURL?: string;\n  status?: number;\n}\ndeclare interface SnippetsNpmLookupEvent {\n  existingVersion: string;\n}\ndeclare interface SnippetsRunNpmEvent {\n  args: string[];\n}\ndeclare interface SnippetsTransformErrorEvent {\n  error: string;\n  addition: string;\n  name: string;\n}\n\n/** @public */\ndeclare type Sort = string | Exclude<SortDirection, {\n  $meta: string;\n}> | string[] | {\n  [key: string]: SortDirection;\n} | Map<string, SortDirection> | [string, SortDirection][] | [string, SortDirection];\n\n/** @public */\ndeclare type SortDirection = 1 | -1 | 'asc' | 'desc' | 'ascending' | 'descending' | {\n  $meta: string;\n};\ndeclare interface StartLoadingCliScriptsEvent {\n  usesShellOption: boolean;\n}\ndeclare interface StartMongoshReplEvent {\n  version: string;\n}\n\n/** @public */\ndeclare interface StreamDescriptionOptions {\n  compressors?: CompressorName[];\n  logicalSessionTimeoutMinutes?: number;\n  loadBalanced: boolean;\n}\nexport declare class StreamProcessor extends ShellApiWithMongoClass {\n  _streams: Streams;\n  name: string;\n  constructor(_streams: Streams, name: string);\n  get _mongo(): Mongo;\n  [asPrintable](): string;\n  start(options?: Document_2): Document_2;\n  stop(options?: Document_2): Document_2;\n  drop(options?: Document_2): Document_2;\n  _drop(options?: Document_2): Promise<Document_2>;\n  stats(options?: Document_2): Document_2;\n  modify(options: Document_2): Document_2;\n  modify(pipeline: Document_2[], options?: Document_2): Document_2;\n  sample(options?: Document_2): Document_2 | undefined;\n  _sampleFrom(cursorId: number): Promise<Document_2 | undefined>;\n}\nexport declare class Streams<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema> extends ShellApiWithMongoClass {\n  static newInstance<M extends GenericServerSideSchema = GenericServerSideSchema, D extends GenericDatabaseSchema = GenericDatabaseSchema>(database: Database<M, D>): Streams<M, D>;\n  private _database;\n  constructor(database: Database<M, D>);\n  get _mongo(): Mongo<M>;\n  [asPrintable](): string;\n  getProcessor(name: string): StreamProcessor;\n  process(pipeline: Document_2[], options?: Document_2): void | Document_2;\n  createStreamProcessor(name: string, pipeline: Document_2[], options?: Document_2): Document_2 | StreamProcessor;\n  listStreamProcessors(filter: Document_2): any;\n  listConnections(filter: Document_2): any;\n  _runStreamCommand(cmd: Document_2, options?: Document_2): Promise<Document_2>;\n}\nexport declare type StringKey<T> = keyof T & string;\n\n/** @public */\ndeclare type SupportedNodeConnectionOptions = SupportedTLSConnectionOptions & SupportedTLSSocketOptions & SupportedSocketOptions;\n\n/** @public */\ndeclare type SupportedSocketOptions = Pick<TcpNetConnectOpts & {\n  autoSelectFamily?: boolean;\n  autoSelectFamilyAttemptTimeout?: number;\n}, (typeof LEGAL_TCP_SOCKET_OPTIONS)[number]>;\n\n/** @public */\ndeclare type SupportedTLSConnectionOptions = Pick<ConnectionOptions & {\n  allowPartialTrustChain?: boolean;\n}, (typeof LEGAL_TLS_SOCKET_OPTIONS)[number]>;\n\n/** @public */\ndeclare type SupportedTLSSocketOptions = Pick<TLSSocketOptions, Extract<keyof TLSSocketOptions, (typeof LEGAL_TLS_SOCKET_OPTIONS)[number]>>;\n\n/** @public */\ndeclare type TagSet = {\n  [key: string]: string;\n};\n\n/** @public\n * Configuration options for timeseries collections\n * @see https://www.mongodb.com/docs/manual/core/timeseries-collections/\n */\ndeclare interface TimeSeriesCollectionOptions extends Document_2 {\n  timeField: string;\n  metaField?: string;\n  granularity?: 'seconds' | 'minutes' | 'hours' | string;\n  bucketMaxSpanSeconds?: number;\n  bucketRoundingSeconds?: number;\n}\n\n/**\n * @public\n * @category BSONType\n *\n * A special type for _internal_ MongoDB use and is **not** associated with the regular Date type.\n */\ndeclare class Timestamp extends LongWithoutOverridesClass {\n  get _bsontype(): 'Timestamp';\n  static readonly MAX_VALUE: Long;\n  /**\n   * An incrementing ordinal for operations within a given second.\n   */\n  get i(): number;\n  /**\n   * A `time_t` value measuring seconds since the Unix epoch\n   */\n  get t(): number;\n  /**\n   * @param int - A 64-bit bigint representing the Timestamp.\n   */\n  constructor(int: bigint);\n  /**\n   * @param long - A 64-bit Long representing the Timestamp.\n   */\n  constructor(long: Long);\n  /**\n   * @param value - A pair of two values indicating timestamp and increment.\n   */\n  constructor(value: {\n    t: number;\n    i: number;\n  });\n  toJSON(): {\n    $timestamp: string;\n  };\n  /** Returns a Timestamp represented by the given (32-bit) integer value. */\n  static fromInt(value: number): Timestamp;\n  /** Returns a Timestamp representing the given number value, provided that it is a finite number. Otherwise, zero is returned. */\n  static fromNumber(value: number): Timestamp;\n  /**\n   * Returns a Timestamp for the given high and low bits. Each is assumed to use 32 bits.\n   *\n   * @param lowBits - the low 32-bits.\n   * @param highBits - the high 32-bits.\n   */\n  static fromBits(lowBits: number, highBits: number): Timestamp;\n  /**\n   * Returns a Timestamp from the given string, optionally using the given radix.\n   *\n   * @param str - the textual representation of the Timestamp.\n   * @param optRadix - the radix in which the text is written.\n   */\n  static fromString(str: string, optRadix: number): Timestamp;\n  /* Excluded from this release type: toExtendedJSON */\n  /* Excluded from this release type: fromExtendedJSON */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare type TimestampOverrides = '_bsontype' | 'toExtendedJSON' | 'fromExtendedJSON' | 'inspect';\nexport declare enum Topologies {\n  ReplSet = \"ReplSet\",\n  Standalone = \"Standalone\",\n  Sharded = \"Sharded\",\n  LoadBalanced = \"LoadBalanced\",\n}\n\n/**\n * Emitted when topology is closed.\n * @public\n * @category Event\n */\ndeclare class TopologyClosedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * Representation of a deployment of servers\n * @public\n */\ndeclare class TopologyDescription {\n  type: TopologyType;\n  setName: string | null;\n  maxSetVersion: number | null;\n  maxElectionId: ObjectId | null;\n  servers: Map<string, ServerDescription>;\n  stale: boolean;\n  compatible: boolean;\n  compatibilityError?: string;\n  logicalSessionTimeoutMinutes: number | null;\n  heartbeatFrequencyMS: number;\n  localThresholdMS: number;\n  commonWireVersion: number;\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(topologyType: TopologyType, serverDescriptions?: Map<string, ServerDescription> | null, setName?: string | null, maxSetVersion?: number | null, maxElectionId?: ObjectId | null, commonWireVersion?: number | null, options?: TopologyDescriptionOptions | null);\n  /* Excluded from this release type: updateFromSrvPollingEvent */\n  /* Excluded from this release type: update */\n  get error(): MongoError | null;\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers(): boolean;\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers(): boolean;\n  /* Excluded from this release type: hasServer */\n  /**\n   * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily\n   * intended for use with JSON.stringify().\n   *\n   * This method will not throw.\n   */\n  toJSON(): Document_2;\n}\n\n/**\n * Emitted when topology description changes.\n * @public\n * @category Event\n */\ndeclare class TopologyDescriptionChangedEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /** The old topology description */\n  previousDescription: TopologyDescription;\n  /** The new topology description */\n  newDescription: TopologyDescription;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/** @public */\ndeclare interface TopologyDescriptionOptions {\n  heartbeatFrequencyMS?: number;\n  localThresholdMS?: number;\n}\n\n/** @public */\ndeclare type TopologyEvents = {\n  /* Excluded from this release type: connect */\n  serverOpening(event: ServerOpeningEvent): void;\n  serverClosed(event: ServerClosedEvent): void;\n  serverDescriptionChanged(event: ServerDescriptionChangedEvent): void;\n  topologyClosed(event: TopologyClosedEvent): void;\n  topologyOpening(event: TopologyOpeningEvent): void;\n  topologyDescriptionChanged(event: TopologyDescriptionChangedEvent): void;\n  error(error: Error): void;\n  /* Excluded from this release type: open */\n  close(): void;\n  timeout(): void;\n} & Omit<ServerEvents, 'connect'> & ConnectionPoolEvents & ConnectionEvents & EventEmitterWithState;\n\n/**\n * Emitted when topology is initialized.\n * @public\n * @category Event\n */\ndeclare class TopologyOpeningEvent {\n  /** A unique identifier for the topology */\n  topologyId: number;\n  /* Excluded from this release type: name */\n  /* Excluded from this release type: __constructor */\n}\n\n/**\n * An enumeration of topology types we know about\n * @public\n */\ndeclare const TopologyType: Readonly<{\n  readonly Single: \"Single\";\n  readonly ReplicaSetNoPrimary: \"ReplicaSetNoPrimary\";\n  readonly ReplicaSetWithPrimary: \"ReplicaSetWithPrimary\";\n  readonly Sharded: \"Sharded\";\n  readonly Unknown: \"Unknown\";\n  readonly LoadBalanced: \"LoadBalanced\";\n}>;\n\n/** @public */\ndeclare type TopologyType = (typeof TopologyType)[keyof typeof TopologyType];\n\n/** @public */\ndeclare interface TopologyVersion {\n  processId: ObjectId;\n  counter: Long;\n}\nexport declare function toShellResult(rawValue: any): Promise<ShellResult>;\n\n/**\n * @public\n * A class maintaining state related to a server transaction. Internal Only\n */\ndeclare class Transaction {\n  /* Excluded from this release type: state */\n  options: TransactionOptions;\n  /* Excluded from this release type: _pinnedServer */\n  /* Excluded from this release type: _recoveryToken */\n  /* Excluded from this release type: __constructor */\n  /* Excluded from this release type: server */\n  get recoveryToken(): Document_2 | undefined;\n  get isPinned(): boolean;\n  /** @returns Whether the transaction has started */\n  get isStarting(): boolean;\n  /**\n   * @returns Whether this session is presently in a transaction\n   */\n  get isActive(): boolean;\n  get isCommitted(): boolean;\n  /* Excluded from this release type: transition */\n  /* Excluded from this release type: pinServer */\n  /* Excluded from this release type: unpinServer */\n}\n\n/**\n * Configuration options for a transaction.\n * @public\n */\ndeclare interface TransactionOptions extends Omit<CommandOperationOptions, 'timeoutMS'> {\n  /** A default read concern for commands in this transaction */\n  readConcern?: ReadConcernLike;\n  /** A default writeConcern for commands in this transaction */\n  writeConcern?: WriteConcern;\n  /** A default read preference for commands in this transaction */\n  readPreference?: ReadPreferenceLike;\n  /** Specifies the maximum amount of time to allow a commit action on a transaction to run in milliseconds */\n  maxCommitTimeMS?: number;\n}\n\n/**\n * Typescript type safe event emitter\n * @public\n */\ndeclare interface TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {\n  addListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  addListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  addListener(event: string | symbol, listener: GenericListener): this;\n  on<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  on(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  on(event: string | symbol, listener: GenericListener): this;\n  once<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  once(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  once(event: string | symbol, listener: GenericListener): this;\n  removeListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  removeListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  removeListener(event: string | symbol, listener: GenericListener): this;\n  off<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  off(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  off(event: string | symbol, listener: GenericListener): this;\n  removeAllListeners<EventKey extends keyof Events>(event?: EventKey | CommonEvents | symbol | string): this;\n  listeners<EventKey extends keyof Events>(event: EventKey | CommonEvents | symbol | string): Events[EventKey][];\n  rawListeners<EventKey extends keyof Events>(event: EventKey | CommonEvents | symbol | string): Events[EventKey][];\n  emit<EventKey extends keyof Events>(event: EventKey | symbol, ...args: Parameters<Events[EventKey]>): boolean;\n  listenerCount<EventKey extends keyof Events>(type: EventKey | CommonEvents | symbol | string): number;\n  prependListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  prependListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  prependListener(event: string | symbol, listener: GenericListener): this;\n  prependOnceListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  prependOnceListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;\n  prependOnceListener(event: string | symbol, listener: GenericListener): this;\n  eventNames(): string[];\n  getMaxListeners(): number;\n  setMaxListeners(n: number): this;\n}\n\n/**\n * Typescript type safe event emitter\n * @public\n */\ndeclare class TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {\n  /* Excluded from this release type: mongoLogger */\n  /* Excluded from this release type: component */\n  /* Excluded from this release type: emitAndLog */\n  /* Excluded from this release type: emitAndLogHeartbeat */\n  /* Excluded from this release type: emitAndLogCommand */\n}\n\n/** @public */\ndeclare interface TypedEventEmitter_2<EventMap extends object> {\n  on<K extends keyof EventMap>(event: K, listener: EventMap[K]): this;\n  off?<K extends keyof EventMap>(event: K, listener: EventMap[K]): this;\n  once<K extends keyof EventMap>(event: K, listener: EventMap[K]): this;\n  emit<K extends keyof EventMap>(event: K, ...args: EventMap[K] extends ((...args: infer P) => any) ? P : never): unknown;\n}\nexport declare interface TypeSignature {\n  type: string;\n  serverVersions?: [string, string];\n  apiVersions?: [number, number];\n  topologies?: Topologies[];\n  returnsPromise?: boolean;\n  deprecated?: boolean;\n  returnType?: string | TypeSignature;\n  attributes?: {\n    [key: string]: TypeSignature;\n  };\n  isDirectShellCommand?: boolean;\n  acceptsRawInput?: boolean;\n  shellCommandCompleter?: ShellCommandCompleter;\n  inherited?: boolean;\n}\n\n/** @public */\ndeclare class UnorderedBulkOperation extends BulkOperationBase {\n  /* Excluded from this release type: __constructor */\n  handleWriteError(writeResult: BulkWriteResult_2): void;\n  addToOperationsList(batchType: BatchType, document: Document_2 | UpdateStatement | DeleteStatement): this;\n}\n\n/** @public */\ndeclare interface UpdateDescription<TSchema extends Document_2 = Document_2> {\n  /**\n   * A document containing key:value pairs of names of the fields that were\n   * changed, and the new value for those fields.\n   */\n  updatedFields?: Partial<TSchema>;\n  /**\n   * An array of field names that were removed from the document.\n   */\n  removedFields?: string[];\n  /**\n   * An array of documents which record array truncations performed with pipeline-based updates using one or more of the following stages:\n   * - $addFields\n   * - $set\n   * - $replaceRoot\n   * - $replaceWith\n   */\n  truncatedArrays?: Array<{\n    /** The name of the truncated field. */\n    field: string;\n    /** The number of elements in the truncated array. */\n    newSize: number;\n  }>;\n  /**\n   * A document containing additional information about any ambiguous update paths from the update event.  The document\n   * maps the full ambiguous update path to an array containing the actual resolved components of the path.  For example,\n   * given a document shaped like `{ a: { '0': 0 } }`, and an update of `{ $inc: 'a.0' }`, disambiguated paths would look like\n   * the following:\n   *\n   * ```\n   *   {\n   *     'a.0': ['a', '0']\n   *   }\n   * ```\n   *\n   * This field is only present when there are ambiguous paths that are updated as a part of the update event and `showExpandedEvents`\n   * is enabled for the change stream.\n   * @sinceServerVersion 6.1.0\n   */\n  disambiguatedPaths?: Document_2;\n}\n\n/** @public */\ndeclare type UpdateFilter<TSchema> = {\n  $currentDate?: OnlyFieldsOfType<TSchema, Date | Timestamp, true | {\n    $type: 'date' | 'timestamp';\n  }>;\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $min?: MatchKeysAndValues<TSchema>;\n  $max?: MatchKeysAndValues<TSchema>;\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $rename?: Record<string, string>;\n  $set?: MatchKeysAndValues<TSchema>;\n  $setOnInsert?: MatchKeysAndValues<TSchema>;\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\n  $addToSet?: SetFields<TSchema>;\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\n  $pull?: PullOperator<TSchema>;\n  $push?: PushOperator<TSchema>;\n  $pullAll?: PullAllOperator<TSchema>;\n  $bit?: OnlyFieldsOfType<TSchema, NumericType | undefined, {\n    and: IntegerType;\n  } | {\n    or: IntegerType;\n  } | {\n    xor: IntegerType;\n  }>;\n} & Document_2;\n\n/** @public */\ndeclare interface UpdateManyModel<TSchema extends Document_2 = Document_2> {\n  /** The filter to limit the updated documents. */\n  filter: Filter<TSchema>;\n  /**\n   * The modifications to apply. The value can be either:\n   * UpdateFilter<TSchema> - A document that contains update operator expressions,\n   * Document[] - an aggregation pipeline.\n   */\n  update: UpdateFilter<TSchema> | Document_2[];\n  /** A set of filters specifying to which array elements an update should apply. */\n  arrayFilters?: Document_2[];\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\ndeclare interface UpdateOneModel<TSchema extends Document_2 = Document_2> {\n  /** The filter to limit the updated documents. */\n  filter: Filter<TSchema>;\n  /**\n   * The modifications to apply. The value can be either:\n   * UpdateFilter<TSchema> - A document that contains update operator expressions,\n   * Document[] - an aggregation pipeline.\n   */\n  update: UpdateFilter<TSchema> | Document_2[];\n  /** A set of filters specifying to which array elements an update should apply. */\n  arrayFilters?: Document_2[];\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\ndeclare interface UpdateOptions extends CommandOperationOptions {\n  /** A set of filters specifying to which array elements an update should apply */\n  arrayFilters?: Document_2[];\n  /** If true, allows the write to opt-out of document level validation */\n  bypassDocumentValidation?: boolean;\n  /** Specifies a collation */\n  collation?: CollationOptions;\n  /** Specify that the update query should only consider plans using the hinted index */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document_2;\n}\nexport declare class UpdateResult extends ShellApiValueClass {\n  acknowledged: boolean;\n  insertedId: ObjectId | null;\n  matchedCount: number;\n  modifiedCount: number;\n  upsertedCount: number;\n  constructor(acknowledged: boolean, matchedCount: number, modifiedCount: number, upsertedCount: number, insertedId: ObjectId | null);\n}\n\n/**\n * @public\n * `TSchema` is the schema of the collection\n */\ndeclare interface UpdateResult_2<TSchema extends Document_2 = Document_2> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of documents that matched the filter */\n  matchedCount: number;\n  /** The number of documents that were modified */\n  modifiedCount: number;\n  /** The number of documents that were upserted */\n  upsertedCount: number;\n  /** The identifier of the inserted document if an upsert took place */\n  upsertedId: InferIdType<TSchema> | null;\n}\n\n/** @public */\ndeclare interface UpdateStatement {\n  /** The query that matches documents to update. */\n  q: Document_2;\n  /** The modifications to apply. */\n  u: Document_2 | Document_2[];\n  /**  If true, perform an insert if no documents match the query. */\n  upsert?: boolean;\n  /** If true, updates all documents that meet the query criteria. */\n  multi?: boolean;\n  /** Specifies the collation to use for the operation. */\n  collation?: CollationOptions;\n  /** An array of filter documents that determines which array elements to modify for an update operation on an array field. */\n  arrayFilters?: Document_2[];\n  /** A document or string that specifies the index to use to support the query predicate. */\n  hint?: Hint;\n}\ndeclare interface UseEvent {\n  db: string;\n}\n\n/**\n * A class representation of the BSON UUID type.\n * @public\n */\ndeclare class UUID extends Binary {\n  /**\n   * Create a UUID type\n   *\n   * When the argument to the constructor is omitted a random v4 UUID will be generated.\n   *\n   * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.\n   */\n  constructor(input?: string | Uint8Array | UUID);\n  /**\n   * The UUID bytes\n   * @readonly\n   */\n  get id(): Uint8Array;\n  set id(value: Uint8Array);\n  /**\n   * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)\n   * @param includeDashes - should the string exclude dash-separators.\n   */\n  toHexString(includeDashes?: boolean): string;\n  /**\n   * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.\n   */\n  toString(encoding?: 'hex' | 'base64'): string;\n  /**\n   * Converts the id into its JSON string representation.\n   * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n   */\n  toJSON(): string;\n  /**\n   * Compares the equality of this UUID with `otherID`.\n   *\n   * @param otherId - UUID instance to compare against.\n   */\n  equals(otherId: string | Uint8Array | UUID): boolean;\n  /**\n   * Creates a Binary instance from the current UUID.\n   */\n  toBinary(): Binary;\n  /**\n   * Generates a populated buffer containing a v4 uuid\n   */\n  static generate(): Uint8Array;\n  /**\n   * Checks if a value is a valid bson UUID\n   * @param input - UUID, string or Buffer to validate.\n   */\n  static isValid(input: string | Uint8Array | UUID | Binary): boolean;\n  /**\n   * Creates an UUID from a hex string representation of an UUID.\n   * @param hexString - 32 or 36 character hex string (dashes excluded/included).\n   */\n  static createFromHexString(hexString: string): UUID;\n  /** Creates an UUID from a base64 string representation of an UUID. */\n  static createFromBase64(base64: string): UUID;\n  /* Excluded from this release type: bytesFromString */\n  /* Excluded from this release type: isValidUUIDString */\n  /**\n   * Converts to a string representation of this Id.\n   *\n   * @returns return the 36 character hex string representation.\n   *\n   */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;\n}\n\n/** @public */\ndeclare interface ValidateCollectionOptions extends CommandOperationOptions {\n  /** Validates a collection in the background, without interrupting read or write traffic (only in MongoDB 4.4+) */\n  background?: boolean;\n}\n\n/** @public */\ndeclare type W = number | 'majority';\ndeclare type WithHelp<T> = { [prop in keyof T]: T[prop] & {\n  help?: () => Help;\n} };\n\n/** Add an _id field to an object shaped type @public */\ndeclare type WithId<TSchema> = EnhancedOmit<TSchema, '_id'> & {\n  _id: InferIdType<TSchema>;\n};\n\n/** Remove the _id field from an object shaped type @public */\ndeclare type WithoutId<TSchema> = Omit<TSchema, '_id'>;\n\n/** @public */\ndeclare type WithSessionCallback<T = unknown> = (session: ClientSession) => Promise<T>;\n\n/** @public */\ndeclare type WithTransactionCallback<T = any> = (session: ClientSession) => Promise<T>;\ndeclare interface Writable {\n  runCommand(db: string, spec: Document_2, options: RunCommandOptions, dbOptions?: DbOptions): Promise<Document_2>;\n  runCommandWithCheck(db: string, spec: Document_2, options: RunCommandOptions, dbOptions?: DbOptions): Promise<Document_2>;\n  runCursorCommand(db: string, spec: Document_2, options: RunCursorCommandOptions, dbOptions?: DbOptions): ServiceProviderRunCommandCursor;\n  dropDatabase(database: string, options: DropDatabaseOptions, dbOptions?: DbOptions): Promise<Document_2>;\n  bulkWrite(database: string, collection: string, requests: AnyBulkWriteOperation[], options: BulkWriteOptions, dbOptions?: DbOptions): Promise<BulkWriteResult_2>;\n  clientBulkWrite(models: AnyClientBulkWriteModel<Document_2>[], options: ClientBulkWriteOptions): Promise<ClientBulkWriteResult>;\n  deleteMany(database: string, collection: string, filter: Document_2, options: DeleteOptions, dbOptions?: DbOptions): Promise<DeleteResult_2>;\n  deleteOne(database: string, collection: string, filter: Document_2, options: DeleteOptions, dbOptions?: DbOptions): Promise<DeleteResult_2>;\n  findOneAndDelete(database: string, collection: string, filter: Document_2, options: FindOneAndDeleteOptions, dbOptions?: DbOptions): Promise<Document_2 | null>;\n  findOneAndReplace(database: string, collection: string, filter: Document_2, replacement: Document_2, options: FindOneAndReplaceOptions, dbOptions?: DbOptions): Promise<Document_2>;\n  findOneAndUpdate(database: string, collection: string, filter: Document_2, update: Document_2 | Document_2[], options: FindOneAndUpdateOptions, dbOptions?: DbOptions): Promise<Document_2>;\n  insertMany(database: string, collection: string, docs: Document_2[], options: BulkWriteOptions, dbOptions?: DbOptions): Promise<InsertManyResult_2>;\n  insertOne(database: string, collection: string, doc: Document_2, options: InsertOneOptions, dbOptions?: DbOptions): Promise<InsertOneResult_2>;\n  replaceOne(database: string, collection: string, filter: Document_2, replacement: Document_2, options?: ReplaceOptions, dbOptions?: DbOptions): Promise<UpdateResult_2>;\n  updateMany(database: string, collection: string, filter: Document_2, update: Document_2, options?: UpdateOptions, dbOptions?: DbOptions): Promise<UpdateResult_2>;\n  updateOne(database: string, collection: string, filter: Document_2, update: Document_2, options?: UpdateOptions, dbOptions?: DbOptions): Promise<UpdateResult_2>;\n  createIndexes(database: string, collection: string, indexSpecs: Document_2[], options?: CreateIndexesOptions, dbOptions?: DbOptions): Promise<string[]>;\n  dropCollection(database: string, collection: string, options: DropCollectionOptions, dbOptions?: DbOptions): Promise<boolean>;\n  renameCollection(database: string, oldName: string, newName: string, options?: RenameOptions, dbOptions?: DbOptions): Promise<Collection_2>;\n  initializeBulkOp(dbName: string, collName: string, ordered: boolean, options?: BulkWriteOptions, dbOptions?: DbOptions): Promise<OrderedBulkOperation | UnorderedBulkOperation>;\n  createSearchIndexes(database: string, collection: string, descriptions: SearchIndexDescription[], dbOptions?: DbOptions): Promise<string[]>;\n  dropSearchIndex(database: string, collection: string, index: string, dbOptions?: DbOptions): Promise<void>;\n  updateSearchIndex(database: string, collection: string, index: string, definition: Document_2, dbOptions?: DbOptions): Promise<void>;\n}\n\n/**\n * A MongoDB WriteConcern, which describes the level of acknowledgement\n * requested from MongoDB for write operations.\n * @public\n *\n * @see https://www.mongodb.com/docs/manual/reference/write-concern/\n */\ndeclare class WriteConcern {\n  /**\n   * Request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.\n   * If w is 0 and is set on a write operation, the server will not send a response.\n   */\n  readonly w?: W;\n  /** Request acknowledgment that the write operation has been written to the on-disk journal */\n  readonly journal?: boolean;\n  /**\n   * Specify a time limit to prevent write operations from blocking indefinitely.\n   */\n  readonly wtimeoutMS?: number;\n  /**\n   * Specify a time limit to prevent write operations from blocking indefinitely.\n   * @deprecated Will be removed in the next major version. Please use wtimeoutMS.\n   */\n  wtimeout?: number;\n  /**\n   * Request acknowledgment that the write operation has been written to the on-disk journal.\n   * @deprecated Will be removed in the next major version. Please use journal.\n   */\n  j?: boolean;\n  /**\n   * Equivalent to the j option.\n   * @deprecated Will be removed in the next major version. Please use journal.\n   */\n  fsync?: boolean | 1;\n  /**\n   * Constructs a WriteConcern from the write concern properties.\n   * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.\n   * @param wtimeoutMS - specify a time limit to prevent write operations from blocking indefinitely\n   * @param journal - request acknowledgment that the write operation has been written to the on-disk journal\n   * @param fsync - equivalent to the j option. Is deprecated and will be removed in the next major version.\n   */\n  constructor(w?: W, wtimeoutMS?: number, journal?: boolean, fsync?: boolean | 1);\n  /**\n   * Apply a write concern to a command document. Will modify and return the command.\n   */\n  static apply(command: Document_2, writeConcern: WriteConcern): Document_2;\n  /** Construct a WriteConcern given an options object. */\n  static fromOptions(options?: WriteConcernOptions | WriteConcern | W, inherit?: WriteConcernOptions | WriteConcern): WriteConcern | undefined;\n}\n\n/**\n * An error representing a failure by the server to apply the requested write concern to the bulk operation.\n * @public\n * @category Error\n */\ndeclare class WriteConcernError {\n  /* Excluded from this release type: serverError */\n  constructor(error: WriteConcernErrorData);\n  /** Write concern error code. */\n  get code(): number | undefined;\n  /** Write concern error message. */\n  get errmsg(): string | undefined;\n  /** Write concern error info. */\n  get errInfo(): Document_2 | undefined;\n  toJSON(): WriteConcernErrorData;\n  toString(): string;\n}\n\n/** @public */\ndeclare interface WriteConcernErrorData {\n  code: number;\n  errmsg: string;\n  errInfo?: Document_2;\n}\n\n/** @public */\ndeclare interface WriteConcernOptions {\n  /** Write Concern as an object */\n  writeConcern?: WriteConcern | WriteConcernSettings;\n}\n\n/** @public */\ndeclare interface WriteConcernSettings {\n  /** The write concern */\n  w?: W;\n  /**\n   * The write concern timeout.\n   */\n  wtimeoutMS?: number;\n  /** The journal write concern */\n  journal?: boolean;\n  /**\n   * The journal write concern.\n   * @deprecated Will be removed in the next major version. Please use the journal option.\n   */\n  j?: boolean;\n  /**\n   * The write concern timeout.\n   */\n  wtimeout?: number;\n  /**\n   * The file sync write concern.\n   * @deprecated Will be removed in the next major version. Please use the journal option.\n   */\n  fsync?: boolean | 1;\n}\ndeclare interface WriteCustomLogEvent {\n  method: 'info' | 'error' | 'warn' | 'fatal' | 'debug';\n  message: string;\n  attr?: unknown;\n  level?: 1 | 2 | 3 | 4 | 5;\n}\n\n/**\n * An error that occurred during a BulkWrite on the server.\n * @public\n * @category Error\n */\ndeclare class WriteError {\n  err: BulkWriteOperationError;\n  constructor(err: BulkWriteOperationError);\n  /** WriteError code. */\n  get code(): number;\n  /** WriteError original bulk operation index. */\n  get index(): number;\n  /** WriteError message. */\n  get errmsg(): string | undefined;\n  /** WriteError details. */\n  get errInfo(): Document_2 | undefined;\n  /** Returns the underlying operation that caused the error */\n  getOperation(): Document_2;\n  toJSON(): {\n    code: number;\n    index: number;\n    errmsg?: string;\n    op: Document_2;\n  };\n  toString(): string;\n}\nexport {};\n\ndeclare global {\n  const use: ShellApi['use'];\n  const show: ShellApi['show'];\n  const exit: ShellApi['exit'];\n  const quit: ShellApi['quit'];\n  const Mongo: ShellApi['Mongo'];\n  const connect: ShellApi['connect'];\n  const it: ShellApi['it'];\n  const version: ShellApi['version'];\n  const load: ShellApi['load'];\n  const enableTelemetry: ShellApi['enableTelemetry'];\n  const disableTelemetry: ShellApi['disableTelemetry'];\n  const passwordPrompt: ShellApi['passwordPrompt'];\n  const sleep: ShellApi['sleep'];\n  const print: ShellApi['print'];\n  const printjson: ShellApi['printjson'];\n  const convertShardKeyToHashed: ShellApi['convertShardKeyToHashed'];\n  const cls: ShellApi['cls'];\n  const isInteractive: ShellApi['isInteractive'];\n\n  const DBRef: ShellBson['DBRef'];\n  const bsonsize: ShellBson['bsonsize'];\n  const MaxKey: ShellBson['MaxKey'];\n  const MinKey: ShellBson['MinKey'];\n  const ObjectId: ShellBson['ObjectId'];\n  const Timestamp: ShellBson['Timestamp'];\n  const Code: ShellBson['Code'];\n  const NumberDecimal: ShellBson['NumberDecimal'];\n  const NumberInt: ShellBson['NumberInt'];\n  const NumberLong: ShellBson['NumberLong'];\n  const ISODate: ShellBson['ISODate'];\n  const BinData: ShellBson['BinData'];\n  const HexData: ShellBson['HexData'];\n  const UUID: ShellBson['UUID'];\n  const MD5: ShellBson['MD5'];\n  const Decimal128: ShellBson['Decimal128'];\n  const BSONSymbol: ShellBson['BSONSymbol'];\n  const Int32: ShellBson['Int32'];\n  const Long: ShellBson['Long'];\n  const Binary: ShellBson['Binary'];\n  const Double: ShellBson['Double'];\n  const EJSON: ShellBson['EJSON'];\n  const BSONRegExp: ShellBson['BSONRegExp'];\n}\n",
};
export default files;
