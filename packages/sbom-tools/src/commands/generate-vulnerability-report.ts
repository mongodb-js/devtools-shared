import { promises as fs } from 'fs';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const snykPolicy = require('snyk-policy');
import _ from 'lodash';
import chalk from 'chalk';

import { loadDependencyFiles } from '../load-dependency-files';
import type { KnownSeverity } from './severity';
import { severityToScore } from './severity';

export async function loadReports(
  files: string[]
): Promise<SnykTestProjectResult[]> {
  // turns single project result to a multi-project one, to simplify further
  // processing
  return (
    await Promise.all(
      files.map(async (fileName) =>
        JSON.parse(await fs.readFile(fileName, 'utf-8'))
      )
    )
  ).flat();
}

type SnykTestProjectResult = {
  vulnerabilities: SnykVulnerability[];
};

type SnykVulnerability = {
  moduleName: string;
  from: string[];
  name: string;
  version: string;
  cvssScore: number;
  severity: KnownSeverity;
  id: string;
  url: string;
  title: string;
  fixedIn: string[];
};

type Vulnerability = {
  name: string;
  id: string;
  score: number;
  fixedIn: string;
  origins: string[];
  severity: string;
  policy?: {
    type: 'ignore';
    reason: string;
  };
};

type Dependency = {
  name: string;
  version: string;
};

async function fetchSnykVulnerabilities(
  snykTestResults: SnykTestProjectResult[],
  dependencies: Dependency[]
): Promise<Vulnerability[]> {
  const rules = await snykPolicy.load(process.cwd());
  const affectedDependencies: SnykVulnerability[] = [];

  snykTestResults.forEach((projectResult) => {
    projectResult.vulnerabilities.forEach((vuln) => {
      dependencies.forEach((dep) => {
        if (
          vuln.moduleName === dep.name &&
          vuln.from.includes(`${dep.name}@${dep.version}`)
        ) {
          affectedDependencies.push(vuln);
        }
      });
    });
  });

  const uniqueVulnerabilities = new Map();

  affectedDependencies.forEach((vuln) => {
    const key = `${vuln.name}@${vuln.version}_${vuln.id}`;
    const origin = '-';

    if (uniqueVulnerabilities.has(key)) {
      const existingVuln = uniqueVulnerabilities.get(key);
      if (!existingVuln.origins.includes(origin)) {
        existingVuln.origins.push(origin);
      }
    } else {
      uniqueVulnerabilities.set(key, {
        name: `${vuln.name}@${vuln.version}`,
        id: vuln.id,
        score: vuln.cvssScore,
        severity: `${vuln.severity
          .charAt(0)
          .toUpperCase()}${vuln.severity.slice(1)}`,
        fixedIn: vuln.fixedIn.join(', '),
        origins: [origin],
        policy: snykPolicy.getByVuln(rules, vuln),
      });
    }
  });

  const sortedVulnerabilities = Array.from(uniqueVulnerabilities.values()).sort(
    (a, b) => a.name.localeCompare(b.name)
  );

  return sortedVulnerabilities;
}

function printTable(title: string, vulnerabilities: Vulnerability[]) {
  console.info(`## ${title} (${vulnerabilities.length} vulnerabilities)`);
  console.info('| dep@version | id | score | fixed in | origin | ignored |');
  console.info('| ----------- | -- | ----- | -------- | ------ | ------- |');

  const sortedVulns = _.orderBy(
    vulnerabilities,
    ['score', 'name'],
    ['desc', 'asc']
  );
  for (const vuln of sortedVulns) {
    const severity = `${vuln.score} (${vuln.severity})`;
    const ignored =
      vuln.policy?.type === 'ignore'
        ? vuln.policy?.reason
        : !vuln.fixedIn
        ? 'Remediation not available yet'
        : '-';

    console.info(
      `| ${vuln.name} | ${vuln.id} | ${severity} | ${vuln.fixedIn} | ${ignored} |`
    );
  }
}

function fail(failOn: KnownSeverity, bundleVulnerabilities: Vulnerability[]) {
  const minScore = severityToScore(failOn) ?? 0;
  for (const vuln of bundleVulnerabilities) {
    if (
      (vuln.score === undefined || vuln.score >= minScore) && // >= severity, always fail if unknown
      vuln.fixedIn && // a fix is a available
      vuln.policy?.type !== 'ignore' // not ignored
    ) {
      console.error(
        chalk.red(
          `Vulnerabilities check failed: found vulnerabilies >= "${failOn}"`
        )
      );
      process.exit(1);
    }
  }
}

export async function generateVulnerabilityReport(options: {
  dependencyFiles: string[];
  snykReports: string[];
  failOn: KnownSeverity;
}): Promise<void> {
  const productionDependencies = await loadDependencyFiles(
    options.dependencyFiles
  );

  const snykTestResult = await loadReports(options.snykReports);

  const bundleVulnerabilities = await fetchSnykVulnerabilities(
    snykTestResult,
    productionDependencies
  );

  printTable('Snyk Report', bundleVulnerabilities);

  if (options.failOn) {
    fail(options.failOn, bundleVulnerabilities);
  }
}
