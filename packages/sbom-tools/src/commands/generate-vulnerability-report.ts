import { promises as fs } from 'fs';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const snykPolicy = require('snyk-policy');
import _ from 'lodash';

import { loadDependencyFiles } from '../load-dependency-files';
import type {
  KnownSeverity,
  SnykTestProjectResult,
  SnykVulnerability,
} from '../snyk-vulnerability';
import { severityToScore } from '../snyk-vulnerability';
import { Command } from 'commander';

export async function loadReports(
  files: string[]
): Promise<SnykTestProjectResult[]> {
  // turns single project result to a multi-project one, to simplify further
  // processing
  return (
    await Promise.all(
      files.map(async (fileName) =>
        JSON.parse(await fs.readFile(fileName, 'utf-8'))
      )
    )
  ).flat();
}

type Vulnerability = {
  name: string;
  id: string;
  score: number;
  fixedIn: string;
  origins: string[];
  severity: string;
  policy?: {
    type: 'ignore';
    reason: string;
    expires: any;
  };
};

type Dependency = {
  name: string;
  version: string;
};

type SnykPolicyRules = any;

function filterApplicableVulnerabilities(
  snykTestResults: SnykTestProjectResult[],
  dependencies: Dependency[],
  rules: SnykPolicyRules
): Vulnerability[] {
  const affectedDependencies: SnykVulnerability[] = [];

  snykTestResults.forEach((projectResult) => {
    projectResult.vulnerabilities.forEach((vuln) => {
      dependencies.forEach((dep) => {
        if (
          vuln.moduleName === dep.name &&
          vuln.from.includes(`${dep.name}@${dep.version}`)
        ) {
          affectedDependencies.push(vuln);
        }
      });
    });
  });

  const uniqueVulnerabilities = new Map();

  affectedDependencies.forEach((vuln) => {
    const key = `${vuln.name}@${vuln.version}_${vuln.id}`;
    const origin = '-';

    if (uniqueVulnerabilities.has(key)) {
      const existingVuln = uniqueVulnerabilities.get(key);
      if (!existingVuln.origins.includes(origin)) {
        existingVuln.origins.push(origin);
      }
    } else {
      uniqueVulnerabilities.set(key, {
        name: `${vuln.name}@${vuln.version}`,
        id: vuln.id,
        score: vuln.cvssScore,
        severity: `${vuln.severity
          .charAt(0)
          .toUpperCase()}${vuln.severity.slice(1)}`,
        fixedIn: vuln.fixedIn.join(', '),
        origins: [origin],
        policy: snykPolicy.getByVuln(rules, vuln),
      });
    }
  });

  const sortedVulnerabilities = Array.from(uniqueVulnerabilities.values()).sort(
    (a, b) => a.name.localeCompare(b.name)
  );

  return sortedVulnerabilities;
}

function formatIgnored(vuln: Vulnerability): string {
  if (!hasKnownRemediation(vuln)) {
    return 'Reason: Remediation not available yet';
  }

  if (hasIgnorePolicy(vuln)) {
    const expired = hasExpiredPolicy(vuln) ? ' (Expired)' : '';
    return `Reason: ${vuln.policy?.reason ?? 'unknown'}${expired}`;
  }

  return '-';
}

function generateTable(vulnerabilities: Vulnerability[]): string {
  let output = '';

  output += `## Vulnerabilities Report (${vulnerabilities.length} vulnerabilities)\n`;
  output += '| dep@version | id | score | fixed in | origin | ignored |\n';
  output += '| ----------- | -- | ----- | -------- | ------ | ------- |\n';

  const sortedVulns = _.orderBy(
    vulnerabilities,
    ['score', 'name'],
    ['desc', 'asc']
  );
  for (const vuln of sortedVulns) {
    const severity = `${vuln.score ?? '?'} (${vuln.severity})`;
    const ignored = formatIgnored(vuln);

    output += `| ${vuln.name} | ${vuln.id} | ${severity} | ${
      vuln.fixedIn || 'N/A'
    } | ${ignored} |\n`;
  }

  return output;
}

function isIgnored(vuln: Vulnerability) {
  return hasIgnorePolicy(vuln) && !hasExpiredPolicy(vuln);
}

function hasIgnorePolicy(vuln: Vulnerability) {
  return vuln.policy?.type === 'ignore';
}

function hasExpiredPolicy(vuln: Vulnerability) {
  return new Date() >= vuln.policy?.expires;
}

function hasKnownRemediation(vuln: Vulnerability) {
  return !!vuln.fixedIn;
}

function fail(failOn: KnownSeverity, bundleVulnerabilities: Vulnerability[]) {
  const minScore = severityToScore(failOn) ?? 0;

  for (const vuln of bundleVulnerabilities) {
    if (
      (vuln.score === undefined || vuln.score >= minScore) && // >= severity, always fail if unknown
      hasKnownRemediation(vuln) &&
      !isIgnored(vuln)
    ) {
      throw new Error(
        `Vulnerabilities check failed: found vulnerabilities >= "${failOn}"`
      );
    }
  }
}

export async function generateVulnerabilityReport(options: {
  dependencyFiles: string[];
  snykReports: string[];
  snykPolicyPath?: string;
  failOn?: KnownSeverity;
  printResult?: (result: string) => void;
}): Promise<void> {
  const productionDependencies = await loadDependencyFiles(
    options.dependencyFiles
  );

  const snykTestResult = await loadReports(options.snykReports);
  const rules = await snykPolicy.load(options.snykPolicyPath ?? process.cwd(), {
    loose: true,
  });

  const applicableVulnerabilities = filterApplicableVulnerabilities(
    snykTestResult,
    productionDependencies,
    rules
  );

  (options.printResult ?? console.info)(
    generateTable(applicableVulnerabilities)
  );

  if (options.failOn) {
    fail(options.failOn, applicableVulnerabilities);
  }
}

function commaSeparatedList(value: string) {
  return value.split(',');
}

export const command = new Command('generate-vulnerability-report')
  .description(
    'Generate a report of snyk vulnerabilities applicable to a list of dependencies'
  )
  .option(
    '--dependencies <paths>',
    'Comma-separated list of dependency files',
    commaSeparatedList,
    []
  )
  .option(
    '--snyk-reports <paths>',
    'Comma-separated list of snyk result files',
    commaSeparatedList,
    []
  )
  .option('--fail-on [level]', 'Fail on the specified severity level')
  .option('--snyk-policy-path [path]', 'Snyk policy path')
  .action(async (options) => {
    await generateVulnerabilityReport({
      dependencyFiles: options.dependencies,
      snykReports: options.snykReports,
      failOn: options.failOn,
      snykPolicyPath: options.snykPolicyPath,
    });
  });
